
---------------------------------------------app.py 1--------------------------------------------

from flask import Flask, jsonify, request
from flask_cors import CORS
import pandas as pd
from scoring import load_and_prepare, compute_latest, score_and_rank, apply_overrides
import os

CSV_PATH = os.path.join(os.path.dirname(__file__), '..', 'kmrl_train_30day_log.csv')
app = Flask(__name__)
CORS(app)

def load_data():
    df = pd.read_csv(CSV_PATH)
    df = load_and_prepare(df)
    return df

@app.route('/api/latest_snapshot', methods=['GET'])
def latest_snapshot():
    df = load_data()
    latest, latest_date = compute_latest(df)
    out = latest[['train_id','train_status','fitness_validity_date','fitness_days_left','job_card_status','mileage_30','branding_active','days_since_clean','needs_cleaning']].copy()
    out['fitness_validity_date'] = out['fitness_validity_date'].dt.strftime('%Y-%m-%d')
    return jsonify({'latest_date': str(latest_date.date()), 'snapshot': out.to_dict(orient='records')})

@app.route('/api/recommendation', methods=['GET'])
def recommendation():
    df = load_data()
    latest, latest_date = compute_latest(df)
    ranked = score_and_rank(latest)
    out = ranked[['train_id','recommended_action','composite_score','fitness_days_left','mileage_30','job_card_status','branding_active','days_since_clean']].copy()
    out['composite_score'] = out['composite_score'].round(4)
    return jsonify({'latest_date': str(latest_date.date()), 'recommendations': out.to_dict(orient='records')})

@app.route('/api/whatif', methods=['POST'])
def whatif():
    payload = request.get_json() or {}
    overrides = payload.get('overrides', {})
    df = load_data()
    latest, latest_date = compute_latest(df)
    latest = apply_overrides(latest, overrides)
    latest['fitness_days_left'] = (pd.to_datetime(latest['fitness_validity_date']) - latest_date).dt.days.fillna(0).astype(int)
    ranked = score_and_rank(latest)
    out = ranked[['train_id','recommended_action','composite_score','fitness_days_left','mileage_30','job_card_status','branding_active','days_since_clean']].copy()
    out['composite_score'] = out['composite_score'].round(4)
    return jsonify({'latest_date': str(latest_date.date()), 'recommendations': out.to_dict(orient='records')})

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)




--------------------------------------index.html 1-----------------------------------------------
<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>KMRL Induction Prototype</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>
<body class="bg-gray-50 p-6">
  <div id="root"></div>
  <script type="text/babel">
    const {useState, useEffect} = React;

    function App(){
      const [snapshot, setSnapshot] = useState([]);
      const [recs, setRecs] = useState([]);

      useEffect(()=>{
        fetch('http://localhost:5000/api/latest_snapshot').then(r=>r.json()).then(d=>{ setSnapshot(d.snapshot || []); });
        fetch('http://localhost:5000/api/recommendation').then(r=>r.json()).then(d=>{ setRecs(d.recommendations || []); });
      },[]);

      const doWhatIf = async(trainId) => {
        const payload = { overrides: {} };
        payload.overrides[trainId] = { mark_cleaned: true };
        const res = await fetch('http://localhost:5000/api/whatif', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
        const data = await res.json();
        setRecs(data.recommendations || []);
      };

      return (
        <div className="max-w-6xl mx-auto">
          <h1 className="text-2xl font-bold mb-4">KMRL â€” Induction Planner Prototype</h1>
          <div className="grid grid-cols-3 gap-4">
            <div className="col-span-1 bg-white p-4 rounded shadow">
              <h2 className="font-semibold">Latest Snapshot</h2>
              <div className="text-sm mt-2 space-y-2 max-h-96 overflow-auto">
                {snapshot.slice(0,25).map(s=>(
                  <div key={s.train_id} className="border p-2 rounded">
                    <div className="font-medium">{s.train_id} â€” {s.train_status}</div>
                    <div className="text-xs">Fitness days left: {s.fitness_days_left} | Mileage30: {s.mileage_30}</div>
                  </div>
                ))}
              </div>
            </div>
            <div className="col-span-2 bg-white p-4 rounded shadow">
              <h2 className="font-semibold">Recommendations (ranked)</h2>
              <div className="mt-2 space-y-2">
                {recs.map(r=>(
                  <div key={r.train_id} className="flex justify-between items-center border p-2 rounded">
                    <div>
                      <div className="font-medium">{r.train_id} â€” {r.recommended_action}</div>
                      <div className="text-xs">Score: {r.composite_score} | Fitness: {r.fitness_days_left}d | Mileage: {r.mileage_30}km</div>
                    </div>
                    <div className="flex gap-2">
                      <button onClick={()=>doWhatIf(r.train_id)} className="px-3 py-1 rounded bg-blue-100 text-sm">What-If: Mark Cleaned</button>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
  </script>
</body>
</html>





-------------------------------------------app.py 2-------------------------------------------
from flask import Flask, jsonify
from flask_cors import CORS
import pandas as pd

app = Flask(__name__)
CORS(app)

CSV_PATH = "../kmrl_train_30day_log.csv"  # Adjust path if needed

def load_data():
    df = pd.read_csv(
        CSV_PATH,
        parse_dates=['Date', 'Fitness Validity', 'Last Cleaned'],
        dayfirst=True  # important for dd-mm-yyyy
    )
    df.columns = df.columns.str.strip()  # Remove extra spaces

    # Ensure datetime (in case some strings still exist)
    for col in ['Date', 'Fitness Validity', 'Last Cleaned']:
        df[col] = pd.to_datetime(df[col], dayfirst=True, errors='coerce')

    return df


def get_train_status():
    df = load_data()
    status_list = []

    for train_id, group in df.groupby("Train ID"):
        last_run_date = group['Date'].max()
        next_inspection = group['Fitness Validity'].max()
        job_status = group['Job-card Status'].iloc[-1]
        yard_pos = group['Yard Position'].iloc[-1]
        operational_status = group['Status'].iloc[-1]

        days_until_inspection = (next_inspection - pd.Timestamp.now()).days

        # Determine status and consequences
        if job_status.lower().startswith("open-critical") or days_until_inspection < 0:
            status = "Critical - Needs Maintenance"
            consequences = ["High risk if train runs", "Possible delay"]
        elif job_status.lower().startswith("open") or days_until_inspection <= 5:
            status = "Warning - Soon due"
            consequences = ["Minor risk", "May require attention soon"]
        else:
            status = "Healthy"
            consequences = []

        status_list.append({
            "train_id": train_id,
            "last_run_date": last_run_date.strftime("%Y-%m-%d"),
            "next_inspection": next_inspection.strftime("%Y-%m-%d"),
            "yard_position": yard_pos,
            "status": status,
            "consequences_if_missed": consequences,
            "operational_status": operational_status
        })

    return status_list

def get_recommendations():
    # Trains prioritized by criticality
    all_status = get_train_status()
    # Critical first, then Warning, then Healthy
    recommendations = sorted(
        all_status,
        key=lambda x: {"Critical - Needs Maintenance": 0, "Warning - Soon due": 1, "Healthy": 2}[x['status']]
    )
    for rec in recommendations:
        rec['reason_for_servicing'] = ""
        if rec['status'] == "Critical - Needs Maintenance":
            rec['reason_for_servicing'] = "Missed inspection / Open-Critical job"
        elif rec['status'] == "Warning - Soon due":
            rec['reason_for_servicing'] = "Inspection due soon / Open-Minor job"
        else:
            rec['reason_for_servicing'] = "Routine check"

    return recommendations

@app.route("/api/current_status")
def current_status():
    return jsonify(get_train_status())

@app.route("/api/recommendation")
def recommendation():
    return jsonify(get_recommendations())

if __name__ == "__main__":
    app.run(debug=True)


--------------------------------------------idex.html 2---------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KMRL â€“ Induction Planner Prototype</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 p-5">

    <h1 class="text-3xl font-bold mb-5">KMRL â€“ Induction Planner Prototype</h1>

    <h2 class="text-xl font-semibold mb-3">Current Train Status</h2>
    <table class="min-w-full bg-white shadow-md rounded mb-10" id="status-table">
        <thead>
            <tr class="bg-gray-200">
                <th class="py-2 px-4">Train ID</th>
                <th class="py-2 px-4">Last Run</th>
                <th class="py-2 px-4">Next Inspection</th>
                <th class="py-2 px-4">Yard Position</th>
                <th class="py-2 px-4">Status</th>
                <th class="py-2 px-4">Consequences</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <h2 class="text-xl font-semibold mb-3">Recommended Next Trains for Servicing</h2>
    <table class="min-w-full bg-white shadow-md rounded" id="recommendation-table">
        <thead>
            <tr class="bg-gray-200">
                <th class="py-2 px-4">Train ID</th>
                <th class="py-2 px-4">Status</th>
                <th class="py-2 px-4">Reason for Servicing</th>
                <th class="py-2 px-4">Consequences</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

<script>
async function fetchStatus() {
    const res = await fetch("http://localhost:5000/api/current_status");
    const data = await res.json();

    const tbody = document.querySelector("#status-table tbody");
    tbody.innerHTML = "";
    data.forEach(train => {
        let statusColor = "bg-green-200";
        if(train.status.includes("Critical")) statusColor = "bg-red-200";
        else if(train.status.includes("Warning")) statusColor = "bg-yellow-200";

        tbody.innerHTML += `<tr class="${statusColor}">
            <td class="py-2 px-4">${train.train_id}</td>
            <td class="py-2 px-4">${train.last_run_date}</td>
            <td class="py-2 px-4">${train.next_inspection}</td>
            <td class="py-2 px-4">${train.yard_position}</td>
            <td class="py-2 px-4 font-bold">${train.status}</td>
            <td class="py-2 px-4">${train.consequences_if_missed.join(", ")}</td>
        </tr>`;
    });
}

async function fetchRecommendations() {
    const res = await fetch("http://localhost:5000/api/recommendation");
    const data = await res.json();

    const tbody = document.querySelector("#recommendation-table tbody");
    tbody.innerHTML = "";
    data.forEach(train => {
        tbody.innerHTML += `<tr class="bg-gray-100">
            <td class="py-2 px-4">${train.train_id}</td>
            <td class="py-2 px-4">${train.status}</td>
            <td class="py-2 px-4">${train.reason_for_servicing}</td>
            <td class="py-2 px-4">${train.consequences_if_missed.join(", ")}</td>
        </tr>`;
    });
}

// Initial fetch
fetchStatus();
fetchRecommendations();

// Refresh every 60 seconds
setInterval(fetchStatus, 60000);
setInterval(fetchRecommendations, 60000);
</script>

</body>
</html>


----------------------------------------------index.html 3--------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>KMRL AI Scheduling Dashboard</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <h1>ðŸš‡ KMRL AI-Driven Train Scheduling Dashboard</h1>
    <p>Smart Status â€¢ Predictive Maintenance â€¢ Yard Overview</p>
  </header>

  <main>
    <section id="yard-map-section">
      <h2>Train Yard Overview</h2>
      <div id="yard-map"></div>
    </section>

    <section id="status-section">
      <h2>Current Train Status</h2>
      <div id="status-container" class="scrollable"></div>
    </section>

    <section id="recommend-section">
      <h2>Service Recommendations</h2>
      <div id="recommend-container" class="scrollable"></div>
    </section>
  </main>

  <footer>
    <p>Powered by VisionForge âš¡ | Kochi Metro Rail Ltd</p>
  </footer>

  <script src="script.js"></script>
</body>
</html>
----------------------------------------------style.css 3---------------------------------
body {
  font-family: "Segoe UI", sans-serif;
  background: radial-gradient(circle at top, #001f3f, #000);
  color: #fff;
  margin: 0;
  overflow-x: hidden;
}

header {
  text-align: center;
  padding: 25px 10px;
  background: rgba(0, 128, 255, 0.1);
  border-bottom: 2px solid cyan;
  box-shadow: 0 0 10px cyan;
}

header h1 {
  font-size: 2rem;
  color: cyan;
  text-shadow: 0 0 15px cyan;
  animation: glowPulse 3s infinite alternate;
}

header p {
  color: #aaa;
}

@keyframes glowPulse {
  from { text-shadow: 0 0 10px cyan; }
  to { text-shadow: 0 0 25px cyan, 0 0 50px cyan; }
}

main {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-around;
  padding: 20px;
}

section {
  flex: 1 1 30%;
  margin: 10px;
  background: rgba(0, 0, 50, 0.4);
  border: 1px solid cyan;
  border-radius: 15px;
  padding: 15px;
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
  backdrop-filter: blur(6px);
  min-width: 350px;
}

h2 {
  text-align: center;
  color: cyan;
  margin-bottom: 10px;
  text-shadow: 0 0 10px cyan;
}

.scrollable {
  max-height: 400px;
  overflow-y: auto;
  padding: 10px;
}

/* Yard Map Styling */
#yard-map {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  grid-gap: 15px;
  justify-items: center;
  padding: 10px;
}

.train {
  width: 100px;
  height: 60px;
  background: linear-gradient(135deg, #00ffff55, #0077ffaa);
  border: 1px solid cyan;
  border-radius: 10px;
  box-shadow: 0 0 15px cyan;
  text-align: center;
  padding-top: 5px;
  position: relative;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.train:hover {
  transform: scale(1.1);
  box-shadow: 0 0 25px lime;
}

.train.critical { background: linear-gradient(135deg, #ff000080, #ff5050aa); box-shadow: 0 0 25px red; }
.train.minor { background: linear-gradient(135deg, #ffaa0080, #ffdd55aa); box-shadow: 0 0 20px gold; }
.train.healthy { background: linear-gradient(135deg, #00ff8080, #00ffaa); box-shadow: 0 0 20px lime; }

/* Status and Recommendation Cards */
.card {
  background: rgba(0, 0, 50, 0.5);
  border: 1px solid cyan;
  border-radius: 12px;
  padding: 10px;
  margin-bottom: 10px;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
  transition: transform 0.2s ease;
}
.card:hover { transform: scale(1.02); }

.card h3 {
  margin: 0;
  color: #00ffff;
}
.card p {
  font-size: 0.9em;
  color: #ddd;
}
footer {
  text-align: center;
  padding: 15px;
  font-size: 0.8em;
  color: #999;
  border-top: 1px solid cyan;
  margin-top: 30px;
}
-------------------------------------------------------script.js 3----------------------------
const BACKEND_URL = "http://127.0.0.1:5000";

async function fetchData(endpoint) {
  const res = await fetch(`${BACKEND_URL}${endpoint}`);
  return res.json();
}

function createCard(train) {
  return `
    <div class="card">
      <h3>Train ${train.train_id}</h3>
      <p><b>Yard Position:</b> ${train.yard_position}</p>
      <p><b>Status:</b> ${train.status}</p>
      <p><b>Fitness:</b> ${train.fitness_status}</p>
      <p><b>Last Run:</b> ${train.last_run_date}</p>
      <p><b>Next Service:</b> ${train.next_service_due_date}</p>
      <p><b>Consequence:</b> ${train.consequence_if_skipped}</p>
    </div>
  `;
}

function createRecommendation(rec) {
  return `
    <div class="card">
      <h3>ðŸš† Train ${rec.train_id}</h3>
      <p><b>Reason:</b> ${rec.reason}</p>
      <p><b>Fitness Status:</b> ${rec.fitness_status}</p>
      <p><b>Consequence:</b> ${rec.consequence_if_skipped}</p>
    </div>
  `;
}

function createTrainIcon(train) {
  let cls = "train healthy";
  if (train.fitness_status === "Critical") cls = "train critical";
  else if (train.fitness_status === "Minor") cls = "train minor";

  return `
    <div class="${cls}">
      <strong>${train.train_id}</strong><br/>
      <small>${train.yard_position}</small>
    </div>
  `;
}

async function loadDashboard() {
  const statusContainer = document.getElementById("status-container");
  const recommendContainer = document.getElementById("recommend-container");
  const yardMap = document.getElementById("yard-map");

  const [statusData, recData] = await Promise.all([
    fetchData("/api/current_status"),
    fetchData("/api/recommendation")
  ]);

  statusContainer.innerHTML = statusData.map(createCard).join("");
  recommendContainer.innerHTML = recData.map(createRecommendation).join("");
  yardMap.innerHTML = statusData.map(createTrainIcon).join("");

  animateTrains();
}

function animateTrains() {
  const trains = document.querySelectorAll(".train");
  trains.forEach(train => {
    train.animate(
      [
        { transform: "translateY(0px)" },
        { transform: "translateY(-5px)" },
        { transform: "translateY(0px)" }
      ],
      { duration: 3000 + Math.random() * 2000, iterations: Infinity }
    );
  });
}

loadDashboard();


---------------------------------------------index.html 4--------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KMRL â€” AI Scheduling Control Center</title>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <link rel="stylesheet" href="style.css" />
  <script defer src="script.js"></script>
</head>
<body>
  <header>
    <div class="brand">
      <h1>ðŸš† KMRL AI Scheduling Control Center</h1>
      <p class="sub">Live yard map â€¢ Predictive maintenance â€¢ Recommendations</p>
    </div>
    <div class="header-stats">
      <div class="stat" id="stat-total">Trains: â€”</div>
      <div class="stat" id="stat-critical">Critical: â€”</div>
      <div class="stat" id="stat-minor">Minor: â€”</div>
      <div class="stat" id="stat-healthy">Healthy: â€”</div>
    </div>
  </header>

  <main>
    <section class="left">
      <div class="panel">
        <h2>Yard Map â€” Animated Tracks</h2>
        <div id="yard" class="yard">
          <svg id="tracks-svg" viewBox="0 0 1000 500" preserveAspectRatio="xMidYMid meet"></svg>
          <div id="trains-layer" class="trains-layer"></div>
        </div>
      </div>

      <div class="panel small">
        <h2>Recommendations</h2>
        <div id="recommend-list" class="recommend-list"></div>
      </div>
    </section>

    <section class="right">
      <div class="panel">
        <h2>Live Status Table</h2>
        <div class="table-wrap">
          <table id="status-table">
            <thead>
              <tr>
                <th style="width:110px">Train</th>
                <th style="width:140px">Yard</th>
                <th style="width:100px">Fitness</th>
                <th style="width:130px">Next Service</th>
                <th style="width:80px">Days Left</th>
                <th>Consequence</th>
              </tr>
            </thead>
            <tbody id="status-body"></tbody>
          </table>
        </div>
      </div>

      <div class="panel small">
        <h2>Health Summary</h2>
        <canvas id="healthChart" width="300" height="240"></canvas>
      </div>
    </section>
  </main>

  <!-- details modal -->
  <div id="detail-modal" class="modal hidden">
    <div class="modal-card">
      <button id="modal-close" class="modal-close">âœ•</button>
      <div id="modal-content"></div>
    </div>
  </div>

  <footer>
    <small>VisionForge â€¢ KMRL prototype â€” data from kmrl_train_30day_log.csv</small>
  </footer>
</body>
</html>

----------------------------------------style.css 4----------------------------------------------
/* Basic theme */
:root{
  --bg:#061025;
  --panel:#071829;
  --accent:#00f0ff;
  --soft:#0ea5a4;
  --glass: rgba(255,255,255,0.03);
}
*{box-sizing:border-box}
body{
  margin:0;
  font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;
  background: linear-gradient(180deg,#020814 0%, #061025 60%);
  color:#e6f9fb;
  -webkit-font-smoothing:antialiased;
}

/* Header */
header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:18px 28px;
  border-bottom:1px solid rgba(0,255,255,0.05);
  gap:20px;
}
.brand h1{margin:0;font-size:20px;color:var(--accent);text-shadow:0 0 12px rgba(0,240,255,0.15)}
.sub{margin:2px 0 0;font-size:12px;color:#9fd9dc}
.header-stats{display:flex;gap:12px}
.stat{
  background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  padding:8px 12px;border-radius:10px;font-weight:600;font-size:13px;border:1px solid rgba(0,240,255,0.06)
}

/* Layout */
main{display:grid;grid-template-columns: 1fr 420px; gap:22px;padding:22px}
.panel{
  background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  border-radius:12px;padding:14px;border:1px solid rgba(0,240,255,0.06);
  box-shadow: 0 6px 30px rgba(0,0,0,0.4);
}
.panel.small{margin-top:18px;}
.left{display:flex;flex-direction:column;gap:18px}
.right{display:flex;flex-direction:column;gap:18px}

/* Yard */
#yard{position:relative;height:420px;border-radius:8px;overflow:hidden}
#tracks-svg{position:absolute;inset:0;width:100%;height:100%}
.trains-layer{position:absolute;inset:0;pointer-events:none}

/* Train icon */
.train {
  position:absolute;
  width:110px;
  height:42px;
  border-radius:8px;
  display:flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  padding:6px 10px;
  color:#041219;font-weight:700;
  transform:translate(-50%,-50%);
  pointer-events:auto;
  cursor:pointer;
  box-shadow:0 6px 18px rgba(0,0,0,0.5);
  transition: transform .18s ease, box-shadow .18s ease;
  will-change: transform;
}
.train:hover{transform:translate(-50%,-50%) scale(1.06); box-shadow:0 12px 30px rgba(0,0,0,0.6)}
.train .id {font-size:13px}
.train .slot {font-size:10px;color:#022}

/* Colors & animations */
.train.critical{background:linear-gradient(90deg,#ff6b6b,#ff3d3d); color:white; animation:glowRed 1.6s infinite}
.train.minor{background:linear-gradient(90deg,#ffd27a,#ffb84d); color:#102; animation:glowOrange 1.8s infinite}
.train.healthy{background:linear-gradient(90deg,#7bf5c6,#2bd8a6); color:#012; animation:float 3s ease-in-out infinite}

@keyframes glowRed{0%{box-shadow:0 0 12px rgba(255,90,90,0.5)}50%{box-shadow:0 0 28px rgba(255,60,60,0.85)}100%{box-shadow:0 0 12px rgba(255,90,90,0.5)}}
@keyframes glowOrange{0%{box-shadow:0 0 8px rgba(255,190,90,0.4)}50%{box-shadow:0 0 18px rgba(255,160,60,0.7)}100%{box-shadow:0 0 8px rgba(255,190,90,0.4)}}
@keyframes float{0%{transform:translate(-50%,-55%)}50%{transform:translate(-50%,-48%)}100%{transform:translate(-50%,-55%)}}

/* Trail effect */
.train::after{
  content:"";
  position:absolute;left:50%;top:100%;width:140px;height:6px;border-radius:6px;transform:translateX(-50%);opacity:0.12;filter:blur(6px);
  background:linear-gradient(90deg, rgba(0,0,0,0.45), rgba(0,0,0,0.1));
}

/* Table */
.table-wrap{overflow:auto;max-height:320px}
table{width:100%;border-collapse:collapse;color:#e6fbfb}
th,td{padding:8px 10px;text-align:center;border-bottom:1px solid rgba(255,255,255,0.03)}
th{background:linear-gradient(90deg,#003a5a,#006b8b);color:#fff;position:sticky;top:0}
td.critical{background:linear-gradient(90deg,#ff6b6b,#ff4d4d);color:#fff}
td.minor{background:linear-gradient(90deg,#ffd27a,#ffb84d);color:#073}
td.healthy{background:linear-gradient(90deg,#7bf5c6,#2bd8a6);color:#022}

/* Recommendations */
.recommend-list{display:flex;flex-direction:column;gap:8px;max-height:240px;overflow:auto}
.rec-card{padding:10px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border:1px solid rgba(255,255,255,0.03)}
.rec-card.critical{border-left:4px solid #ff4d4d}
.rec-card.minor{border-left:4px solid #ffb84d}
.rec-card.healthy{border-left:4px solid #2bd8a6}

/* Modal */
.modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:60}
.modal.hidden{display:none}
.modal-card{background:var(--panel);padding:18px;border-radius:10px;width:min(720px,92%);position:relative;border:1px solid rgba(0,240,255,0.06)}
.modal-close{position:absolute;right:8px;top:8px;background:transparent;border:0;color:#fff;font-size:18px;cursor:pointer}

/* Footer */
footer{padding:12px;text-align:center;color:#89dfe0;background:linear-gradient(180deg,#00141f,#001219);margin-top:18px;border-top:1px solid rgba(0,240,255,0.03)}

/* Responsive */
@media(max-width:980px){
  main{grid-template-columns:1fr; padding:12px}
  .trains-layer{transform:scale(0.9)}
  .brand h1{font-size:18px}
}


-----------------------------script.js 4-----------------------------------------------
// script.js â€” connects to /api/current_status and /api/recommendation
const API_BASE = "http://127.0.0.1:5000";
const REFRESH_MS = 8000;

// map tracks & slots into coordinates on 1000x500 viewBox
// we'll use tracks 1..4 (y positions) and slots 1..6 (x positions)
const TRACK_Y = {
  1: 80,
  2: 180,
  3: 280,
  4: 380
};
const SLOT_X = {
  1: 100, 2: 230, 3: 360, 4: 490, 5: 620, 6: 750
};

let healthChart = null;

async function fetchAll() {
  const [statusRes, recRes] = await Promise.all([
    fetch(`${API_BASE}/api/current_status`),
    fetch(`${API_BASE}/api/recommendation`)
  ]);
  if (!statusRes.ok || !recRes.ok) throw new Error("API fetch failed");
  const statusData = await statusRes.json();
  const recData = await recRes.json();
  return { statusData, recData };
}

function parseYardPosition(posStr) {
  // expected format: "Track-3, Slot-2" or "Track-3 Slot-2" or "Track-3"
  if (!posStr) return { x: 500, y: 250, track: null, slot: null };
  const s = posStr.replace(/\s/g, "");
  const match = s.match(/Track-(\d+).*Slot-(\d+)/i);
  if (match) {
    const track = Number(match[1]), slot = Number(match[2]);
    return { x: SLOT_X[slot] || 500, y: TRACK_Y[track] || 250, track, slot };
  }
  // try only track
  const m2 = s.match(/Track-(\d+)/i);
  if (m2) {
    const track = Number(m2[1]);
    return { x: 500, y: TRACK_Y[track] || 250, track, slot: null };
  }
  return { x: 500, y: 250, track: null, slot: null };
}

function renderTracksSVG() {
  const svg = document.getElementById("tracks-svg");
  svg.innerHTML = ""; // clear
  // draw horizontal tracks lines (4 tracks)
  for (let t = 1; t <= 4; t++) {
    const y = TRACK_Y[t];
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", 40);
    line.setAttribute("y1", y);
    line.setAttribute("x2", 960);
    line.setAttribute("y2", y);
    line.setAttribute("stroke", "#063046");
    line.setAttribute("stroke-width", "16");
    line.setAttribute("stroke-linecap", "round");
    svg.appendChild(line);
    // small slot markers
    for (let s = 1; s <= 6; s++) {
      const cx = SLOT_X[s];
      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("cx", cx);
      circle.setAttribute("cy", y);
      circle.setAttribute("r", 6);
      circle.setAttribute("fill", "rgba(0,240,255,0.06)");
      svg.appendChild(circle);
    }
  }
}

function clearTrainsLayer() {
  document.getElementById("trains-layer").innerHTML = "";
}

function createTrainElement(train, idx) {
  // train: object from backend with keys like train_id, yard_position, fitness_status, next_service_due_date...
  const div = document.createElement("div");
  div.className = "train";
  const fitness = (train.fitness_status || "Healthy").toLowerCase();
  div.classList.add(fitness);
  div.dataset.id = train.train_id;

  // parse yard position
  const pos = parseYardPosition(train.yard_position || "");
  // set initial position (we center icon)
  div.style.left = `${pos.x}px`;
  div.style.top = `${pos.y}px`;
  div.style.pointerEvents = "auto";

  div.innerHTML = `<div class="id">${train.train_id}</div><div class="slot">${train.yard_position || ""}</div>`;

  // store info for modal tooltip
  div.dataset.info = JSON.stringify(train);

  // subtle random movement path using CSS translate animation via JS
  const dx = (Math.random() - 0.5) * 40; // small horizontal bob
  const dy = (Math.random() - 0.5) * 10;
  const dur = 4000 + (idx % 5) * 600;
  // create CSS animation by setting style animation with unique name
  const animName = `move${idx}`;
  const styleTag = document.createElement("style");
  styleTag.textContent = `
    @keyframes ${animName}{
      0%{ transform: translate(0px,0px) }
      50%{ transform: translate(${dx}px, ${dy}px) }
      100%{ transform: translate(0px,0px) }
    }
  `;
  document.head.appendChild(styleTag);
  div.style.animation = `${animName} ${dur}ms ease-in-out infinite`;

  // click handler opens modal
  div.addEventListener("click", (e) => {
    e.stopPropagation();
    showDetailModal(train);
  });

  return div;
}

function updateSummaryCounts(statusData) {
  const total = statusData.length;
  const critical = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "critical").length;
  const minor = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "minor").length;
  const healthy = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "healthy").length;

  document.getElementById("stat-total").textContent = `Trains: ${total}`;
  document.getElementById("stat-critical").textContent = `Critical: ${critical}`;
  document.getElementById("stat-minor").textContent = `Minor: ${minor}`;
  document.getElementById("stat-healthy").textContent = `Healthy: ${healthy}`;

  // update chart:
  updateHealthChart(critical, minor, healthy);
}

function updateHealthChart(critical, minor, healthy) {
  const ctx = document.getElementById("healthChart").getContext("2d");
  if (healthChart) {
    healthChart.data.datasets[0].data = [critical, minor, healthy];
    healthChart.update();
    return;
  }
  healthChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: ['Critical','Minor','Healthy'],
      datasets: [{
        data: [critical, minor, healthy],
        backgroundColor: ['#ff6b6b','#ffd27a','#7bf5c6'],
        borderWidth: 0
      }]
    },
    options: {
      responsive:true,
      plugins:{legend:{position:'bottom',labels:{color:'#dff'}}}
    }
  });
}

function renderStatusTable(statusData, recData) {
  const tbody = document.getElementById("status-body");
  tbody.innerHTML = "";
  statusData.forEach(train => {
    const match = recData.find(r => r.train_id === train.train_id) || {};
    const fitness = (train.fitness_status || "Healthy").toLowerCase();
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${train.train_id}</td>
      <td>${train.yard_position || 'â€”'}</td>
      <td class="${fitness}">${train.fitness_status || 'Healthy'}</td>
      <td>${train.next_service_due_date || 'â€”'}</td>
      <td>${train.days_until_next_service ?? 'â€”'}</td>
      <td>${match.consequence_if_skipped || train.consequence_if_skipped || 'â€”'}</td>
    `;
    tbody.appendChild(tr);
    // small reveal animation
    tr.style.opacity = 0;
    tr.style.transform = "translateY(6px)";
    setTimeout(()=>{ tr.style.transition="all .28s ease"; tr.style.opacity=1; tr.style.transform="translateY(0)"; }, 60);
  });
}

function renderRecommendations(recData) {
  const container = document.getElementById("recommend-list");
  container.innerHTML = "";
  if (!recData || recData.length === 0) {
    container.innerHTML = `<div class="rec-card">No immediate recommendations</div>`;
    return;
  }
  recData.slice(0,8).forEach(r => {
    const div = document.createElement("div");
    div.className = `rec-card ${(r.fitness_status||"healthy").toLowerCase()}`;
    div.innerHTML = `<strong>Train ${r.train_id}</strong>
      <div style="font-size:13px;margin-top:6px">${r.reason}</div>
      <div style="margin-top:8px;color:#bfe">${r.consequence_if_skipped}</div>`;
    div.addEventListener("click", ()=> showDetailModal(r));
    container.appendChild(div);
  });
}

// modal
function showDetailModal(obj) {
  const modal = document.getElementById("detail-modal");
  const content = document.getElementById("modal-content");
  content.innerHTML = `
    <h3 style="color:var(--accent)">Train ${obj.train_id || obj.train_id}</h3>
    <table style="width:100%;margin-top:8px;color:#dff">
      ${Object.entries(obj).map(([k,v])=>`<tr><td style="padding:6px 8px;border-bottom:1px solid rgba(255,255,255,0.03);font-weight:600;width:40%">${k}</td><td style="padding:6px 8px;border-bottom:1px solid rgba(255,255,255,0.03)">${v ?? ''}</td></tr>`).join("")}
    </table>
    <div style="margin-top:10px;text-align:right"><button id="modal-ok" style="padding:8px 12px;border-radius:8px;background:#00c3d6;border:0;color:#031">Close</button></div>
  `;
  modal.classList.remove("hidden");
  document.getElementById("modal-close").onclick = ()=> modal.classList.add("hidden");
  content.querySelector("#modal-ok").onclick = ()=> modal.classList.add("hidden");
}

document.getElementById("detail-modal").addEventListener("click",(e)=>{
  if (e.target.id === "detail-modal") e.target.classList.add("hidden");
});

// main refresh+render
async function refreshAll() {
  try {
    const { statusData, recData } = await fetchAll();
    // update summary/visuals
    updateSummaryCounts(statusData);
    renderStatusTable(statusData, recData);
    renderRecommendations(recData);

    // render trains in yard (animated)
    renderTracksSVG();
    clearTrainsLayer();
    const layer = document.getElementById("trains-layer");
    statusData.forEach((t, idx)=> {
      const el = createTrainElement(t, idx);
      layer.appendChild(el);
    });
  } catch (err) {
    console.error("Error refreshing:", err);
  }
}

// initial run + periodic refresh
refreshAll();
setInterval(refreshAll, REFRESH_MS);


-----------------------------------------index.html 5-------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KMRL â€” AI Scheduling Control Center</title>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <link rel="stylesheet" href="style.css" />
  <script defer src="script.js"></script>
</head>
<body>
  <!-- Animated background -->
  <div class="animated-bg">
    <div class="grid-overlay"></div>
    <div class="particle-container" id="particles"></div>
    <div class="glow-orbs">
      <div class="orb orb1"></div>
      <div class="orb orb2"></div>
      <div class="orb orb3"></div>
    </div>
  </div>

  <header>
    <div class="brand">
      <div class="logo-container">
        <div class="logo-pulse"></div>
        <i class="fas fa-train logo-icon"></i>
      </div>
      <div>
        <h1>KMRL AI Control Center</h1>
        <p class="sub"><span class="live-indicator"></span> Live Monitoring System â€¢ Real-time Analytics</p>
      </div>
    </div>
    <div class="header-stats">
      <div class="stat-card" id="stat-total">
        <i class="fas fa-subway"></i>
        <div class="stat-content">
          <span class="stat-value" data-value="0">0</span>
          <span class="stat-label">Total Trains</span>
        </div>
      </div>
      <div class="stat-card critical-stat" id="stat-critical">
        <i class="fas fa-exclamation-triangle"></i>
        <div class="stat-content">
          <span class="stat-value" data-value="0">0</span>
          <span class="stat-label">Critical</span>
        </div>
      </div>
      <div class="stat-card minor-stat" id="stat-minor">
        <i class="fas fa-exclamation-circle"></i>
        <div class="stat-content">
          <span class="stat-value" data-value="0">0</span>
          <span class="stat-label">Minor Issues</span>
        </div>
      </div>
      <div class="stat-card healthy-stat" id="stat-healthy">
        <i class="fas fa-check-circle"></i>
        <div class="stat-content">
          <span class="stat-value" data-value="0">0</span>
          <span class="stat-label">Healthy</span>
        </div>
      </div>
    </div>
  </header>

  <main>
    <section class="left">
      <div class="panel glass-panel">
        <div class="panel-header">
          <h2><i class="fas fa-map-marked-alt"></i> Live Yard Visualization</h2>
          <div class="panel-controls">
            <button class="control-btn" id="zoom-in"><i class="fas fa-search-plus"></i></button>
            <button class="control-btn" id="zoom-out"><i class="fas fa-search-minus"></i></button>
            <button class="control-btn" id="refresh-yard"><i class="fas fa-sync-alt"></i></button>
          </div>
        </div>
        <div id="yard" class="yard">
          <div class="yard-grid"></div>
          <svg id="tracks-svg" viewBox="0 0 1000 500" preserveAspectRatio="xMidYMid meet"></svg>
          <div id="trains-layer" class="trains-layer"></div>
          <div class="track-labels">
            <div class="track-label" style="top: 70px">Track 1</div>
            <div class="track-label" style="top: 170px">Track 2</div>
            <div class="track-label" style="top: 270px">Track 3</div>
            <div class="track-label" style="top: 370px">Track 4</div>
          </div>
        </div>
      </div>

      <div class="panel glass-panel small">
        <div class="panel-header">
          <h2><i class="fas fa-lightbulb"></i> AI Recommendations</h2>
          <span class="badge-new">AI Powered</span>
        </div>
        <div id="recommend-list" class="recommend-list"></div>
      </div>
    </section>

    <section class="right">
      <div class="panel glass-panel">
        <div class="panel-header">
          <h2><i class="fas fa-table"></i> Real-time Status Monitor</h2>
          <div class="status-indicator">
            <span class="pulse-dot"></span>
            <span>Live</span>
          </div>
        </div>
        <div class="table-wrap">
          <table id="status-table">
            <thead>
              <tr>
                <th>Train ID</th>
                <th>Location</th>
                <th>Health</th>
                <th>Next Service</th>
                <th>Days Left</th>
                <th>Risk Level</th>
              </tr>
            </thead>
            <tbody id="status-body">
              <!-- Skeleton loader -->
              <tr class="skeleton-row">
                <td><div class="skeleton"></div></td>
                <td><div class="skeleton"></div></td>
                <td><div class="skeleton"></div></td>
                <td><div class="skeleton"></div></td>
                <td><div class="skeleton"></div></td>
                <td><div class="skeleton"></div></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="panel glass-panel small">
        <div class="panel-header">
          <h2><i class="fas fa-chart-pie"></i> Fleet Health Analytics</h2>
        </div>
        <div class="chart-container">
          <canvas id="healthChart" width="300" height="240"></canvas>
          <div class="chart-center-label">
            <span class="chart-percentage">0%</span>
            <span class="chart-subtitle">Healthy</span>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Enhanced Modal -->
  <div id="detail-modal" class="modal hidden">
    <div class="modal-backdrop"></div>
    <div class="modal-card">
      <div class="modal-header">
        <h3 id="modal-title">Train Details</h3>
        <button id="modal-close" class="modal-close"><i class="fas fa-times"></i></button>
      </div>
      <div id="modal-content" class="modal-content"></div>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div id="loading-overlay" class="loading-overlay">
    <div class="loader">
      <div class="loader-track">
        <div class="loader-train"></div>
      </div>
      <p>Initializing Control Center...</p>
    </div>
  </div>

  <footer>
    <div class="footer-content">
      <div class="footer-left">
        <small>Â© 2024 VisionForge â€¢ KMRL AI Control System</small>
      </div>
      <div class="footer-right">
        <span class="connection-status">
          <i class="fas fa-wifi"></i> Connected
        </span>
        <span class="last-update">Last update: <span id="last-update-time">--:--:--</span></span>
      </div>
    </div>
  </footer>
</body>
</html>

------------------------------------script.js 5-------------------------------------------
// Enhanced Control Center Script
const API_BASE = "http://127.0.0.1:5000";
const REFRESH_MS = 5000;

// Enhanced track and slot positioning
const TRACK_Y = { 1: 80, 2: 180, 3: 280, 4: 380 };
const SLOT_X = { 1: 100, 2: 230, 3: 360, 4: 490, 5: 620, 6: 750 };

let healthChart = null;
let particleCount = 0;
let refreshInterval = null;
let currentScale = 1;

// Initialize on DOM load
document.addEventListener('DOMContentLoaded', () => {
  initializeApp();
  setupEventListeners();
  createParticles();
  animateBackground();
});

async function initializeApp() {
  // Show loading overlay
  showLoading();
  
  // Initial data fetch
  await refreshAll();
  
  // Hide loading after initial load
  setTimeout(() => hideLoading(), 1500);
  
  // Start periodic refresh
  refreshInterval = setInterval(refreshAll, REFRESH_MS);
}

function showLoading() {
  document.getElementById('loading-overlay').classList.remove('hidden');
}

function hideLoading() {
  document.getElementById('loading-overlay').classList.add('hidden');
}

function setupEventListeners() {
  // Zoom controls
  document.getElementById('zoom-in').addEventListener('click', () => {
    currentScale = Math.min(currentScale + 0.1, 1.5);
    document.getElementById('tracks-svg').style.transform = `scale(${currentScale})`;
    document.getElementById('trains-layer').style.transform = `scale(${currentScale})`;
  });
  
  document.getElementById('zoom-out').addEventListener('click', () => {
    currentScale = Math.max(currentScale - 0.1, 0.7);
    document.getElementById('tracks-svg').style.transform = `scale(${currentScale})`;
    document.getElementById('trains-layer').style.transform = `scale(${currentScale})`;
  });
  
  // Refresh button
  document.getElementById('refresh-yard').addEventListener('click', () => {
    animateRefresh();
    refreshAll();
  });
  
  // Modal close handlers
  document.getElementById('modal-close').addEventListener('click', closeModal);
  document.querySelector('.modal-backdrop').addEventListener('click', closeModal);
}

function animateRefresh() {
  const btn = document.getElementById('refresh-yard');
  btn.style.animation = 'spin 0.5s ease';
  setTimeout(() => btn.style.animation = '', 500);
}

// Create floating particles
function createParticles() {
  const container = document.getElementById('particles');
  for (let i = 0; i < 50; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.cssText = `
      position: absolute;
      width: ${Math.random() * 3 + 1}px;
      height: ${Math.random() * 3 + 1}px;
      background: rgba(0, 240, 255, ${Math.random() * 0.5 + 0.2});
      border-radius: 50%;
      left: ${Math.random() * 100}%;
      top: ${Math.random() * 100}%;
      animation: particleFloat ${Math.random() * 20 + 10}s linear infinite;
      animation-delay: ${Math.random() * 5}s;
    `;
    container.appendChild(particle);
  }
  
  // Add CSS animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes particleFloat {
      0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateY(-100vh) rotate(360deg); opacity: 0; }
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  `;
  document.head.appendChild(style);
}

function animateBackground() {
  // Animated gradient background
  let hue = 0;
  setInterval(() => {
    hue = (hue + 1) % 360;
    document.documentElement.style.setProperty('--dynamic-hue', `${hue}deg`);
  }, 100);
}

async function fetchAll() {
  try {
    const [statusRes, recRes] = await Promise.all([
      fetch(`${API_BASE}/api/current_status`),
      fetch(`${API_BASE}/api/recommendation`)
    ]);
    
    if (!statusRes.ok || !recRes.ok) throw new Error("API fetch failed");
    
    const statusData = await statusRes.json();
    const recData = await recRes.json();
    
    return { statusData, recData };
  } catch (error) {
    console.error("Fetch error:", error);
    showNotification('Connection error. Retrying...', 'error');
    return { statusData: [], recData: [] };
  }
}

function parseYardPosition(posStr) {
  if (!posStr) return { x: 500, y: 250, track: null, slot: null };
  const s = posStr.replace(/\s/g, "");
  const match = s.match(/Track-(\d+).*Slot-(\d+)/i);
  
  if (match) {
    const track = Number(match[1]), slot = Number(match[2]);
    return { 
      x: SLOT_X[slot] || 500, 
      y: TRACK_Y[track] || 250, 
      track, 
      slot 
    };
  }
  
  const m2 = s.match(/Track-(\d+)/i);
  if (m2) {
    const track = Number(m2[1]);
    return { 
      x: 500, 
      y: TRACK_Y[track] || 250, 
      track, 
      slot: null 
    };
  }
  
  return { x: 500, y: 250, track: null, slot: null };
}

function renderTracksSVG() {
  const svg = document.getElementById("tracks-svg");
  svg.innerHTML = "";
  
  // Create gradient definitions
  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  
  // Track gradient
  const trackGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
  trackGradient.setAttribute("id", "trackGradient");
  trackGradient.innerHTML = `
    <stop offset="0%" style="stop-color:#063046;stop-opacity:0.5" />
    <stop offset="50%" style="stop-color:#0ea5e9;stop-opacity:0.3" />
    <stop offset="100%" style="stop-color:#063046;stop-opacity:0.5" />
  `;
  defs.appendChild(trackGradient);
  
  // Glow filter
  const filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
  filter.setAttribute("id", "glow");
  filter.innerHTML = `
    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
    <feMerge>
      <feMergeNode in="coloredBlur"/>
      <feMergeNode in="SourceGraphic"/>
    </feMerge>
  `;
  defs.appendChild(filter);
  
  svg.appendChild(defs);
  
  // Draw enhanced tracks
  for (let t = 1; t <= 4; t++) {
    const y = TRACK_Y[t];
    
    // Track background
    const trackBg = document.createElementNS("http://www.w3.org/2000/svg", "line");
    trackBg.setAttribute("x1", 40);
    trackBg.setAttribute("y1", y);
    trackBg.setAttribute("x2", 960);
    trackBg.setAttribute("y2", y);
    trackBg.setAttribute("stroke", "url(#trackGradient)");
    trackBg.setAttribute("stroke-width", "20");
    trackBg.setAttribute("stroke-linecap", "round");
    trackBg.setAttribute("opacity", "0.3");
    svg.appendChild(trackBg);
    
    // Animated track line
    const track = document.createElementNS("http://www.w3.org/2000/svg", "line");
    track.setAttribute("x1", 40);
    track.setAttribute("y1", y);
    track.setAttribute("x2", 960);
    track.setAttribute("y2", y);
    track.setAttribute("stroke", "#0ea5e9");
    track.setAttribute("stroke-width", "2");
    track.setAttribute("stroke-linecap", "round");
    track.setAttribute("stroke-dasharray", "20 10");
    track.setAttribute("filter", "url(#glow)");
    track.style.animation = `dashMove ${10 + t * 2}s linear infinite`;
    svg.appendChild(track);
    
    // Slot indicators with animation
    for (let s = 1; s <= 6; s++) {
      const cx = SLOT_X[s];
      
      // Outer pulse ring
      const pulseRing = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      pulseRing.setAttribute("cx", cx);
      pulseRing.setAttribute("cy", y);
      pulseRing.setAttribute("r", 12);
      pulseRing.setAttribute("fill", "none");
      pulseRing.setAttribute("stroke", "rgba(0, 240, 255, 0.3)");
      pulseRing.setAttribute("stroke-width", "1");
      pulseRing.style.animation = `pulsering ${2 + Math.random() * 2}s ease-in-out infinite`;
      svg.appendChild(pulseRing);
      
      // Inner circle
      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("cx", cx);
      circle.setAttribute("cy", y);
      circle.setAttribute("r", 5);
      circle.setAttribute("fill", "rgba(0, 240, 255, 0.6)");
      circle.setAttribute("filter", "url(#glow)");
      svg.appendChild(circle);
    }
  }
  
  // Add animations
  const style = document.createElement('style');
  style.textContent = `
    @keyframes dashMove {
      0% { stroke-dashoffset: 0; }
      100% { stroke-dashoffset: 30; }
    }
    @keyframes pulsering {
      0%, 100% { 
        r: 12;
        opacity: 0;
      }
      50% { 
        r: 20;
        opacity: 0.5;
      }
    }
  `;
  document.head.appendChild(style);
}

function createTrainElement(train, idx) {
  const div = document.createElement("div");
  div.className = "train";
  const fitness = (train.fitness_status || "Healthy").toLowerCase();
  div.classList.add(fitness);
  div.dataset.id = train.train_id;
  
  const pos = parseYardPosition(train.yard_position || "");
  div.style.left = `${pos.x}px`;
  div.style.top = `${pos.y}px`;
  
  // Add train icon
  div.innerHTML = `
    <i class="fas fa-train"></i>
    <div class="id">${train.train_id}</div>
    <div class="slot">${pos.track ? `T${pos.track}` : ''}${pos.slot ? `-S${pos.slot}` : ''}</div>
  `;
  
  // Store info for modal
  div.dataset.info = JSON.stringify(train);
  
  // Add hover particle effect
  div.addEventListener('mouseenter', (e) => createHoverParticles(e));
  
  // Click handler
  div.addEventListener('click', (e) => {
    e.stopPropagation();
    showDetailModal(train);
  });
  
  // Entrance animation
  div.style.animation = `trainEntry 0.5s cubic-bezier(0.4, 0, 0.2, 1) ${idx * 0.05}s both`;
  
  return div;
}

function createHoverParticles(e) {
  const train = e.currentTarget;
  const rect = train.getBoundingClientRect();
  
  for (let i = 0; i < 5; i++) {
    const particle = document.createElement('div');
    particle.style.cssText = `
      position: fixed;
      width: 4px;
      height: 4px;
      background: rgba(0, 240, 255, 0.8);
      border-radius: 50%;
      left: ${rect.left + rect.width / 2}px;
      top: ${rect.top + rect.height / 2}px;
      pointer-events: none;
      z-index: 100;
    `;
    document.body.appendChild(particle);
    
    // Animate particle
    const angle = (Math.PI * 2 * i) / 5;
    const distance = 30 + Math.random() * 20;
    particle.animate([
      { transform: 'translate(0, 0) scale(1)', opacity: 1 },
      { 
        transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`,
        opacity: 0
      }
    ], {
      duration: 600,
      easing: 'ease-out'
    }).onfinish = () => particle.remove();
  }
}

function animateStatCounter(element, newValue) {
  const current = parseInt(element.dataset.value) || 0;
  const duration = 1000;
  const start = Date.now();
  
  const animate = () => {
    const elapsed = Date.now() - start;
    const progress = Math.min(elapsed / duration, 1);
    const value = Math.floor(current + (newValue - current) * easeOutQuart(progress));
    
    element.textContent = value;
    
    if (progress < 1) {
      requestAnimationFrame(animate);
    } else {
      element.dataset.value = newValue;
    }
  };
  
  animate();
}

function easeOutQuart(t) {
  return 1 - Math.pow(1 - t, 4);
}

function updateSummaryCounts(statusData) {
  const total = statusData.length;
  const critical = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "critical").length;
  const minor = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "minor").length;
  const healthy = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "healthy").length;
  
  // Animate counters
  animateStatCounter(document.querySelector('#stat-total .stat-value'), total);
  animateStatCounter(document.querySelector('#stat-critical .stat-value'), critical);
  animateStatCounter(document.querySelector('#stat-minor .stat-value'), minor);
  animateStatCounter(document.querySelector('#stat-healthy .stat-value'), healthy);
  
  updateHealthChart(critical, minor, healthy);
  updateChartCenterLabel(healthy, total);
}

function updateChartCenterLabel(healthy, total) {
  const percentage = total > 0 ? Math.round((healthy / total) * 100) : 0;
  document.querySelector('.chart-percentage').textContent = `${percentage}%`;
}

function updateHealthChart(critical, minor, healthy) {
  const ctx = document.getElementById("healthChart").getContext("2d");
  
  if (healthChart) {
    healthChart.data.datasets[0].data = [critical, minor, healthy];
    healthChart.update('active');
    return;
  }
  
  healthChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: ['Critical', 'Minor Issues', 'Healthy'],
      datasets: [{
        data: [critical, minor, healthy],
        backgroundColor: [
          'rgba(239, 68, 68, 0.8)',
          'rgba(245, 158, 11, 0.8)',
          'rgba(16, 185, 129, 0.8)'
        ],
        borderColor: [
          'rgba(239, 68, 68, 1)',
          'rgba(245, 158, 11, 1)',
          'rgba(16, 185, 129, 1)'
        ],
        borderWidth: 2,
        hoverOffset: 4
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      cutout: '70%',
      plugins: {
        legend: {
          position: 'bottom',
          labels: {
            color: '#94a3b8',
            padding: 15,
            font: {
              size: 11
            }
          }
        },
        tooltip: {
          backgroundColor: 'rgba(15, 23, 42, 0.9)',
          titleColor: '#f1f5f9',
          bodyColor: '#94a3b8',
          borderColor: 'rgba(0, 240, 255, 0.2)',
          borderWidth: 1,
          padding: 12,
          displayColors: true,
          callbacks: {
            label: function(context) {
              const label = context.label || '';
              const value = context.parsed || 0;
              const total = context.dataset.data.reduce((a, b) => a + b, 0);
              const percentage = ((value / total) * 100).toFixed(1);
              return `${label}: ${value} (${percentage}%)`;
            }
          }
        }
      },
      animation: {
        animateRotate: true,
        animateScale: true,
        duration: 1500,
        easing: 'easeInOutQuart'
      }
    }
  });
}

function renderStatusTable(statusData, recData) {
  const tbody = document.getElementById("status-body");
  tbody.innerHTML = "";
  
  statusData.forEach((train, idx) => {
    const match = recData.find(r => r.train_id === train.train_id) || {};
    const fitness = (train.fitness_status || "Healthy").toLowerCase();
    const tr = document.createElement("tr");
    
    tr.innerHTML = `
      <td>
        <div style="display: flex; align-items: center; gap: 8px;">
          <i class="fas fa-train" style="color: var(--accent-cyan); font-size: 12px;"></i>
          ${train.train_id}
        </div>
      </td>
      <td>${train.yard_position || 'â€”'}</td>
      <td class="${fitness}">
        <span style="display: inline-flex; align-items: center; gap: 6px;">
          <span class="status-dot ${fitness}"></span>
          ${train.fitness_status || 'Healthy'}
        </span>
      </td>
      <td>${train.next_service_due_date || 'â€”'}</td>
      <td>
        <span class="days-badge ${train.days_until_next_service < 3 ? 'urgent' : ''}">
          ${train.days_until_next_service ?? 'â€”'}
        </span>
      </td>
      <td>${match.consequence_if_skipped || train.consequence_if_skipped || 'â€”'}</td>
    `;
    
    tbody.appendChild(tr);
    
    // Staggered entrance animation
    tr.style.animation = `tableRowSlide 0.3s ease-out ${idx * 0.03}s both`;
  });
  
  // Update last update time
  updateLastUpdateTime();
}

function renderRecommendations(recData) {
  const container = document.getElementById("recommend-list");
  container.innerHTML = "";
  
  if (!recData || recData.length === 0) {
    container.innerHTML = `
      <div class="rec-card" style="text-align: center; color: var(--text-secondary);">
        <i class="fas fa-check-circle" style="font-size: 2rem; color: var(--success); margin-bottom: 1rem;"></i>
        <p>All systems operating normally</p>
      </div>
    `;
    return;
  }
  
  recData.slice(0, 6).forEach((r, idx) => {
    const div = document.createElement("div");
    div.className = `rec-card ${(r.fitness_status||"healthy").toLowerCase()}`;
    
    const urgencyIcon = r.fitness_status === "Critical" ? 
      '<i class="fas fa-exclamation-triangle" style="color: #ef4444;"></i>' :
      r.fitness_status === "Minor" ?
      '<i class="fas fa-exclamation-circle" style="color: #f59e0b;"></i>' :
      '<i class="fas fa-info-circle" style="color: #10b981;"></i>';
    
    div.innerHTML = `
      <strong style="display: flex; align-items: center; gap: 8px;">
        ${urgencyIcon}
        Train ${r.train_id}
      </strong>
      <div class="rec-reason">${r.reason}</div>
      <div class="rec-consequence">
        <i class="fas fa-angle-right"></i>
        ${r.consequence_if_skipped}
      </div>
    `;
    
    div.addEventListener("click", () => showDetailModal(r));
    
    // Entrance animation
    div.style.animation = `recommendSlide 0.4s ease-out ${idx * 0.05}s both`;
    
    container.appendChild(div);
  });
}

function showDetailModal(obj) {
  const modal = document.getElementById("detail-modal");
  const content = document.getElementById("modal-content");
  const title = document.getElementById("modal-title");
  
  const fitness = (obj.fitness_status || "Healthy").toLowerCase();
  const statusColor = fitness === "critical" ? "#ef4444" : 
                      fitness === "minor" ? "#f59e0b" : "#10b981";
  
  title.innerHTML = `
    <i class="fas fa-train" style="margin-right: 8px;"></i>
    Train ${obj.train_id || obj.train_id}
  `;
  
  content.innerHTML = `
    <div style="display: grid; gap: 1rem;">
      <div style="display: flex; align-items: center; gap: 1rem; padding: 1rem; background: rgba(0, 240, 255, 0.05); border-radius: 8px;">
        <div style="width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; background: ${statusColor}20; border-radius: 50%;">
          <i class="fas fa-${fitness === 'critical' ? 'exclamation-triangle' : fitness === 'minor' ? 'exclamation-circle' : 'check-circle'}" style="font-size: 1.5rem; color: ${statusColor};"></i>
        </div>
        <div>
          <div style="font-size: 0.875rem; color: var(--text-secondary);">Current Status</div>
          <div style="font-size: 1.25rem; font-weight: 600; color: ${statusColor}; text-transform: capitalize;">${obj.fitness_status || 'Healthy'}</div>
        </div>
      </div>
      
      <table style="width: 100%; border-collapse: collapse;">
        ${Object.entries(obj).map(([key, value]) => {
          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          return `
            <tr style="border-bottom: 1px solid var(--border-color);">
              <td style="padding: 0.75rem; font-weight: 600; color: var(--text-secondary); width: 40%;">
                ${formattedKey}
              </td>
              <td style="padding: 0.75rem; color: var(--text-primary);">
                ${value ?? 'â€”'}
              </td>
            </tr>
          `;
        }).join('')}
      </table>
      
      <div style="display: flex; justify-content: flex-end; gap: 0.75rem; margin-top: 1rem;">
        <button onclick="closeModal()" style="padding: 0.75rem 1.5rem; background: transparent; border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; cursor: pointer; transition: all 0.3s;">
          Close
        </button>
        <button style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue)); border: none; color: white; border-radius: 8px; cursor: pointer; transition: all 0.3s;">
          <i class="fas fa-wrench" style="margin-right: 8px;"></i>
          Schedule Maintenance
        </button>
      </div>
    </div>
  `;
  
  modal.classList.remove("hidden");
}

function closeModal() {
  document.getElementById("detail-modal").classList.add("hidden");
}

function updateLastUpdateTime() {
  const now = new Date();
  const timeStr = now.toLocaleTimeString('en-US', { 
    hour12: false,
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
  document.getElementById('last-update-time').textContent = timeStr;
}

function showNotification(message, type = 'info') {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 1rem 1.5rem;
    background: ${type === 'error' ? 'rgba(239, 68, 68, 0.9)' : 'rgba(16, 185, 129, 0.9)'};
    color: white;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    animation: notificationSlide 0.3s ease-out;
  `;
  notification.textContent = message;
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'notificationSlideOut 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

// Add notification animations
const notificationStyle = document.createElement('style');
notificationStyle.textContent = `
  @keyframes notificationSlide {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  @keyframes notificationSlideOut {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
  }
  @keyframes trainEntry {
    from { 
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.5);
    }
    to { 
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
  }
  @keyframes tableRowSlide {
    from {
      opacity: 0;
      transform: translateX(-20px);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }
  @keyframes recommendSlide {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  .status-dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    animation: statusPulse 2s ease-in-out infinite;
  }
  .status-dot.critical {
    background: #ef4444;
    box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
  }
  .status-dot.minor {
    background: #f59e0b;
    box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
  }
  .status-dot.healthy {
    background: #10b981;
    box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
  }
  @keyframes statusPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
  }
  .days-badge {
    display: inline-block;
    padding: 2px 8px;
    background: rgba(148, 163, 184, 0.1);
    border-radius: 12px;
    font-size: 0.875rem;
    font-weight: 600;
  }
  .days-badge.urgent {
    background: rgba(239, 68, 68, 0.2);
    color: #fca5a5;
    animation: urgentPulse 1s ease-in-out infinite;
  }
  @keyframes urgentPulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
    50% { box-shadow: 0 0 10px 2px rgba(239, 68, 68, 0.3); }
  }
`;
document.head.appendChild(notificationStyle);

// Main refresh function
async function refreshAll() {
  try {
    const { statusData, recData } = await fetchAll();
    
    // Update all components with animations
    updateSummaryCounts(statusData);
    renderStatusTable(statusData, recData);
    renderRecommendations(recData);
    
    // Render animated yard
    renderTracksSVG();
    const layer = document.getElementById("trains-layer");
    layer.innerHTML = "";
    
    statusData.forEach((t, idx) => {
      setTimeout(() => {
        const el = createTrainElement(t, idx);
        layer.appendChild(el);
      }, idx * 50);
    });
    
  } catch (err) {
    console.error("Error refreshing:", err);
    showNotification('Error loading data', 'error');
  }
}
-----------------------------------------stle.css 5-----------------------------
/* Advanced Theme Variables */
:root {
  --bg-primary: #030712;
  --bg-secondary: #0f172a;
  --panel-bg: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(30, 41, 59, 0.7));
  --accent-cyan: #00f0ff;
  --accent-blue: #0ea5e9;
  --accent-purple: #8b5cf6;
  --success: #10b981;
  --warning: #f59e0b;
  --danger: #ef4444;
  --text-primary: #f1f5f9;
  --text-secondary: #94a3b8;
  --border-color: rgba(148, 163, 184, 0.1);
  --glow-cyan: 0 0 30px rgba(0, 240, 255, 0.5);
  --glow-purple: 0 0 30px rgba(139, 92, 246, 0.5);
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  min-height: 100vh;
  overflow-x: hidden;
  position: relative;
}

/* Animated Background */
.animated-bg {
  position: fixed;
  inset: 0;
  z-index: -1;
  overflow: hidden;
}

.grid-overlay {
  position: absolute;
  inset: 0;
  background-image: 
    linear-gradient(rgba(0, 240, 255, 0.03) 1px, transparent 1px),
    linear-gradient(90deg, rgba(0, 240, 255, 0.03) 1px, transparent 1px);
  background-size: 50px 50px;
  animation: gridMove 20s linear infinite;
}

@keyframes gridMove {
  0% { transform: translate(0, 0); }
  100% { transform: translate(50px, 50px); }
}

.glow-orbs {
  position: absolute;
  inset: 0;
  filter: blur(80px);
  opacity: 0.6;
}

.orb {
  position: absolute;
  border-radius: 50%;
  animation: orbFloat 20s ease-in-out infinite;
}

.orb1 {
  width: 400px;
  height: 400px;
  background: radial-gradient(circle, var(--accent-cyan), transparent);
  top: -200px;
  left: -200px;
}

.orb2 {
  width: 300px;
  height: 300px;
  background: radial-gradient(circle, var(--accent-purple), transparent);
  bottom: -150px;
  right: -150px;
  animation-delay: -7s;
}

.orb3 {
  width: 250px;
  height: 250px;
  background: radial-gradient(circle, var(--accent-blue), transparent);
  top: 50%;
  left: 50%;
  animation-delay: -14s;
}

@keyframes orbFloat {
  0%, 100% { transform: translate(0, 0) scale(1); }
  33% { transform: translate(100px, -100px) scale(1.1); }
  66% { transform: translate(-100px, 100px) scale(0.9); }
}

/* Header Styles */
header {
  background: linear-gradient(90deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.95));
  backdrop-filter: blur(10px);
  border-bottom: 1px solid var(--border-color);
  padding: 1.5rem 2rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: relative;
  z-index: 10;
  box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);
}

.brand {
  display: flex;
  align-items: center;
  gap: 1.5rem;
}

.logo-container {
  position: relative;
  width: 50px;
  height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.logo-pulse {
  position: absolute;
  inset: 0;
  background: radial-gradient(circle, var(--accent-cyan), transparent);
  border-radius: 50%;
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(0.8); opacity: 0.5; }
  50% { transform: scale(1.2); opacity: 0; }
}

.logo-icon {
  font-size: 24px;
  color: var(--accent-cyan);
  z-index: 1;
  animation: trainMove 3s ease-in-out infinite;
}

@keyframes trainMove {
  0%, 100% { transform: translateX(0); }
  50% { transform: translateX(3px); }
}

.brand h1 {
  font-size: 1.5rem;
  font-weight: 700;
  background: linear-gradient(90deg, var(--accent-cyan), var(--accent-blue));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: 0 0 30px rgba(0, 240, 255, 0.3);
}

.sub {
  font-size: 0.875rem;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.live-indicator {
  display: inline-block;
  width: 8px;
  height: 8px;
  background: var(--success);
  border-radius: 50%;
  animation: blink 2s ease-in-out infinite;
}

@keyframes blink {
  0%, 100% { opacity: 1; box-shadow: 0 0 10px var(--success); }
  50% { opacity: 0.3; }
}

/* Header Stats */
.header-stats {
  display: flex;
  gap: 1rem;
}

.stat-card {
  background: linear-gradient(135deg, rgba(15, 23, 42, 0.8), rgba(30, 41, 59, 0.6));
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 0.75rem 1.25rem;
  display: flex;
  align-items: center;
  gap: 1rem;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.stat-card::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
  transform: translateX(-100%);
  transition: transform 0.6s;
}

.stat-card:hover::before {
  transform: translateX(100%);
}

.stat-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}

.stat-card i {
  font-size: 1.25rem;
  opacity: 0.8;
}

.stat-content {
  display: flex;
  flex-direction: column;
}

.stat-value {
  font-size: 1.25rem;
  font-weight: 700;
  line-height: 1;
}

.stat-label {
  font-size: 0.75rem;
  color: var(--text-secondary);
  margin-top: 0.25rem;
}

.critical-stat { border-color: rgba(239, 68, 68, 0.3); }
.critical-stat i { color: var(--danger); }
.minor-stat { border-color: rgba(245, 158, 11, 0.3); }
.minor-stat i { color: var(--warning); }
.healthy-stat { border-color: rgba(16, 185, 129, 0.3); }
.healthy-stat i { color: var(--success); }

/* Main Layout */
main {
  display: grid;
  grid-template-columns: 1fr 480px;
  gap: 1.5rem;
  padding: 1.5rem;
  max-width: 1600px;
  margin: 0 auto;
}

.left, .right {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

/* Glass Panel Design */
.glass-panel {
  background: var(--panel-bg);
  backdrop-filter: blur(10px);
  border: 1px solid var(--border-color);
  border-radius: 16px;
  padding: 1.5rem;
  position: relative;
  overflow: hidden;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
  animation: slideUp 0.6s ease-out;
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.glass-panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--accent-cyan), transparent);
  animation: shimmer 3s ease-in-out infinite;
}

@keyframes shimmer {
  0%, 100% { opacity: 0; }
  50% { opacity: 1; }
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
}

.panel-header h2 {
  font-size: 1.125rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.panel-header i {
  color: var(--accent-cyan);
}

.panel-controls {
  display: flex;
  gap: 0.5rem;
}

.control-btn {
  background: rgba(15, 23, 42, 0.6);
  border: 1px solid var(--border-color);
  color: var(--text-primary);
  width: 32px;
  height: 32px;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.control-btn:hover {
  background: rgba(0, 240, 255, 0.1);
  border-color: var(--accent-cyan);
  transform: scale(1.1);
}

.control-btn:active {
  transform: scale(0.95);
}

/* Yard Visualization */
#yard {
  position: relative;
  height: 450px;
  background: linear-gradient(135deg, rgba(3, 7, 18, 0.8), rgba(15, 23, 42, 0.6));
  border-radius: 12px;
  overflow: hidden;
  border: 1px solid var(--border-color);
}

.yard-grid {
  position: absolute;
  inset: 0;
  background-image: 
    repeating-linear-gradient(0deg, transparent, transparent 49px, rgba(0, 240, 255, 0.05) 50px),
    repeating-linear-gradient(90deg, transparent, transparent 49px, rgba(0, 240, 255, 0.05) 50px);
  pointer-events: none;
}

#tracks-svg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
}

.trains-layer {
  position: absolute;
  inset: 0;
}

.track-labels {
  position: absolute;
  left: 20px;
  pointer-events: none;
}

.track-label {
  position: absolute;
  background: rgba(0, 240, 255, 0.1);
  border: 1px solid rgba(0, 240, 255, 0.3);
  padding: 4px 12px;
  border-radius: 20px;
  font-size: 0.75rem;
  font-weight: 600;
  color: var(--accent-cyan);
}

/* Enhanced Train Icons */
.train {
  position: absolute;
  min-width: 120px;
  padding: 10px 16px;
  border-radius: 12px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  transform: translate(-50%, -50%);
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  font-weight: 600;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  pointer-events: auto;
}

.train::before {
  content: '';
  position: absolute;
  inset: -2px;
  border-radius: 12px;
  padding: 2px;
  background: linear-gradient(45deg, transparent, var(--accent-cyan), transparent);
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: 0;
  transition: opacity 0.3s;
}

.train:hover::before {
  opacity: 1;
  animation: borderRotate 3s linear infinite;
}

@keyframes borderRotate {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.train:hover {
  transform: translate(-50%, -50%) scale(1.1);
  z-index: 10;
}

.train .id {
  font-size: 0.875rem;
  letter-spacing: 0.5px;
}

.train .slot {
  font-size: 0.75rem;
  opacity: 0.8;
  margin-top: 2px;
}

/* Train Status Styles */
.train.critical {
  background: linear-gradient(135deg, rgba(239, 68, 68, 0.9), rgba(220, 38, 38, 0.8));
  color: white;
  animation: criticalPulse 1.5s ease-in-out infinite;
}

@keyframes criticalPulse {
  0%, 100% { 
    box-shadow: 0 0 20px rgba(239, 68, 68, 0.6), inset 0 0 10px rgba(255, 255, 255, 0.1);
  }
  50% { 
    box-shadow: 0 0 40px rgba(239, 68, 68, 0.9), inset 0 0 15px rgba(255, 255, 255, 0.2);
  }
}

.train.minor {
  background: linear-gradient(135deg, rgba(245, 158, 11, 0.9), rgba(217, 119, 6, 0.8));
  color: white;
  animation: minorPulse 2s ease-in-out infinite;
}

@keyframes minorPulse {
  0%, 100% { 
    box-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
  }
  50% { 
    box-shadow: 0 0 30px rgba(245, 158, 11, 0.8);
  }
}

.train.healthy {
  background: linear-gradient(135deg, rgba(16, 185, 129, 0.9), rgba(5, 150, 105, 0.8));
  color: white;
  animation: healthyFloat 3s ease-in-out infinite;
}

@keyframes healthyFloat {
  0%, 100% { 
    transform: translate(-50%, -52%);
    box-shadow: 0 0 15px rgba(16, 185, 129, 0.4);
  }
  50% { 
    transform: translate(-50%, -48%);
    box-shadow: 0 0 25px rgba(16, 185, 129, 0.6);
  }
}

/* Enhanced Table */
.table-wrap {
  overflow: auto;
  max-height: 350px;
  border-radius: 8px;
  border: 1px solid var(--border-color);
}

table {
  width: 100%;
  border-collapse: collapse;
}

thead {
  position: sticky;
  top: 0;
  z-index: 1;
}

th {
  background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.95));
  padding: 12px;
  text-align: left;
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text-secondary);
  border-bottom: 2px solid var(--border-color);
}

td {
  padding: 12px;
  border-bottom: 1px solid var(--border-color);
  font-size: 0.875rem;
  transition: all 0.3s ease;
}

tbody tr {
  background: rgba(15, 23, 42, 0.4);
  transition: all 0.3s ease;
}

tbody tr:hover {
  background: rgba(0, 240, 255, 0.05);
  transform: scale(1.01);
}

/* Status badges in table */
td.critical {
  background: linear-gradient(90deg, rgba(239, 68, 68, 0.2), transparent);
  color: #fca5a5;
  font-weight: 600;
}

td.minor {
  background: linear-gradient(90deg, rgba(245, 158, 11, 0.2), transparent);
  color: #fcd34d;
  font-weight: 600;
}

td.healthy {
  background: linear-gradient(90deg, rgba(16, 185, 129, 0.2), transparent);
  color: #6ee7b7;
  font-weight: 600;
}

/* Skeleton loader */
.skeleton-row td {
  padding: 12px;
}

.skeleton {
  height: 20px;
  background: linear-gradient(90deg, rgba(148, 163, 184, 0.1) 25%, rgba(148, 163, 184, 0.2) 50%, rgba(148, 163, 184, 0.1) 75%);
  background-size: 200% 100%;
  animation: loading 1.5s ease-in-out infinite;
  border-radius: 4px;
}

@keyframes loading {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}

/* Recommendations */
.recommend-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
  max-height: 280px;
  overflow-y: auto;
  padding-right: 8px;
}

.recommend-list::-webkit-scrollbar {
  width: 6px;
}

.recommend-list::-webkit-scrollbar-track {
  background: rgba(15, 23, 42, 0.4);
  border-radius: 3px;
}

.recommend-list::-webkit-scrollbar-thumb {
  background: var(--accent-cyan);
  border-radius: 3px;
}

.rec-card {
  background: linear-gradient(135deg, rgba(15, 23, 42, 0.6), rgba(30, 41, 59, 0.4));
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 16px;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.rec-card::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 4px;
  background: var(--accent-cyan);
}

.rec-card.critical::before { background: var(--danger); }
.rec-card.minor::before { background: var(--warning); }
.rec-card.healthy::before { background: var(--success); }

.rec-card:hover {
  transform: translateX(4px);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
  border-color: var(--accent-cyan);
}

.rec-card strong {
  display: block;
  margin-bottom: 8px;
  font-size: 0.95rem;
}

.rec-card .rec-reason {
  font-size: 0.875rem;
  color: var(--text-secondary);
  margin-bottom: 8px;
}

.rec-card .rec-consequence {
  font-size: 0.8rem;
  color: var(--accent-cyan);
  display: flex;
  align-items: center;
  gap: 6px;
}

/* Chart Enhancements */
.chart-container {
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
}

.chart-center-label {
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  pointer-events: none;
}

.chart-percentage {
  font-size: 2rem;
  font-weight: 700;
  background: linear-gradient(90deg, var(--accent-cyan), var(--accent-blue));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.chart-subtitle {
  font-size: 0.875rem;
  color: var(--text-secondary);
}

/* Modal Enhancements */
.modal {
  position: fixed;
  inset: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal.hidden {
  display: none;
}

.modal-backdrop {
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(5px);
  animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.modal-card {
  position: relative;
  background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.95));
  border: 1px solid var(--border-color);
  border-radius: 16px;
  width: min(800px, 90vw);
  max-height: 80vh;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  animation: slideUpModal 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes slideUpModal {
  from {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 24px;
  border-bottom: 1px solid var(--border-color);
  background: linear-gradient(90deg, rgba(0, 240, 255, 0.05), transparent);
}

.modal-header h3 {
  font-size: 1.25rem;
  background: linear-gradient(90deg, var(--accent-cyan), var(--accent-blue));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.modal-close {
  background: transparent;
  border: none;
  color: var(--text-secondary);
  font-size: 1.25rem;
  cursor: pointer;
  padding: 8px;
  transition: all 0.3s ease;
  border-radius: 8px;
}

.modal-close:hover {
  background: rgba(239, 68, 68, 0.1);
  color: var(--danger);
  transform: rotate(90deg);
}

.modal-content {
  padding: 24px;
  overflow-y: auto;
  max-height: 60vh;
}

/* Loading Overlay */
.loading-overlay {
  position: fixed;
  inset: 0;
  background: var(--bg-primary);
  z-index: 200;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  transition: opacity 0.5s ease;
}

.loading-overlay.hidden {
  opacity: 0;
  pointer-events: none;
}

.loader {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2rem;
}

.loader-track {
  width: 200px;
  height: 4px;
  background: rgba(148, 163, 184, 0.2);
  border-radius: 2px;
  position: relative;
  overflow: hidden;
}

.loader-train {
  position: absolute;
  left: -40px;
  top: -8px;
  width: 40px;
  height: 20px;
  background: linear-gradient(90deg, var(--accent-cyan), var(--accent-blue));
  border-radius: 4px;
  animation: trainLoad 2s ease-in-out infinite;
}

@keyframes trainLoad {
  0% { left: -40px; }
  100% { left: 200px; }
}

.loader p {
  color: var(--text-secondary);
  font-size: 0.875rem;
}

/* Footer */
footer {
  background: linear-gradient(90deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.95));
  border-top: 1px solid var(--border-color);
  padding: 1rem 2rem;
  margin-top: 2rem;
}

.footer-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 1600px;
  margin: 0 auto;
}

.footer-right {
  display: flex;
  align-items: center;
  gap: 1.5rem;
}

.connection-status {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  color: var(--success);
  font-size: 0.875rem;
}

.last-update {
  font-size: 0.875rem;
  color: var(--text-secondary);
}

/* Badges */
.badge-new {
  background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
  color: white;
  padding: 4px 8px;
  border-radius: 20px;
  font-size: 0.7rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  animation: badgePulse 2s ease-in-out infinite;
}

@keyframes badgePulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

.status-indicator {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: rgba(16, 185, 129, 0.1);
  border: 1px solid rgba(16, 185, 129, 0.3);
  border-radius: 20px;
  font-size: 0.8rem;
  color: var(--success);
}

.pulse-dot {
  width: 8px;
  height: 8px;
  background: var(--success);
  border-radius: 50%;
  animation: pulseDot 1.5s ease-in-out infinite;
}

@keyframes pulseDot {
  0% {
    box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(16, 185, 129, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(16, 185, 129, 0);
  }
}

/* Responsive Design */
@media (max-width: 1200px) {
  main {
    grid-template-columns: 1fr;
  }
  
  .header-stats {
    flex-wrap: wrap;
  }
}

@media (max-width: 768px) {
  header {
    flex-direction: column;
    gap: 1rem;
  }
  
  .header-stats {
    width: 100%;
    justify-content: space-between;
  }
  
  .stat-card {
    flex: 1;
    min-width: 0;
  }
  
  .stat-label {
    display: none;
  }
  
  main {
    padding: 1rem;
  }
  
  .footer-content {
    flex-direction: column;
    gap: 1rem;
  }
}

--------------------------------- script.js 6-----------------------------------------

// Enhanced Control Center Script with Moving Trains and Auto-Health System
const API_BASE = "http://127.0.0.1:5000";
const REFRESH_MS = 5000;
const HEALTH_UPDATE_MS = 30000; // 30 seconds for health updates

// Enhanced track and slot positioning
const TRACK_Y = { 1: 80, 2: 180, 3: 280, 4: 380 };
const SLOT_X = { 1: 100, 2: 230, 3: 360, 4: 490, 5: 620, 6: 750 };

let healthChart = null;
let particleCount = 0;
let refreshInterval = null;
let healthUpdateInterval = null;
let currentScale = 1;
let currentStatusData = [];
let currentRecData = [];
let trainMovements = new Map(); // Store train movement states
let healthUpdateQueue = [];
let isProcessingHealth = false;

// Initialize on DOM load
document.addEventListener('DOMContentLoaded', () => {
  initializeApp();
  setupEventListeners();
  createParticles();
  animateBackground();
  startHealthImprovementSystem();
});

async function initializeApp() {
  // Show loading overlay
  showLoading();
  
  // Initial data fetch
  await refreshAll();
  
  // Hide loading after initial load
  setTimeout(() => hideLoading(), 1500);
  
  // Start periodic refresh
  refreshInterval = setInterval(refreshAll, REFRESH_MS);
}

function showLoading() {
  document.getElementById('loading-overlay').classList.remove('hidden');
}

function hideLoading() {
  document.getElementById('loading-overlay').classList.add('hidden');
}

function setupEventListeners() {
  // Zoom controls
  document.getElementById('zoom-in').addEventListener('click', () => {
    currentScale = Math.min(currentScale + 0.1, 1.5);
    document.getElementById('tracks-svg').style.transform = `scale(${currentScale})`;
    document.getElementById('trains-layer').style.transform = `scale(${currentScale})`;
  });
  
  document.getElementById('zoom-out').addEventListener('click', () => {
    currentScale = Math.max(currentScale - 0.1, 0.7);
    document.getElementById('tracks-svg').style.transform = `scale(${currentScale})`;
    document.getElementById('trains-layer').style.transform = `scale(${currentScale})`;
  });
  
  // Refresh button
  document.getElementById('refresh-yard').addEventListener('click', () => {
    animateRefresh();
    refreshAll();
  });
  
  // Modal close handlers
  document.getElementById('modal-close').addEventListener('click', closeModal);
  document.querySelector('.modal-backdrop').addEventListener('click', closeModal);
}

function animateRefresh() {
  const btn = document.getElementById('refresh-yard');
  btn.style.animation = 'spin 0.5s ease';
  setTimeout(() => btn.style.animation = '', 500);
}

// Create floating particles
function createParticles() {
  const container = document.getElementById('particles');
  for (let i = 0; i < 50; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.cssText = `
      position: absolute;
      width: ${Math.random() * 3 + 1}px;
      height: ${Math.random() * 3 + 1}px;
      background: rgba(0, 240, 255, ${Math.random() * 0.5 + 0.2});
      border-radius: 50%;
      left: ${Math.random() * 100}%;
      top: ${Math.random() * 100}%;
      animation: particleFloat ${Math.random() * 20 + 10}s linear infinite;
      animation-delay: ${Math.random() * 5}s;
    `;
    container.appendChild(particle);
  }
  
  // Add CSS animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes particleFloat {
      0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateY(-100vh) rotate(360deg); opacity: 0; }
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  `;
  document.head.appendChild(style);
}

function animateBackground() {
  // Animated gradient background
  let hue = 0;
  setInterval(() => {
    hue = (hue + 1) % 360;
    document.documentElement.style.setProperty('--dynamic-hue', `${hue}deg`);
  }, 100);
}

// Health Improvement Queue System
function startHealthImprovementSystem() {
  // Initialize queue with non-healthy trains
  updateHealthQueue();
  
  // Process health improvements every 30 seconds
  healthUpdateInterval = setInterval(() => {
    processNextHealthImprovement();
  }, HEALTH_UPDATE_MS);
  
  // Also process first one after 30 seconds from start
  setTimeout(() => {
    processNextHealthImprovement();
  }, HEALTH_UPDATE_MS);
}

function updateHealthQueue() {
  // Get all non-healthy trains sorted by priority (critical first, then minor)
  healthUpdateQueue = currentStatusData
    .filter(train => train.fitness_status !== 'Healthy')
    .sort((a, b) => {
      const priority = { 'Critical': 0, 'Minor': 1, 'Healthy': 2 };
      return (priority[a.fitness_status] || 2) - (priority[b.fitness_status] || 2);
    });
}

function processNextHealthImprovement() {
  if (isProcessingHealth || healthUpdateQueue.length === 0) {
    updateHealthQueue(); // Refresh queue if empty
    return;
  }
  
  isProcessingHealth = true;
  
  // Get the first train in queue
  const trainToHeal = healthUpdateQueue.shift();
  
  if (trainToHeal) {
    // Update train status to healthy
    const trainIndex = currentStatusData.findIndex(t => t.train_id === trainToHeal.train_id);
    if (trainIndex !== -1) {
      // Show healing animation
      showHealingNotification(trainToHeal.train_id);
      
      // Update the status
      currentStatusData[trainIndex].fitness_status = 'Healthy';
      currentStatusData[trainIndex].days_until_next_service = 30; // Reset service days
      currentStatusData[trainIndex].consequence_if_skipped = 'Regular maintenance';
      
      // Update all visualizations with animation
      animateHealthTransition(trainToHeal.train_id);
      updateAllVisualizations();
    }
  }
  
  isProcessingHealth = false;
}

function showHealingNotification(trainId) {
  const notification = document.createElement('div');
  notification.className = 'healing-notification';
  notification.innerHTML = `
    <i class="fas fa-wrench"></i>
    <span>Train ${trainId} maintenance completed!</span>
    <i class="fas fa-check-circle"></i>
  `;
  notification.style.cssText = `
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    padding: 1rem 2rem;
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.95), rgba(5, 150, 105, 0.95));
    color: white;
    border-radius: 50px;
    box-shadow: 0 10px 40px rgba(16, 185, 129, 0.4);
    z-index: 1000;
    display: flex;
    align-items: center;
    gap: 1rem;
    font-weight: 600;
    animation: healingPulse 0.6s ease-out;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'healingFadeOut 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

function animateHealthTransition(trainId) {
  // Find train element in yard
  const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
  if (trainElement) {
    // Add healing effect
    trainElement.style.animation = 'healingGlow 1s ease-out';
    
    // Change class after animation
    setTimeout(() => {
      trainElement.className = 'train healthy';
      // Restart movement animation
      const movement = trainMovements.get(trainId);
      if (movement) {
        applyTrainMovement(trainElement, movement.track, movement.startX, trainId);
      }
    }, 500);
  }
}

function updateAllVisualizations() {
  // Update summary counts with animation
  updateSummaryCounts(currentStatusData);
  
  // Update table
  renderStatusTable(currentStatusData, currentRecData);
  
  // Update recommendations
  renderRecommendations(currentRecData);
  
  // Update trains in yard
  updateYardTrains();
}

async function fetchAll() {
  try {
    const [statusRes, recRes] = await Promise.all([
      fetch(`${API_BASE}/api/current_status`),
      fetch(`${API_BASE}/api/recommendation`)
    ]);
    
    if (!statusRes.ok || !recRes.ok) throw new Error("API fetch failed");
    
    const statusData = await statusRes.json();
    const recData = await recRes.json();
    
    return { statusData, recData };
  } catch (error) {
    console.error("Fetch error:", error);
    showNotification('Connection error. Retrying...', 'error');
    return { statusData: currentStatusData, recData: currentRecData };
  }
}

function parseYardPosition(posStr) {
  if (!posStr) return { x: 500, y: 250, track: null, slot: null };
  const s = posStr.replace(/\s/g, "");
  const match = s.match(/Track-(\d+).*Slot-(\d+)/i);
  
  if (match) {
    const track = Number(match[1]), slot = Number(match[2]);
    return { 
      x: SLOT_X[slot] || 500, 
      y: TRACK_Y[track] || 250, 
      track, 
      slot 
    };
  }
  
  const m2 = s.match(/Track-(\d+)/i);
  if (m2) {
    const track = Number(m2[1]);
    return { 
      x: 500, 
      y: TRACK_Y[track] || 250, 
      track, 
      slot: null 
    };
  }
  
  return { x: 500, y: 250, track: null, slot: null };
}

function renderTracksSVG() {
  const svg = document.getElementById("tracks-svg");
  svg.innerHTML = "";
  
  // Create gradient definitions
  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  
  // Track gradient
  const trackGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
  trackGradient.setAttribute("id", "trackGradient");
  trackGradient.innerHTML = `
    <stop offset="0%" style="stop-color:#063046;stop-opacity:0.5" />
    <stop offset="50%" style="stop-color:#0ea5e9;stop-opacity:0.3" />
    <stop offset="100%" style="stop-color:#063046;stop-opacity:0.5" />
  `;
  defs.appendChild(trackGradient);
  
  // Moving track gradient
  const movingGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
  movingGradient.setAttribute("id", "movingGradient");
  movingGradient.innerHTML = `
    <stop offset="0%" style="stop-color:#00f0ff;stop-opacity:0">
      <animate attributeName="stop-opacity" values="0;0.5;0" dur="2s" repeatCount="indefinite" />
    </stop>
    <stop offset="50%" style="stop-color:#00f0ff;stop-opacity:0.5">
      <animate attributeName="stop-opacity" values="0.5;1;0.5" dur="2s" repeatCount="indefinite" />
    </stop>
    <stop offset="100%" style="stop-color:#00f0ff;stop-opacity:0">
      <animate attributeName="stop-opacity" values="0;0.5;0" dur="2s" repeatCount="indefinite" />
    </stop>
  `;
  defs.appendChild(movingGradient);
  
  // Glow filter
  const filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
  filter.setAttribute("id", "glow");
  filter.innerHTML = `
    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
    <feMerge>
      <feMergeNode in="coloredBlur"/>
      <feMergeNode in="SourceGraphic"/>
    </feMerge>
  `;
  defs.appendChild(filter);
  
  svg.appendChild(defs);
  
  // Draw enhanced tracks with rails
  for (let t = 1; t <= 4; t++) {
    const y = TRACK_Y[t];
    
    // Track background (rail bed)
    const trackBg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    trackBg.setAttribute("x", 40);
    trackBg.setAttribute("y", y - 12);
    trackBg.setAttribute("width", 920);
    trackBg.setAttribute("height", 24);
    trackBg.setAttribute("fill", "rgba(15, 23, 42, 0.6)");
    trackBg.setAttribute("rx", 12);
    svg.appendChild(trackBg);
    
    // Upper rail
    const rail1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
    rail1.setAttribute("x1", 40);
    rail1.setAttribute("y1", y - 6);
    rail1.setAttribute("x2", 960);
    rail1.setAttribute("y2", y - 6);
    rail1.setAttribute("stroke", "#1e40af");
    rail1.setAttribute("stroke-width", "2");
    svg.appendChild(rail1);
    
    // Lower rail
    const rail2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
    rail2.setAttribute("x1", 40);
    rail2.setAttribute("y1", y + 6);
    rail2.setAttribute("x2", 960);
    rail2.setAttribute("y2", y + 6);
    rail2.setAttribute("stroke", "#1e40af");
    rail2.setAttribute("stroke-width", "2");
    svg.appendChild(rail2);
    
    // Track ties (sleepers)
    for (let x = 60; x < 960; x += 30) {
      const tie = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      tie.setAttribute("x", x - 2);
      tie.setAttribute("y", y - 10);
      tie.setAttribute("width", 4);
      tie.setAttribute("height", 20);
      tie.setAttribute("fill", "rgba(148, 163, 184, 0.2)");
      svg.appendChild(tie);
    }
    
    // Animated track light
    const trackLight = document.createElementNS("http://www.w3.org/2000/svg", "line");
    trackLight.setAttribute("x1", 40);
    trackLight.setAttribute("y1", y);
    trackLight.setAttribute("x2", 960);
    trackLight.setAttribute("y2", y);
    trackLight.setAttribute("stroke", "url(#movingGradient)");
    trackLight.setAttribute("stroke-width", "1");
    trackLight.setAttribute("filter", "url(#glow)");
    svg.appendChild(trackLight);
    
    // Station/slot indicators
    for (let s = 1; s <= 6; s++) {
      const cx = SLOT_X[s];
      
      // Station platform
      const platform = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      platform.setAttribute("x", cx - 25);
      platform.setAttribute("y", y - 20);
      platform.setAttribute("width", 50);
      platform.setAttribute("height", 40);
      platform.setAttribute("fill", "rgba(0, 240, 255, 0.05)");
      platform.setAttribute("stroke", "rgba(0, 240, 255, 0.2)");
      platform.setAttribute("stroke-width", "1");
      platform.setAttribute("rx", 5);
      svg.appendChild(platform);
      
      // Station marker
      const marker = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      marker.setAttribute("cx", cx);
      marker.setAttribute("cy", y);
      marker.setAttribute("r", 4);
      marker.setAttribute("fill", "rgba(0, 240, 255, 0.8)");
      marker.setAttribute("filter", "url(#glow)");
      svg.appendChild(marker);
      
      // Station label
      const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
      label.setAttribute("x", cx);
      label.setAttribute("y", y - 25);
      label.setAttribute("text-anchor", "middle");
      label.setAttribute("fill", "rgba(148, 163, 184, 0.6)");
      label.setAttribute("font-size", "10");
      label.setAttribute("font-family", "monospace");
      label.textContent = `S${s}`;
      svg.appendChild(label);
    }
  }
}

function createTrainElement(train, idx) {
  const div = document.createElement("div");
  div.className = "train";
  const fitness = (train.fitness_status || "Healthy").toLowerCase();
  div.classList.add(fitness);
  div.dataset.id = train.train_id;
  
  const pos = parseYardPosition(train.yard_position || "");
  
  // Store movement data
  const movement = {
    track: pos.track || Math.floor(Math.random() * 4) + 1,
    startX: pos.x,
    currentX: pos.x,
    direction: Math.random() > 0.5 ? 1 : -1,
    speed: 0.5 + Math.random() * 1.5
  };
  trainMovements.set(train.train_id, movement);
  
  // Set initial position
  div.style.left = `${movement.startX}px`;
  div.style.top = `${TRACK_Y[movement.track]}px`;
  
  // Train body with locomotive design
  div.innerHTML = `
    <div class="train-body">
      <div class="train-front"></div>
      <div class="train-windows">
        <span class="window"></span>
        <span class="window"></span>
      </div>
      <div class="train-info">
        <div class="id">${train.train_id}</div>
        <div class="slot">Track ${movement.track}</div>
      </div>
    </div>
  `;
  
  // Store info for modal
  div.dataset.info = JSON.stringify(train);
  
  // Add hover effects
  div.addEventListener('mouseenter', (e) => {
    createHoverParticles(e);
    // Pause movement on hover
    div.style.animationPlayState = 'paused';
  });
  
  div.addEventListener('mouseleave', () => {
    div.style.animationPlayState = 'running';
  });
  
  // Click handler
  div.addEventListener('click', (e) => {
    e.stopPropagation();
    showDetailModal(train);
  });
  
  // Apply movement animation
  applyTrainMovement(div, movement.track, movement.startX, train.train_id);
  
  return div;
}

function applyTrainMovement(element, track, startX, trainId) {
  const movement = trainMovements.get(trainId);
  if (!movement) return;
  
  // Create unique animation for this train
  const animName = `trainRun_${trainId}`;
  const duration = 20 + Math.random() * 10; // 20-30 seconds for full track
  const delay = Math.random() * 5;
  
  // Remove old style if exists
  const oldStyle = document.getElementById(`style_${trainId}`);
  if (oldStyle) oldStyle.remove();
  
  // Create keyframes for running along track
  const style = document.createElement('style');
  style.id = `style_${trainId}`;
  style.textContent = `
    @keyframes ${animName} {
      0% { 
        left: ${startX}px;
        transform: translate(-50%, -50%) scaleX(1);
      }
      49% { 
        left: 920px;
        transform: translate(-50%, -50%) scaleX(1);
      }
      50% { 
        left: 920px;
        transform: translate(-50%, -50%) scaleX(-1);
      }
      99% { 
        left: 80px;
        transform: translate(-50%, -50%) scaleX(-1);
      }
      100% { 
        left: 80px;
        transform: translate(-50%, -50%) scaleX(1);
      }
    }
    
    .train[data-id="${trainId}"] .train-body {
      position: relative;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .train[data-id="${trainId}"] .train-front {
      width: 20px;
      height: 35px;
      background: linear-gradient(90deg, rgba(255,255,255,0.3), transparent);
      border-radius: 10px 0 0 10px;
      position: relative;
    }
    
    .train[data-id="${trainId}"] .train-front::after {
      content: '';
      position: absolute;
      bottom: -3px;
      left: 2px;
      right: 2px;
      height: 6px;
      background: repeating-linear-gradient(90deg, #333 0px, #333 3px, #666 3px, #666 6px);
      border-radius: 2px;
      animation: wheelRotate 0.5s linear infinite;
    }
    
    .train[data-id="${trainId}"] .train-windows {
      display: flex;
      gap: 3px;
    }
    
    .train[data-id="${trainId}"] .window {
      width: 12px;
      height: 10px;
      background: rgba(255, 255, 255, 0.6);
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 2px;
    }
    
    @keyframes wheelRotate {
      0% { background-position: 0 0; }
      100% { background-position: 6px 0; }
    }
  `;
  document.head.appendChild(style);
  
  // Apply animation to train
  element.style.animation = `${animName} ${duration}s linear ${delay}s infinite`;
  
  // Add smoke effect for moving trains
  addSmokeEffect(element);
}

function addSmokeEffect(trainElement) {
  const smoke = document.createElement('div');
  smoke.className = 'train-smoke';
  smoke.style.cssText = `
    position: absolute;
    top: -10px;
    left: 10px;
    width: 10px;
    height: 10px;
    background: rgba(148, 163, 184, 0.3);
    border-radius: 50%;
    animation: smoke 2s ease-out infinite;
  `;
  trainElement.appendChild(smoke);
  
  // Add smoke animation if not exists
  if (!document.getElementById('smoke-style')) {
    const style = document.createElement('style');
    style.id = 'smoke-style';
    style.textContent = `
      @keyframes smoke {
        0% {
          transform: translateY(0) scale(1);
          opacity: 0.6;
        }
        100% {
          transform: translateY(-30px) scale(2);
          opacity: 0;
        }
      }
    `;
    document.head.appendChild(style);
  }
}

function updateYardTrains() {
  const layer = document.getElementById("trains-layer");
  
  currentStatusData.forEach(train => {
    const existingTrain = layer.querySelector(`[data-id="${train.train_id}"]`);
    
    if (existingTrain) {
      // Update existing train status
      const fitness = (train.fitness_status || "Healthy").toLowerCase();
      existingTrain.className = `train ${fitness}`;
      
      // Update info
      existingTrain.dataset.info = JSON.stringify(train);
    }
  });
}

function createHoverParticles(e) {
  const train = e.currentTarget;
  const rect = train.getBoundingClientRect();
  
  // Create rail sparks effect
  for (let i = 0; i < 8; i++) {
    const particle = document.createElement('div');
    particle.style.cssText = `
      position: fixed;
      width: 3px;
      height: 3px;
      background: linear-gradient(45deg, #ffd700, #ff6b6b);
      border-radius: 50%;
      left: ${rect.left + rect.width / 2}px;
      top: ${rect.bottom - 5}px;
      pointer-events: none;
      z-index: 100;
    `;
    document.body.appendChild(particle);
    
    // Animate spark
    const angle = (Math.PI * 2 * i) / 8;
    const distance = 20 + Math.random() * 30;
    particle.animate([
      { 
        transform: 'translate(0, 0) scale(1)', 
        opacity: 1 
      },
      { 
        transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance - 20}px) scale(0)`,
        opacity: 0
      }
    ], {
      duration: 800,
      easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
    }).onfinish = () => particle.remove();
  }
}

function animateStatCounter(element, newValue) {
  const current = parseInt(element.dataset.value) || 0;
  const duration = 1000;
  const start = Date.now();
  
  const animate = () => {
    const elapsed = Date.now() - start;
    const progress = Math.min(elapsed / duration, 1);
    const value = Math.floor(current + (newValue - current) * easeOutQuart(progress));
    
    element.textContent = value;
    
    if (progress < 1) {
      requestAnimationFrame(animate);
    } else {
      element.dataset.value = newValue;
    }
  };
  
  animate();
}

function easeOutQuart(t) {
  return 1 - Math.pow(1 - t, 4);
}

function updateSummaryCounts(statusData) {
  const total = statusData.length;
  const critical = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "critical").length;
  const minor = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "minor").length;
  const healthy = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "healthy").length;
  
  // Animate counters
  animateStatCounter(document.querySelector('#stat-total .stat-value'), total);
  animateStatCounter(document.querySelector('#stat-critical .stat-value'), critical);
  animateStatCounter(document.querySelector('#stat-minor .stat-value'), minor);
  animateStatCounter(document.querySelector('#stat-healthy .stat-value'), healthy);
  
  // Highlight healthy counter when updated
  if (healthy > parseInt(document.querySelector('#stat-healthy .stat-value').dataset.value || 0)) {
    const healthyStat = document.getElementById('stat-healthy');
    healthyStat.style.animation = 'healthyUpdate 1s ease';
    setTimeout(() => healthyStat.style.animation = '', 1000);
  }
  
  updateHealthChart(critical, minor, healthy);
  updateChartCenterLabel(healthy, total);
}

function updateChartCenterLabel(healthy, total) {
  const percentage = total > 0 ? Math.round((healthy / total) * 100) : 0;
  document.querySelector('.chart-percentage').textContent = `${percentage}%`;
}

function updateHealthChart(critical, minor, healthy) {
  const ctx = document.getElementById("healthChart").getContext("2d");
  
  if (healthChart) {
    // Animate chart update
    healthChart.data.datasets[0].data = [critical, minor, healthy];
    healthChart.update('active');
    return;
  }
  
  healthChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: ['Critical', 'Minor Issues', 'Healthy'],
      datasets: [{
        data: [critical, minor, healthy],
        backgroundColor: [
          'rgba(239, 68, 68, 0.8)',
          'rgba(245, 158, 11, 0.8)',
          'rgba(16, 185, 129, 0.8)'
        ],
        borderColor: [
          'rgba(239, 68, 68, 1)',
          'rgba(245, 158, 11, 1)',
          'rgba(16, 185, 129, 1)'
        ],
        borderWidth: 2,
        hoverOffset: 4
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      cutout: '70%',
      plugins: {
        legend: {
          position: 'bottom',
          labels: {
            color: '#94a3b8',
            padding: 15,
            font: {
              size: 11
            }
          }
        },
        tooltip: {
          backgroundColor: 'rgba(15, 23, 42, 0.9)',
          titleColor: '#f1f5f9',
          bodyColor: '#94a3b8',
          borderColor: 'rgba(0, 240, 255, 0.2)',
          borderWidth: 1,
          padding: 12,
          displayColors: true,
          callbacks: {
            label: function(context) {
              const label = context.label || '';
              const value = context.parsed || 0;
              const total = context.dataset.data.reduce((a, b) => a + b, 0);
              const percentage = ((value / total) * 100).toFixed(1);
              return `${label}: ${value} (${percentage}%)`;
            }
          }
        }
      },
      animation: {
        animateRotate: true,
        animateScale: true,
        duration: 1500,
        easing: 'easeInOutQuart'
      }
    }
  });
}

function renderStatusTable(statusData, recData) {
  const tbody = document.getElementById("status-body");
  tbody.innerHTML = "";
  
  statusData.forEach((train, idx) => {
    const match = recData.find(r => r.train_id === train.train_id) || {};
    const fitness = (train.fitness_status || "Healthy").toLowerCase();
    const tr = document.createElement("tr");
    
    // Add healing animation for recently healed trains
    const wasHealed = train.fitness_status === 'Healthy' && train.recentlyHealed;
    
    tr.innerHTML = `
      <td>
        <div style="display: flex; align-items: center; gap: 8px;">
          <i class="fas fa-train" style="color: var(--accent-cyan); font-size: 12px;"></i>
          ${train.train_id}
          ${wasHealed ? '<span class="healing-badge">NEW</span>' : ''}
        </div>
      </td>
      <td>${train.yard_position || 'â€”'}</td>
      <td class="${fitness}">
        <span style="display: inline-flex; align-items: center; gap: 6px;">
          <span class="status-dot ${fitness}"></span>
          ${train.fitness_status || 'Healthy'}
        </span>
      </td>
      <td>${train.next_service_due_date || 'â€”'}</td>
      <td>
        <span class="days-badge ${train.days_until_next_service < 3 ? 'urgent' : ''}">
          ${train.days_until_next_service ?? 'â€”'}
        </span>
      </td>
      <td>${match.consequence_if_skipped || train.consequence_if_skipped || 'â€”'}</td>
    `;
    
    tbody.appendChild(tr);
    
    // Add special animation for healed trains
    if (wasHealed) {
      tr.style.animation = `healedRow 1s ease-out`;
      delete train.recentlyHealed; // Clear flag after animation
    } else {
      tr.style.animation = `tableRowSlide 0.3s ease-out ${idx * 0.03}s both`;
    }
  });
  
  // Update last update time
  updateLastUpdateTime();
}

function renderRecommendations(recData) {
  const container = document.getElementById("recommend-list");
  container.innerHTML = "";
  
  // Filter out healthy trains from recommendations
  const activeRecs = recData.filter(r => r.fitness_status !== 'Healthy');
  
  if (!activeRecs || activeRecs.length === 0) {
    container.innerHTML = `
      <div class="rec-card" style="text-align: center; color: var(--text-secondary);">
        <i class="fas fa-check-circle" style="font-size: 2rem; color: var(--success); margin-bottom: 1rem;"></i>
        <p>All systems operating normally</p>
        <small style="display: block; margin-top: 0.5rem; opacity: 0.7;">Next health check in ${Math.floor((HEALTH_UPDATE_MS - (Date.now() % HEALTH_UPDATE_MS)) / 1000)} seconds</small>
      </div>
    `;
    return;
  }
  
  activeRecs.slice(0, 6).forEach((r, idx) => {
    const div = document.createElement("div");
    div.className = `rec-card ${(r.fitness_status||"healthy").toLowerCase()}`;
    
    const urgencyIcon = r.fitness_status === "Critical" ? 
      '<i class="fas fa-exclamation-triangle" style="color: #ef4444;"></i>' :
      r.fitness_status === "Minor" ?
      '<i class="fas fa-exclamation-circle" style="color: #f59e0b;"></i>' :
      '<i class="fas fa-info-circle" style="color: #10b981;"></i>';
    
    const isNext = idx === 0 ? '<span class="next-badge">NEXT</span>' : '';
    
    div.innerHTML = `
      <strong style="display: flex; align-items: center; gap: 8px;">
        ${urgencyIcon}
        Train ${r.train_id}
        ${isNext}
      </strong>
      <div class="rec-reason">${r.reason}</div>
      <div class="rec-consequence">
        <i class="fas fa-angle-right"></i>
        ${r.consequence_if_skipped}
      </div>
    `;
    
    div.addEventListener("click", () => showDetailModal(r));
    
    // Entrance animation
    div.style.animation = `recommendSlide 0.4s ease-out ${idx * 0.05}s both`;
    
    container.appendChild(div);
  });
}

function showDetailModal(obj) {
  const modal = document.getElementById("detail-modal");
  const content = document.getElementById("modal-content");
  const title = document.getElementById("modal-title");
  
  const fitness = (obj.fitness_status || "Healthy").toLowerCase();
  const statusColor = fitness === "critical" ? "#ef4444" : 
                      fitness === "minor" ? "#f59e0b" : "#10b981";
  
  title.innerHTML = `
    <i class="fas fa-train" style="margin-right: 8px;"></i>
    Train ${obj.train_id || obj.train_id}
  `;
  
  content.innerHTML = `
    <div style="display: grid; gap: 1rem;">
      <div style="display: flex; align-items: center; gap: 1rem; padding: 1rem; background: rgba(0, 240, 255, 0.05); border-radius: 8px;">
        <div style="width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; background: ${statusColor}20; border-radius: 50%;">
          <i class="fas fa-${fitness === 'critical' ? 'exclamation-triangle' : fitness === 'minor' ? 'exclamation-circle' : 'check-circle'}" style="font-size: 1.5rem; color: ${statusColor};"></i>
        </div>
        <div>
          <div style="font-size: 0.875rem; color: var(--text-secondary);">Current Status</div>
          <div style="font-size: 1.25rem; font-weight: 600; color: ${statusColor}; text-transform: capitalize;">${obj.fitness_status || 'Healthy'}</div>
        </div>
      </div>
      
      <table style="width: 100%; border-collapse: collapse;">
        ${Object.entries(obj).map(([key, value]) => {
          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          return `
            <tr style="border-bottom: 1px solid var(--border-color);">
              <td style="padding: 0.75rem; font-weight: 600; color: var(--text-secondary); width: 40%;">
                ${formattedKey}
              </td>
              <td style="padding: 0.75rem; color: var(--text-primary);">
                ${value ?? 'â€”'}
              </td>
            </tr>
          `;
        }).join('')}
      </table>
      
      <div style="display: flex; justify-content: flex-end; gap: 0.75rem; margin-top: 1rem;">
        <button onclick="closeModal()" style="padding: 0.75rem 1.5rem; background: transparent; border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; cursor: pointer; transition: all 0.3s;">
          Close
        </button>
        <button style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue)); border: none; color: white; border-radius: 8px; cursor: pointer; transition: all 0.3s;">
          <i class="fas fa-wrench" style="margin-right: 8px;"></i>
          Schedule Maintenance
        </button>
      </div>
    </div>
  `;
  
  modal.classList.remove("hidden");
}

function closeModal() {
  document.getElementById("detail-modal").classList.add("hidden");
}

function updateLastUpdateTime() {
  const now = new Date();
  const timeStr = now.toLocaleTimeString('en-US', { 
    hour12: false,
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
  document.getElementById('last-update-time').textContent = timeStr;
}

function showNotification(message, type = 'info') {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 1rem 1.5rem;
    background: ${type === 'error' ? 'rgba(239, 68, 68, 0.9)' : 'rgba(16, 185, 129, 0.9)'};
    color: white;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    animation: notificationSlide 0.3s ease-out;
  `;
  notification.textContent = message;
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'notificationSlideOut 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

// Add all required animations
const enhancedStyles = document.createElement('style');
enhancedStyles.textContent = `
  @keyframes notificationSlide {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  @keyframes notificationSlideOut {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
  }
  @keyframes trainEntry {
    from { 
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.5);
    }
    to { 
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
  }
  @keyframes tableRowSlide {
    from {
      opacity: 0;
      transform: translateX(-20px);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }
  @keyframes recommendSlide {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  @keyframes healingPulse {
    0% { 
      transform: translateX(-50%) scale(0.8);
      opacity: 0;
    }
    50% { 
      transform: translateX(-50%) scale(1.1);
      opacity: 1;
    }
    100% { 
      transform: translateX(-50%) scale(1);
      opacity: 1;
    }
  }
  @keyframes healingFadeOut {
    from { 
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    to { 
      opacity: 0;
      transform: translateX(-50%) translateY(-20px);
    }
  }
  @keyframes healingGlow {
    0% { 
      box-shadow: 0 0 20px rgba(16, 185, 129, 0);
    }
    50% { 
      box-shadow: 0 0 40px rgba(16, 185, 129, 0.8);
    }
    100% { 
      box-shadow: 0 0 20px rgba(16, 185, 129, 0.4);
    }
  }
  @keyframes healedRow {
    0% { 
      background: rgba(16, 185, 129, 0.3);
      transform: scale(1);
    }
    50% { 
      background: rgba(16, 185, 129, 0.1);
      transform: scale(1.02);
    }
    100% { 
      background: transparent;
      transform: scale(1);
    }
  }
  @keyframes healthyUpdate {
    0% { 
      transform: scale(1);
      box-shadow: 0 0 0 rgba(16, 185, 129, 0);
    }
    50% { 
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
    }
    100% { 
      transform: scale(1);
      box-shadow: 0 0 0 rgba(16, 185, 129, 0);
    }
  }
  .status-dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    animation: statusPulse 2s ease-in-out infinite;
  }
  .status-dot.critical {
    background: #ef4444;
    box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
  }
  .status-dot.minor {
    background: #f59e0b;
    box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
  }
  .status-dot.healthy {
    background: #10b981;
    box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
  }
  @keyframes statusPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
  }
  .days-badge {
    display: inline-block;
    padding: 2px 8px;
    background: rgba(148, 163, 184, 0.1);
    border-radius: 12px;
    font-size: 0.875rem;
    font-weight: 600;
  }
  .days-badge.urgent {
    background: rgba(239, 68, 68, 0.2);
    color: #fca5a5;
    animation: urgentPulse 1s ease-in-out infinite;
  }
  @keyframes urgentPulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
    50% { box-shadow: 0 0 10px 2px rgba(239, 68, 68, 0.3); }
  }
  .healing-badge {
    background: linear-gradient(135deg, #10b981, #059669);
    color: white;
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 0.65rem;
    font-weight: 700;
    margin-left: 4px;
    animation: badgeBounce 0.6s ease;
  }
  @keyframes badgeBounce {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
  }
  .next-badge {
    background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
    color: white;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.65rem;
    font-weight: 700;
    margin-left: auto;
    animation: nextPulse 1.5s ease-in-out infinite;
  }
  @keyframes nextPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }
  
  /* Enhanced train design */
  .train {
    min-width: 140px;
    padding: 8px 12px;
  }
  
  .train-body {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
  }
  
  .train-info {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
`;
document.head.appendChild(enhancedStyles);

// Main refresh function
async function refreshAll() {
  try {
    const { statusData, recData } = await fetchAll();
    
    // Store current data
    currentStatusData = statusData;
    currentRecData = recData;
    
    // Update health queue
    updateHealthQueue();
    
    // Update all components with animations
    updateSummaryCounts(statusData);
    renderStatusTable(statusData, recData);
    renderRecommendations(recData);
    
    // Render animated yard
    renderTracksSVG();
    const layer = document.getElementById("trains-layer");
    layer.innerHTML = "";
    
    statusData.forEach((t, idx) => {
      setTimeout(() => {
        const el = createTrainElement(t, idx);
        layer.appendChild(el);
      }, idx * 50);
    });
    
  } catch (err) {
    console.error("Error refreshing:", err);
    showNotification('Error loading data', 'error');
  }
}

---------------------------------------------script.js 7--------------------------------------
// Enhanced Control Center Script with Fixed Train Positioning and Health System
const API_BASE = "http://127.0.0.1:5000";
const REFRESH_MS = 8000; // Increased to avoid conflicts
const HEALTH_UPDATE_MS = 30000; // 30 seconds for health updates

// Enhanced track and slot positioning
const TRACK_Y = { 1: 80, 2: 200, 3: 320, 4: 440 };
const SLOT_X = { 1: 100, 2: 230, 3: 360, 4: 490, 5: 620, 6: 750, 7: 880 };

let healthChart = null;
let particleCount = 0;
let refreshInterval = null;
let healthUpdateInterval = null;
let currentScale = 1;
let localStatusData = []; // Local copy that we modify
let backendStatusData = []; // Original from backend
let currentRecData = [];
let trainPositions = new Map(); // Track train positions to prevent overlap
let healthProcessedTrains = new Set(); // Track which trains have been healed
let isInitialLoad = true;

// Initialize on DOM load
document.addEventListener('DOMContentLoaded', () => {
  initializeApp();
  setupEventListeners();
  createParticles();
  animateBackground();
});

async function initializeApp() {
  // Show loading overlay
  showLoading();
  
  // Initial data fetch
  await refreshAll();
  
  // Hide loading after initial load
  setTimeout(() => hideLoading(), 1500);
  
  // Start health improvement system after initial load
  setTimeout(() => {
    startHealthImprovementSystem();
  }, 2000);
  
  // Start periodic refresh with longer interval
  refreshInterval = setInterval(() => {
    if (!isProcessingHealth) {
      refreshAll();
    }
  }, REFRESH_MS);
}

function showLoading() {
  document.getElementById('loading-overlay').classList.remove('hidden');
}

function hideLoading() {
  document.getElementById('loading-overlay').classList.add('hidden');
}

function setupEventListeners() {
  // Zoom controls
  document.getElementById('zoom-in').addEventListener('click', () => {
    currentScale = Math.min(currentScale + 0.1, 1.5);
    document.getElementById('tracks-svg').style.transform = `scale(${currentScale})`;
    document.getElementById('trains-layer').style.transform = `scale(${currentScale})`;
  });
  
  document.getElementById('zoom-out').addEventListener('click', () => {
    currentScale = Math.max(currentScale - 0.1, 0.7);
    document.getElementById('tracks-svg').style.transform = `scale(${currentScale})`;
    document.getElementById('trains-layer').style.transform = `scale(${currentScale})`;
  });
  
  // Refresh button
  document.getElementById('refresh-yard').addEventListener('click', () => {
    animateRefresh();
    refreshAll();
  });
  
  // Modal close handlers
  document.getElementById('modal-close').addEventListener('click', closeModal);
  document.querySelector('.modal-backdrop').addEventListener('click', closeModal);
}

function animateRefresh() {
  const btn = document.getElementById('refresh-yard');
  btn.style.animation = 'spin 0.5s ease';
  setTimeout(() => btn.style.animation = '', 500);
}

// Create floating particles
function createParticles() {
  const container = document.getElementById('particles');
  for (let i = 0; i < 50; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.cssText = `
      position: absolute;
      width: ${Math.random() * 3 + 1}px;
      height: ${Math.random() * 3 + 1}px;
      background: rgba(0, 240, 255, ${Math.random() * 0.5 + 0.2});
      border-radius: 50%;
      left: ${Math.random() * 100}%;
      top: ${Math.random() * 100}%;
      animation: particleFloat ${Math.random() * 20 + 10}s linear infinite;
      animation-delay: ${Math.random() * 5}s;
    `;
    container.appendChild(particle);
  }
  
  // Add CSS animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes particleFloat {
      0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateY(-100vh) rotate(360deg); opacity: 0; }
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  `;
  document.head.appendChild(style);
}

function animateBackground() {
  // Animated gradient background
  let hue = 0;
  setInterval(() => {
    hue = (hue + 1) % 360;
    document.documentElement.style.setProperty('--dynamic-hue', `${hue}deg`);
  }, 100);
}

// Global variable to track if health system is running
let isProcessingHealth = false;
let healthSystemStarted = false;

// Health Improvement Queue System
function startHealthImprovementSystem() {
  if (healthSystemStarted) return;
  healthSystemStarted = true;
  
  console.log('Health improvement system started');
  
  // Process health improvements every 30 seconds
  healthUpdateInterval = setInterval(() => {
    processNextHealthImprovement();
  }, HEALTH_UPDATE_MS);
  
  // Show countdown timer
  updateHealthCountdown();
  setInterval(updateHealthCountdown, 1000);
}

function updateHealthCountdown() {
  const timeLeft = Math.ceil((HEALTH_UPDATE_MS - (Date.now() % HEALTH_UPDATE_MS)) / 1000);
  const countdownElement = document.querySelector('.health-countdown');
  if (countdownElement) {
    countdownElement.textContent = `Next maintenance: ${timeLeft}s`;
  }
}

function processNextHealthImprovement() {
  console.log('Processing health improvement...');
  isProcessingHealth = true;
  
  // Find the first non-healthy train that hasn't been processed
  const trainToHeal = localStatusData.find(train => 
    train.fitness_status !== 'Healthy' && !healthProcessedTrains.has(train.train_id)
  );
  
  if (trainToHeal) {
    console.log(`Healing train: ${trainToHeal.train_id}`);
    
    // Mark as processed
    healthProcessedTrains.add(trainToHeal.train_id);
    
    // Show healing animation
    showHealingNotification(trainToHeal.train_id);
    
    // Update the train's status in local data
    const trainIndex = localStatusData.findIndex(t => t.train_id === trainToHeal.train_id);
    if (trainIndex !== -1) {
      localStatusData[trainIndex] = {
        ...localStatusData[trainIndex],
        fitness_status: 'Healthy',
        days_until_next_service: 30,
        consequence_if_skipped: 'Regular maintenance',
        recentlyHealed: true
      };
      
      // Update all visualizations
      updateAllVisualizations();
      
      // Animate the train element
      animateHealthTransition(trainToHeal.train_id);
    }
  } else {
    // Reset if all trains are healthy or processed
    console.log('Resetting health processed list');
    healthProcessedTrains.clear();
  }
  
  isProcessingHealth = false;
}

function showHealingNotification(trainId) {
  const notification = document.createElement('div');
  notification.className = 'healing-notification';
  notification.innerHTML = `
    <i class="fas fa-wrench"></i>
    <span>Train ${trainId} maintenance completed!</span>
    <i class="fas fa-check-circle"></i>
  `;
  notification.style.cssText = `
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    padding: 1rem 2rem;
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.95), rgba(5, 150, 105, 0.95));
    color: white;
    border-radius: 50px;
    box-shadow: 0 10px 40px rgba(16, 185, 129, 0.4);
    z-index: 1000;
    display: flex;
    align-items: center;
    gap: 1rem;
    font-weight: 600;
    animation: healingPulse 0.6s ease-out;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'healingFadeOut 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

function animateHealthTransition(trainId) {
  // Find train element in yard
  const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
  if (trainElement) {
    // Add healing effect
    const originalAnimation = trainElement.style.animation;
    trainElement.style.animation = 'healingGlow 1s ease-out';
    
    // Change class after animation
    setTimeout(() => {
      trainElement.className = 'train healthy moving';
      trainElement.style.animation = originalAnimation;
    }, 1000);
  }
}

function updateAllVisualizations() {
  // Update summary counts with animation
  updateSummaryCounts(localStatusData);
  
  // Update table
  renderStatusTable(localStatusData, currentRecData);
  
  // Update recommendations
  const activeRecs = currentRecData.filter(r => {
    const train = localStatusData.find(t => t.train_id === r.train_id);
    return train && train.fitness_status !== 'Healthy';
  });
  renderRecommendations(activeRecs);
  
  // Update trains in yard
  updateYardTrains();
}

async function fetchAll() {
  try {
    const [statusRes, recRes] = await Promise.all([
      fetch(`${API_BASE}/api/current_status`),
      fetch(`${API_BASE}/api/recommendation`)
    ]);
    
    if (!statusRes.ok || !recRes.ok) throw new Error("API fetch failed");
    
    const statusData = await statusRes.json();
    const recData = await recRes.json();
    
    return { statusData, recData };
  } catch (error) {
    console.error("Fetch error:", error);
    showNotification('Connection error. Using local data...', 'error');
    return { statusData: localStatusData, recData: currentRecData };
  }
}

function parseYardPosition(posStr) {
  if (!posStr) return { x: 500, y: 250, track: null, slot: null };
  const s = posStr.replace(/\s/g, "");
  const match = s.match(/Track-(\d+).*Slot-(\d+)/i);
  
  if (match) {
    const track = Number(match[1]), slot = Number(match[2]);
    return { 
      x: SLOT_X[slot] || 500, 
      y: TRACK_Y[track] || 250, 
      track, 
      slot 
    };
  }
  
  const m2 = s.match(/Track-(\d+)/i);
  if (m2) {
    const track = Number(m2[1]);
    return { 
      x: 100, 
      y: TRACK_Y[track] || 250, 
      track, 
      slot: 1 
    };
  }
  
  return { x: 100, y: 250, track: 1, slot: 1 };
}

// Calculate non-overlapping position for trains
function calculateTrainPosition(trainId, track, baseX, index, totalOnTrack) {
  const trackWidth = 850; // Usable track width
  const trainWidth = 140; // Train element width
  const spacing = 20; // Minimum spacing between trains
  
  // Calculate position based on index to prevent overlap
  const totalWidth = (trainWidth + spacing) * totalOnTrack;
  const startX = Math.max(100, (1000 - totalWidth) / 2);
  const x = startX + (index * (trainWidth + spacing));
  
  return {
    x: Math.min(Math.max(x, 100), 850), // Keep within track bounds
    y: TRACK_Y[track] || 250
  };
}

function renderTracksSVG() {
  const svg = document.getElementById("tracks-svg");
  svg.innerHTML = "";
  
  // Create gradient definitions
  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  
  // Track gradient
  const trackGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
  trackGradient.setAttribute("id", "trackGradient");
  trackGradient.innerHTML = `
    <stop offset="0%" style="stop-color:#063046;stop-opacity:0.5" />
    <stop offset="50%" style="stop-color:#0ea5e9;stop-opacity:0.3" />
    <stop offset="100%" style="stop-color:#063046;stop-opacity:0.5" />
  `;
  defs.appendChild(trackGradient);
  
  // Glow filter
  const filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
  filter.setAttribute("id", "glow");
  filter.innerHTML = `
    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
    <feMerge>
      <feMergeNode in="coloredBlur"/>
      <feMergeNode in="SourceGraphic"/>
    </feMerge>
  `;
  defs.appendChild(filter);
  
  svg.appendChild(defs);
  
  // Draw enhanced tracks with rails
  for (let t = 1; t <= 4; t++) {
    const y = TRACK_Y[t];
    
    // Track background (rail bed)
    const trackBg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    trackBg.setAttribute("x", 40);
    trackBg.setAttribute("y", y - 15);
    trackBg.setAttribute("width", 920);
    trackBg.setAttribute("height", 30);
    trackBg.setAttribute("fill", "rgba(15, 23, 42, 0.4)");
    trackBg.setAttribute("rx", 15);
    svg.appendChild(trackBg);
    
    // Upper rail
    const rail1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
    rail1.setAttribute("x1", 40);
    rail1.setAttribute("y1", y - 8);
    rail1.setAttribute("x2", 960);
    rail1.setAttribute("y2", y - 8);
    rail1.setAttribute("stroke", "#1e40af");
    rail1.setAttribute("stroke-width", "3");
    rail1.setAttribute("opacity", "0.8");
    svg.appendChild(rail1);
    
    // Lower rail
    const rail2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
    rail2.setAttribute("x1", 40);
    rail2.setAttribute("y1", y + 8);
    rail2.setAttribute("x2", 960);
    rail2.setAttribute("y2", y + 8);
    rail2.setAttribute("stroke", "#1e40af");
    rail2.setAttribute("stroke-width", "3");
    rail2.setAttribute("opacity", "0.8");
    svg.appendChild(rail2);
    
    // Track ties (sleepers)
    for (let x = 60; x < 960; x += 40) {
      const tie = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      tie.setAttribute("x", x - 3);
      tie.setAttribute("y", y - 12);
      tie.setAttribute("width", 6);
      tie.setAttribute("height", 24);
      tie.setAttribute("fill", "rgba(148, 163, 184, 0.15)");
      svg.appendChild(tie);
    }
    
    // Track number label
    const trackLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
    trackLabel.setAttribute("x", 20);
    trackLabel.setAttribute("y", y + 5);
    trackLabel.setAttribute("fill", "rgba(0, 240, 255, 0.6)");
    trackLabel.setAttribute("font-size", "14");
    trackLabel.setAttribute("font-weight", "600");
    trackLabel.textContent = `T${t}`;
    svg.appendChild(trackLabel);
  }
}

function createTrainElement(train, index, trainsOnSameTrack) {
  const div = document.createElement("div");
  div.className = "train moving";
  const fitness = (train.fitness_status || "Healthy").toLowerCase();
  div.classList.add(fitness);
  div.dataset.id = train.train_id;
  
  const pos = parseYardPosition(train.yard_position || "");
  const track = pos.track || (index % 4) + 1; // Distribute across tracks if no position
  
  // Calculate non-overlapping position
  const position = calculateTrainPosition(
    train.train_id, 
    track, 
    pos.x, 
    trainsOnSameTrack.indexOf(train.train_id),
    trainsOnSameTrack.length
  );
  
  // Store position
  trainPositions.set(train.train_id, { track, x: position.x, y: position.y });
  
  // Set initial position
  div.style.left = `${position.x}px`;
  div.style.top = `${position.y}px`;
  
  // Train body with locomotive design
  div.innerHTML = `
    <div class="train-body">
      <div class="train-front"></div>
      <div class="train-info">
        <div class="id">${train.train_id}</div>
        <div class="slot">T${track}</div>
      </div>
      <div class="train-lights"></div>
    </div>
  `;
  
  // Store info for modal
  div.dataset.info = JSON.stringify(train);
  
  // Add hover effects
  div.addEventListener('mouseenter', (e) => {
    createHoverParticles(e);
    div.style.zIndex = '10';
  });
  
  div.addEventListener('mouseleave', () => {
    div.style.zIndex = '1';
  });
  
  // Click handler
  div.addEventListener('click', (e) => {
    e.stopPropagation();
    showDetailModal(train);
  });
  
  // Apply movement animation
  applyTrainMovement(div, track, position.x, train.train_id, trainsOnSameTrack.indexOf(train.train_id));
  
  return div;
}

function applyTrainMovement(element, track, startX, trainId, laneIndex) {
  // Create unique animation for this train
  const animName = `trainRun_${trainId}_${Date.now()}`;
  const duration = 25 + (laneIndex * 5); // Stagger speeds
  const delay = laneIndex * 2; // Stagger start times
  
  // Calculate lane offset to prevent overlap
  const laneOffset = laneIndex * 5; // Vertical offset within track
  
  // Remove old style if exists
  const oldStyle = document.getElementById(`style_${trainId}`);
  if (oldStyle) oldStyle.remove();
  
  // Create keyframes for running along track
  const style = document.createElement('style');
  style.id = `style_${trainId}`;
  style.textContent = `
    @keyframes ${animName} {
      0% { 
        left: ${startX}px;
        transform: translate(-50%, calc(-50% + ${laneOffset}px)) scaleX(1);
      }
      48% { 
        left: 850px;
        transform: translate(-50%, calc(-50% + ${laneOffset}px)) scaleX(1);
      }
      50% { 
        left: 850px;
        transform: translate(-50%, calc(-50% + ${laneOffset}px)) scaleX(-1);
      }
      98% { 
        left: 100px;
        transform: translate(-50%, calc(-50% + ${laneOffset}px)) scaleX(-1);
      }
      100% { 
        left: 100px;
        transform: translate(-50%, calc(-50% + ${laneOffset}px)) scaleX(1);
      }
    }
    
    .train[data-id="${trainId}"] {
      animation: ${animName} ${duration}s linear ${delay}s infinite;
      z-index: ${5 - laneIndex};
    }
    
    .train[data-id="${trainId}"] .train-body {
      position: relative;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px;
    }
    
    .train[data-id="${trainId}"] .train-front {
      width: 15px;
      height: 25px;
      background: linear-gradient(90deg, rgba(255,255,255,0.4), rgba(255,255,255,0.1));
      border-radius: 8px 0 0 8px;
      position: relative;
    }
    
    .train[data-id="${trainId}"] .train-lights {
      width: 6px;
      height: 6px;
      background: #fff;
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(255,255,255,0.8);
      animation: lightBlink 1s ease-in-out infinite;
    }
    
    @keyframes lightBlink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
  `;
  document.head.appendChild(style);
}

function updateYardTrains() {
  const layer = document.getElementById("trains-layer");
  
  localStatusData.forEach(train => {
    const existingTrain = layer.querySelector(`[data-id="${train.train_id}"]`);
    
    if (existingTrain) {
      // Update existing train status
      const fitness = (train.fitness_status || "Healthy").toLowerCase();
      existingTrain.className = `train moving ${fitness}`;
      
      // Update info
      existingTrain.dataset.info = JSON.stringify(train);
      
      // Update display text
      const infoElement = existingTrain.querySelector('.train-info');
      if (infoElement) {
        infoElement.innerHTML = `
          <div class="id">${train.train_id}</div>
          <div class="slot">${fitness === 'healthy' ? 'âœ“' : fitness === 'critical' ? '!' : 'âš '}</div>
        `;
      }
    }
  });
}

function createHoverParticles(e) {
  const train = e.currentTarget;
  const rect = train.getBoundingClientRect();
  
  for (let i = 0; i < 5; i++) {
    const particle = document.createElement('div');
    particle.style.cssText = `
      position: fixed;
      width: 3px;
      height: 3px;
      background: linear-gradient(45deg, #ffd700, #ff6b6b);
      border-radius: 50%;
      left: ${rect.left + rect.width / 2}px;
      top: ${rect.bottom - 5}px;
      pointer-events: none;
      z-index: 100;
    `;
    document.body.appendChild(particle);
    
    const angle = (Math.PI * 2 * i) / 5;
    const distance = 20 + Math.random() * 20;
    particle.animate([
      { 
        transform: 'translate(0, 0) scale(1)', 
        opacity: 1 
      },
      { 
        transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance - 15}px) scale(0)`,
        opacity: 0
      }
    ], {
      duration: 600,
      easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
    }).onfinish = () => particle.remove();
  }
}

function animateStatCounter(element, newValue) {
  const current = parseInt(element.dataset.value) || 0;
  const duration = 1000;
  const start = Date.now();
  
  const animate = () => {
    const elapsed = Date.now() - start;
    const progress = Math.min(elapsed / duration, 1);
    const value = Math.floor(current + (newValue - current) * easeOutQuart(progress));
    
    element.textContent = value;
    
    if (progress < 1) {
      requestAnimationFrame(animate);
    } else {
      element.dataset.value = newValue;
    }
  };
  
  animate();
}

function easeOutQuart(t) {
  return 1 - Math.pow(1 - t, 4);
}

function updateSummaryCounts(statusData) {
  const total = statusData.length;
  const critical = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "critical").length;
  const minor = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "minor").length;
  const healthy = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "healthy").length;
  
  console.log(`Updating counts - Critical: ${critical}, Minor: ${minor}, Healthy: ${healthy}`);
  
  // Animate counters
  animateStatCounter(document.querySelector('#stat-total .stat-value'), total);
  animateStatCounter(document.querySelector('#stat-critical .stat-value'), critical);
  animateStatCounter(document.querySelector('#stat-minor .stat-value'), minor);
  animateStatCounter(document.querySelector('#stat-healthy .stat-value'), healthy);
  
  // Highlight healthy counter when updated
  const prevHealthy = parseInt(document.querySelector('#stat-healthy .stat-value').dataset.value || 0);
  if (healthy > prevHealthy) {
    const healthyStat = document.getElementById('stat-healthy');
    healthyStat.style.animation = 'healthyUpdate 1s ease';
    setTimeout(() => healthyStat.style.animation = '', 1000);
  }
  
  updateHealthChart(critical, minor, healthy);
  updateChartCenterLabel(healthy, total);
}

function updateChartCenterLabel(healthy, total) {
  const percentage = total > 0 ? Math.round((healthy / total) * 100) : 0;
  document.querySelector('.chart-percentage').textContent = `${percentage}%`;
}

function updateHealthChart(critical, minor, healthy) {
  const ctx = document.getElementById("healthChart").getContext("2d");
  
  if (healthChart) {
    // Update existing chart with animation
    healthChart.data.datasets[0].data = [critical, minor, healthy];
    healthChart.update('active');
    return;
  }
  
  // Create new chart
  healthChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: ['Critical', 'Minor Issues', 'Healthy'],
      datasets: [{
        data: [critical, minor, healthy],
        backgroundColor: [
          'rgba(239, 68, 68, 0.8)',
          'rgba(245, 158, 11, 0.8)',
          'rgba(16, 185, 129, 0.8)'
        ],
        borderColor: [
          'rgba(239, 68, 68, 1)',
          'rgba(245, 158, 11, 1)',
          'rgba(16, 185, 129, 1)'
        ],
        borderWidth: 2,
        hoverOffset: 4
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      cutout: '70%',
      plugins: {
        legend: {
          position: 'bottom',
          labels: {
            color: '#94a3b8',
            padding: 15,
            font: {
              size: 11
            }
          }
        },
        tooltip: {
          backgroundColor: 'rgba(15, 23, 42, 0.9)',
          titleColor: '#f1f5f9',
          bodyColor: '#94a3b8',
          borderColor: 'rgba(0, 240, 255, 0.2)',
          borderWidth: 1,
          padding: 12,
          displayColors: true,
          callbacks: {
            label: function(context) {
              const label = context.label || '';
              const value = context.parsed || 0;
              const total = context.dataset.data.reduce((a, b) => a + b, 0);
              const percentage = ((value / total) * 100).toFixed(1);
              return `${label}: ${value} (${percentage}%)`;
            }
          }
        }
      },
      animation: {
        animateRotate: true,
        animateScale: true,
        duration: 1500,
        easing: 'easeInOutQuart'
      }
    }
  });
}

function renderStatusTable(statusData, recData) {
  const tbody = document.getElementById("status-body");
  tbody.innerHTML = "";
  
  statusData.forEach((train, idx) => {
    const match = recData.find(r => r.train_id === train.train_id) || {};
    const fitness = (train.fitness_status || "Healthy").toLowerCase();
    const tr = document.createElement("tr");
    
    const wasHealed = train.recentlyHealed;
    
    tr.innerHTML = `
      <td>
        <div style="display: flex; align-items: center; gap: 8px;">
          <i class="fas fa-train" style="color: ${fitness === 'healthy' ? '#10b981' : fitness === 'critical' ? '#ef4444' : '#f59e0b'}; font-size: 12px;"></i>
          ${train.train_id}
          ${wasHealed ? '<span class="healing-badge">FIXED</span>' : ''}
        </div>
      </td>
      <td>${train.yard_position || 'â€”'}</td>
      <td class="${fitness}">
        <span style="display: inline-flex; align-items: center; gap: 6px;">
          <span class="status-dot ${fitness}"></span>
          ${train.fitness_status || 'Healthy'}
        </span>
      </td>
      <td>${train.next_service_due_date || 'â€”'}</td>
      <td>
        <span class="days-badge ${train.days_until_next_service < 3 ? 'urgent' : ''}">
          ${train.days_until_next_service ?? 'â€”'}
        </span>
      </td>
      <td>${match.consequence_if_skipped || train.consequence_if_skipped || 'â€”'}</td>
    `;
    
    tbody.appendChild(tr);
    
    if (wasHealed) {
      tr.style.animation = `healedRow 1s ease-out`;
      // Clear flag after display
      setTimeout(() => {
        delete train.recentlyHealed;
      }, 1000);
    } else {
      tr.style.animation = `tableRowSlide 0.3s ease-out ${idx * 0.03}s both`;
    }
  });
  
  updateLastUpdateTime();
}

function renderRecommendations(activeRecs) {
  const container = document.getElementById("recommend-list");
  container.innerHTML = "";
  
  if (!activeRecs || activeRecs.length === 0) {
    container.innerHTML = `
      <div class="rec-card" style="text-align: center; color: var(--text-secondary);">
        <i class="fas fa-check-circle" style="font-size: 2rem; color: var(--success); margin-bottom: 1rem;"></i>
        <p>All systems operating normally</p>
        <small class="health-countdown" style="display: block; margin-top: 0.5rem; opacity: 0.7;">Next maintenance check...</small>
      </div>
    `;
    return;
  }
  
  // Show only first 5 recommendations
  activeRecs.slice(0, 5).forEach((r, idx) => {
    const div = document.createElement("div");
    div.className = `rec-card ${(r.fitness_status||"healthy").toLowerCase()}`;
    
    const urgencyIcon = r.fitness_status === "Critical" ? 
      '<i class="fas fa-exclamation-triangle" style="color: #ef4444;"></i>' :
      r.fitness_status === "Minor" ?
      '<i class="fas fa-exclamation-circle" style="color: #f59e0b;"></i>' :
      '<i class="fas fa-info-circle" style="color: #10b981;"></i>';
    
    const isNext = idx === 0 ? '<span class="next-badge">NEXT</span>' : '';
    
    div.innerHTML = `
      <strong style="display: flex; align-items: center; gap: 8px;">
        ${urgencyIcon}
        Train ${r.train_id}
        ${isNext}
      </strong>
      <div class="rec-reason">${r.reason}</div>
      <div class="rec-consequence">
        <i class="fas fa-angle-right"></i>
        ${r.consequence_if_skipped}
      </div>
      ${idx === 0 ? '<small class="health-countdown" style="display: block; margin-top: 0.5rem; color: var(--accent-cyan);"></small>' : ''}
    `;
    
    div.addEventListener("click", () => showDetailModal(r));
    div.style.animation = `recommendSlide 0.4s ease-out ${idx * 0.05}s both`;
    
    container.appendChild(div);
  });
}

function showDetailModal(obj) {
  const modal = document.getElementById("detail-modal");
  const content = document.getElementById("modal-content");
  const title = document.getElementById("modal-title");
  
  const fitness = (obj.fitness_status || "Healthy").toLowerCase();
  const statusColor = fitness === "critical" ? "#ef4444" : 
                      fitness === "minor" ? "#f59e0b" : "#10b981";
  
  title.innerHTML = `
    <i class="fas fa-train" style="margin-right: 8px;"></i>
    Train ${obj.train_id}
  `;
  
  content.innerHTML = `
    <div style="display: grid; gap: 1rem;">
      <div style="display: flex; align-items: center; gap: 1rem; padding: 1rem; background: rgba(0, 240, 255, 0.05); border-radius: 8px;">
        <div style="width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; background: ${statusColor}20; border-radius: 50%;">
          <i class="fas fa-${fitness === 'critical' ? 'exclamation-triangle' : fitness === 'minor' ? 'exclamation-circle' : 'check-circle'}" style="font-size: 1.5rem; color: ${statusColor};"></i>
        </div>
        <div>
          <div style="font-size: 0.875rem; color: var(--text-secondary);">Current Status</div>
          <div style="font-size: 1.25rem; font-weight: 600; color: ${statusColor}; text-transform: capitalize;">${obj.fitness_status || 'Healthy'}</div>
        </div>
      </div>
      
      <table style="width: 100%; border-collapse: collapse;">
        ${Object.entries(obj).map(([key, value]) => {
          if (key === 'recentlyHealed') return ''; // Skip internal flag
          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          return `
            <tr style="border-bottom: 1px solid var(--border-color);">
              <td style="padding: 0.75rem; font-weight: 600; color: var(--text-secondary); width: 40%;">
                ${formattedKey}
              </td>
              <td style="padding: 0.75rem; color: var(--text-primary);">
                ${value ?? 'â€”'}
              </td>
            </tr>
          `;
        }).join('')}
      </table>
      
      <div style="display: flex; justify-content: flex-end; gap: 0.75rem; margin-top: 1rem;">
        <button onclick="closeModal()" style="padding: 0.75rem 1.5rem; background: transparent; border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; cursor: pointer; transition: all 0.3s;">
          Close
        </button>
        <button style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue)); border: none; color: white; border-radius: 8px; cursor: pointer; transition: all 0.3s;">
          <i class="fas fa-wrench" style="margin-right: 8px;"></i>
          Schedule Maintenance
        </button>
      </div>
    </div>
  `;
  
  modal.classList.remove("hidden");
}

function closeModal() {
  document.getElementById("detail-modal").classList.add("hidden");
}

function updateLastUpdateTime() {
  const now = new Date();
  const timeStr = now.toLocaleTimeString('en-US', { 
    hour12: false,
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
  document.getElementById('last-update-time').textContent = timeStr;
}

function showNotification(message, type = 'info') {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 1rem 1.5rem;
    background: ${type === 'error' ? 'rgba(239, 68, 68, 0.9)' : 'rgba(16, 185, 129, 0.9)'};
    color: white;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    animation: notificationSlide 0.3s ease-out;
  `;
  notification.textContent = message;
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'notificationSlideOut 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

// Add all animations and styles
const enhancedStyles = document.createElement('style');
enhancedStyles.textContent = `
  /* Update yard size */
  #yard {
    height: 550px !important;
  }
  
  /* Train styles */
  .train {
    min-width: 120px;
    max-width: 140px;
    padding: 6px 10px;
    position: absolute;
    transform: translate(-50%, -50%);
    transition: box-shadow 0.3s ease;
  }
  
  .train.moving {
    pointer-events: auto;
  }
  
  .train-body {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 4px;
  }
  
  .train-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex: 1;
  }
  
  .train-info .id {
    font-size: 12px;
    font-weight: 700;
  }
  
  .train-info .slot {
    font-size: 10px;
    opacity: 0.8;
    margin-top: 2px;
  }
  
  /* Status-specific colors */
  .train.healthy {
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.95), rgba(5, 150, 105, 0.85));
    border: 1px solid rgba(16, 185, 129, 0.5);
    color: white;
  }
  
  .train.minor {
    background: linear-gradient(135deg, rgba(245, 158, 11, 0.95), rgba(217, 119, 6, 0.85));
    border: 1px solid rgba(245, 158, 11, 0.5);
    color: white;
  }
  
  .train.critical {
    background: linear-gradient(135deg, rgba(239, 68, 68, 0.95), rgba(220, 38, 38, 0.85));
    border: 1px solid rgba(239, 68, 68, 0.5);
    color: white;
    animation: criticalAlert 2s ease-in-out infinite;
  }
  
  @keyframes criticalAlert {
    0%, 100% { box-shadow: 0 0 20px rgba(239, 68, 68, 0.4); }
    50% { box-shadow: 0 0 40px rgba(239, 68, 68, 0.8); }
  }
  
  /* Animations */
  @keyframes healingPulse {
    0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
    50% { transform: translateX(-50%) scale(1.1); opacity: 1; }
    100% { transform: translateX(-50%) scale(1); opacity: 1; }
  }
  
  @keyframes healingFadeOut {
    from { opacity: 1; transform: translateX(-50%) translateY(0); }
    to { opacity: 0; transform: translateX(-50%) translateY(-20px); }
  }
  
  @keyframes healingGlow {
    0% { box-shadow: 0 0 20px rgba(16, 185, 129, 0); }
    50% { box-shadow: 0 0 60px rgba(16, 185, 129, 1); }
    100% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.4); }
  }
  
  @keyframes healedRow {
    0% { background: linear-gradient(90deg, rgba(16, 185, 129, 0.3), transparent); }
    100% { background: transparent; }
  }
  
  @keyframes healthyUpdate {
    0% { transform: scale(1); background: rgba(16, 185, 129, 0); }
    50% { transform: scale(1.05); background: rgba(16, 185, 129, 0.1); }
    100% { transform: scale(1); background: rgba(16, 185, 129, 0); }
  }
  
  @keyframes notificationSlide {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes notificationSlideOut {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
  }
  
  @keyframes tableRowSlide {
    from { opacity: 0; transform: translateX(-20px); }
    to { opacity: 1; transform: translateX(0); }
  }
  
  @keyframes recommendSlide {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  .healing-badge {
    background: linear-gradient(135deg, #10b981, #059669);
    color: white;
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 0.65rem;
    font-weight: 700;
    margin-left: 4px;
    animation: badgeBounce 0.6s ease;
  }
  
  @keyframes badgeBounce {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
  }
  
  .next-badge {
    background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
    color: white;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.65rem;
    font-weight: 700;
    margin-left: auto;
    animation: nextPulse 1.5s ease-in-out infinite;
  }
  
  @keyframes nextPulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.8; transform: scale(0.95); }
  }
  
  .status-dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    animation: statusPulse 2s ease-in-out infinite;
  }
  
  .status-dot.critical {
    background: #ef4444;
    box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
  }
  
  .status-dot.minor {
    background: #f59e0b;
    box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
  }
  
  .status-dot.healthy {
    background: #10b981;
    box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
  }
  
  @keyframes statusPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
  }
  
  .days-badge {
    display: inline-block;
    padding: 2px 8px;
    background: rgba(148, 163, 184, 0.1);
    border-radius: 12px;
    font-size: 0.875rem;
    font-weight: 600;
  }
  
  .days-badge.urgent {
    background: rgba(239, 68, 68, 0.2);
    color: #fca5a5;
    animation: urgentPulse 1s ease-in-out infinite;
  }
  
  @keyframes urgentPulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
    50% { box-shadow: 0 0 10px 2px rgba(239, 68, 68, 0.3); }
  }
`;
document.head.appendChild(enhancedStyles);

// Main refresh function
async function refreshAll() {
  try {
    const { statusData, recData } = await fetchAll();
    
    // On initial load, set both local and backend data
    if (isInitialLoad) {
      backendStatusData = [...statusData];
      localStatusData = [...statusData];
      isInitialLoad = false;
    } else {
      // Merge backend data with local changes
      backendStatusData = [...statusData];
      
      // Preserve health status changes made locally
      localStatusData = statusData.map(backendTrain => {
        const localTrain = localStatusData.find(t => t.train_id === backendTrain.train_id);
        if (localTrain && healthProcessedTrains.has(backendTrain.train_id)) {
          // Keep the local health status if this train was processed
          return {
            ...backendTrain,
            fitness_status: localTrain.fitness_status,
            days_until_next_service: localTrain.days_until_next_service,
            consequence_if_skipped: localTrain.consequence_if_skipped
          };
        }
        return backendTrain;
      });
    }
    
    currentRecData = recData;
    
    // Update all components
    updateAllVisualizations();
    
    // Render animated yard
    renderTracksSVG();
    const layer = document.getElementById("trains-layer");
    layer.innerHTML = "";
    
    // Group trains by track
    const trainsByTrack = {};
    localStatusData.forEach((train, idx) => {
      const pos = parseYardPosition(train.yard_position || "");
      const track = pos.track || (idx % 4) + 1;
      
      if (!trainsByTrack[track]) {
        trainsByTrack[track] = [];
      }
      trainsByTrack[track].push(train.train_id);
    });
    
    // Create train elements with proper positioning
    localStatusData.forEach((train, idx) => {
      const pos = parseYardPosition(train.yard_position || "");
      const track = pos.track || (idx % 4) + 1;
      const trainsOnTrack = trainsByTrack[track] || [];
      
      setTimeout(() => {
        const el = createTrainElement(train, idx, trainsOnTrack);
        layer.appendChild(el);
      }, idx * 30);
    });
    
  } catch (err) {
    console.error("Error refreshing:", err);
    showNotification('Using local data', 'info');
  }
}

----------------------------------------script.js 8-----------------------------------
// Enhanced Control Center Script with Depot Queue System
const API_BASE = "http://127.0.0.1:5000";
const REFRESH_MS = 8000;
const HEALTH_UPDATE_MS = 30000; // 30 seconds for health updates
const EXIT_DELAY_MS = 10000; // 10 seconds before healthy train exits
const MAX_TRAINS_IN_YARD = 8; // Maximum trains allowed in yard at once

// Enhanced track and slot positioning
const TRACK_Y = { 1: 120, 2: 220, 3: 320, 4: 420 };
const SLOT_X = { 1: 150, 2: 280, 3: 410, 4: 540, 5: 670, 6: 800 };

// Queue area positions (left side, waiting to enter)
const QUEUE_X = -100;
const QUEUE_Y_START = 150;
const QUEUE_SPACING = 60;

// Exit area (right side, after service)
const EXIT_X = 1100;

let healthChart = null;
let currentScale = 1;
let localStatusData = [];
let backendStatusData = [];
let currentRecData = [];

// Depot management
let trainsInYard = new Set(); // Trains currently in the yard
let trainQueue = []; // Trains waiting to enter
let exitingTrains = new Set(); // Trains that are exiting
let trainPositions = new Map(); // Current positions of all trains
let healthProcessedTrains = new Set();
let isInitialLoad = true;

// Animation states
let isProcessingMovement = false;
let movementQueue = [];

// Initialize on DOM load
document.addEventListener('DOMContentLoaded', () => {
  initializeApp();
  setupEventListeners();
  createParticles();
  animateBackground();
});

async function initializeApp() {
  showLoading();
  await refreshAll();
  setTimeout(() => hideLoading(), 1500);
  
  // Start systems after initial load
  setTimeout(() => {
    startHealthImprovementSystem();
    startDepotManagementSystem();
  }, 2000);
  
  // Periodic refresh
  refreshInterval = setInterval(() => {
    if (!isProcessingMovement) {
      refreshAll();
    }
  }, REFRESH_MS);
}

function showLoading() {
  document.getElementById('loading-overlay').classList.remove('hidden');
}

function hideLoading() {
  document.getElementById('loading-overlay').classList.add('hidden');
}

function setupEventListeners() {
  document.getElementById('zoom-in').addEventListener('click', () => {
    currentScale = Math.min(currentScale + 0.1, 1.5);
    document.getElementById('tracks-svg').style.transform = `scale(${currentScale})`;
    document.getElementById('trains-layer').style.transform = `scale(${currentScale})`;
  });
  
  document.getElementById('zoom-out').addEventListener('click', () => {
    currentScale = Math.max(currentScale - 0.1, 0.7);
    document.getElementById('tracks-svg').style.transform = `scale(${currentScale})`;
    document.getElementById('trains-layer').style.transform = `scale(${currentScale})`;
  });
  
  document.getElementById('refresh-yard').addEventListener('click', () => {
    animateRefresh();
    refreshAll();
  });
  
  document.getElementById('modal-close').addEventListener('click', closeModal);
  document.querySelector('.modal-backdrop').addEventListener('click', closeModal);
}

function animateRefresh() {
  const btn = document.getElementById('refresh-yard');
  btn.style.animation = 'spin 0.5s ease';
  setTimeout(() => btn.style.animation = '', 500);
}

// Create floating particles
function createParticles() {
  const container = document.getElementById('particles');
  for (let i = 0; i < 50; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.cssText = `
      position: absolute;
      width: ${Math.random() * 3 + 1}px;
      height: ${Math.random() * 3 + 1}px;
      background: rgba(0, 240, 255, ${Math.random() * 0.5 + 0.2});
      border-radius: 50%;
      left: ${Math.random() * 100}%;
      top: ${Math.random() * 100}%;
      animation: particleFloat ${Math.random() * 20 + 10}s linear infinite;
      animation-delay: ${Math.random() * 5}s;
    `;
    container.appendChild(particle);
  }
}

function animateBackground() {
  let hue = 0;
  setInterval(() => {
    hue = (hue + 1) % 360;
    document.documentElement.style.setProperty('--dynamic-hue', `${hue}deg`);
  }, 100);
}

// Depot Management System
function startDepotManagementSystem() {
  console.log('Depot management system started');
  
  // Initial setup: move first batch to yard, rest to queue
  initializeDepotPositions();
  
  // Check for movements periodically
  setInterval(processDepotMovements, 2000);
}

function initializeDepotPositions() {
  trainsInYard.clear();
  trainQueue = [];
  exitingTrains.clear();
  
  localStatusData.forEach((train, index) => {
    if (index < MAX_TRAINS_IN_YARD) {
      // First 8 trains go to yard
      trainsInYard.add(train.train_id);
    } else {
      // Rest go to queue
      trainQueue.push(train.train_id);
    }
  });
  
  console.log(`Initialized: ${trainsInYard.size} in yard, ${trainQueue.length} in queue`);
}

function processDepotMovements() {
  if (isProcessingMovement) return;
  
  // Check if any trains need to exit
  exitingTrains.forEach(trainId => {
    const trainData = localStatusData.find(t => t.train_id === trainId);
    if (trainData && trainData.exitTimer && Date.now() >= trainData.exitTimer) {
      performTrainExit(trainId);
    }
  });
  
  // Check if we can bring trains from queue
  if (trainsInYard.size < MAX_TRAINS_IN_YARD && trainQueue.length > 0) {
    const nextTrain = trainQueue.shift();
    if (nextTrain) {
      performTrainEntry(nextTrain);
    }
  }
}

function performTrainExit(trainId) {
  console.log(`Train ${trainId} exiting yard`);
  isProcessingMovement = true;
  
  const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
  if (trainElement) {
    // Animate train moving to exit
    trainElement.style.transition = 'all 2s ease-out';
    trainElement.style.left = `${EXIT_X}px`;
    trainElement.style.opacity = '0';
    
    setTimeout(() => {
      trainElement.remove();
      trainsInYard.delete(trainId);
      exitingTrains.delete(trainId);
      
      // Move all remaining trains forward
      moveTrainsForward();
      
      // Show exit notification
      showExitNotification(trainId);
      
      isProcessingMovement = false;
    }, 2000);
  } else {
    isProcessingMovement = false;
  }
}

function performTrainEntry(trainId) {
  console.log(`Train ${trainId} entering yard`);
  
  const train = localStatusData.find(t => t.train_id === trainId);
  if (!train) return;
  
  trainsInYard.add(trainId);
  
  // Find available position
  const position = findAvailablePosition();
  
  // Create train element at queue position
  const trainElement = createTrainElement(train, position, true);
  document.getElementById('trains-layer').appendChild(trainElement);
  
  // Animate entry
  setTimeout(() => {
    trainElement.style.transition = 'all 1.5s ease-out';
    trainElement.style.left = `${position.x}px`;
    trainElement.style.opacity = '1';
    
    showEntryNotification(trainId);
  }, 100);
}

function moveTrainsForward() {
  const yardTrains = Array.from(trainsInYard);
  yardTrains.forEach((trainId, index) => {
    const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
    if (trainElement && !exitingTrains.has(trainId)) {
      const newPosition = calculateYardPosition(index);
      trainElement.style.transition = 'all 1s ease-out';
      trainElement.style.left = `${newPosition.x}px`;
      trainElement.style.top = `${newPosition.y}px`;
    }
  });
}

function findAvailablePosition() {
  const positions = [];
  for (let track = 1; track <= 4; track++) {
    for (let slot = 1; slot <= 6; slot++) {
      positions.push({ 
        track, 
        slot, 
        x: SLOT_X[slot], 
        y: TRACK_Y[track],
        occupied: false 
      });
    }
  }
  
  // Mark occupied positions
  trainsInYard.forEach(trainId => {
    const element = document.querySelector(`.train[data-id="${trainId}"]`);
    if (element) {
      const x = parseInt(element.style.left);
      const y = parseInt(element.style.top);
      positions.forEach(pos => {
        if (Math.abs(pos.x - x) < 50 && Math.abs(pos.y - y) < 50) {
          pos.occupied = true;
        }
      });
    }
  });
  
  // Return first available position
  return positions.find(p => !p.occupied) || positions[0];
}

function calculateYardPosition(index) {
  const track = (index % 4) + 1;
  const slot = Math.floor(index / 4) + 1;
  return {
    x: SLOT_X[Math.min(slot, 6)] || SLOT_X[6],
    y: TRACK_Y[track] || TRACK_Y[1]
  };
}

// Health Improvement System (based on recommendations)
let healthSystemStarted = false;
let isProcessingHealth = false;

function startHealthImprovementSystem() {
  if (healthSystemStarted) return;
  healthSystemStarted = true;
  
  console.log('Health improvement system started');
  
  // Process health improvements every 30 seconds
  setInterval(() => {
    processNextHealthImprovement();
  }, HEALTH_UPDATE_MS);
  
  // Show countdown timer
  updateHealthCountdown();
  setInterval(updateHealthCountdown, 1000);
}

function updateHealthCountdown() {
  const timeLeft = Math.ceil((HEALTH_UPDATE_MS - (Date.now() % HEALTH_UPDATE_MS)) / 1000);
  const countdownElements = document.querySelectorAll('.health-countdown');
  countdownElements.forEach(el => {
    el.textContent = `Next service completion: ${timeLeft}s`;
  });
}

function processNextHealthImprovement() {
  if (isProcessingHealth) return;
  console.log('Processing health improvement from recommendations...');
  isProcessingHealth = true;
  
  // Get first non-healthy train from recommendations that's in the yard
  const recommendation = currentRecData.find(rec => {
    const train = localStatusData.find(t => t.train_id === rec.train_id);
    return train && 
           train.fitness_status !== 'Healthy' && 
           trainsInYard.has(train.train_id) &&
           !healthProcessedTrains.has(train.train_id) &&
           !exitingTrains.has(train.train_id);
  });
  
  if (recommendation) {
    const trainToHeal = localStatusData.find(t => t.train_id === recommendation.train_id);
    
    if (trainToHeal) {
      console.log(`Healing train: ${trainToHeal.train_id} (from recommendations)`);
      
      // Mark as processed
      healthProcessedTrains.add(trainToHeal.train_id);
      
      // Show healing animation
      showHealingNotification(trainToHeal.train_id);
      
      // Update the train's status
      const trainIndex = localStatusData.findIndex(t => t.train_id === trainToHeal.train_id);
      if (trainIndex !== -1) {
        localStatusData[trainIndex] = {
          ...localStatusData[trainIndex],
          fitness_status: 'Healthy',
          days_until_next_service: 30,
          consequence_if_skipped: 'Regular maintenance',
          recentlyHealed: true,
          exitTimer: Date.now() + EXIT_DELAY_MS // Schedule exit in 10 seconds
        };
        
        // Mark for exit
        exitingTrains.add(trainToHeal.train_id);
        
        // Update visualizations
        updateAllVisualizations();
        
        // Animate the train
        animateHealthTransition(trainToHeal.train_id);
      }
    }
  } else {
    // Reset if no valid trains to heal
    if (healthProcessedTrains.size > 0) {
      console.log('Resetting health processed list');
      healthProcessedTrains.clear();
    }
  }
  
  isProcessingHealth = false;
}

function showHealingNotification(trainId) {
  const notification = document.createElement('div');
  notification.className = 'healing-notification';
  notification.innerHTML = `
    <i class="fas fa-wrench"></i>
    <span>Train ${trainId} maintenance completed!</span>
    <i class="fas fa-check-circle"></i>
    <div style="font-size: 0.8rem; margin-top: 4px; opacity: 0.8;">Will exit yard in 10 seconds...</div>
  `;
  notification.style.cssText = `
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    padding: 1rem 2rem;
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.95), rgba(5, 150, 105, 0.95));
    color: white;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(16, 185, 129, 0.4);
    z-index: 1000;
    text-align: center;
    animation: healingPulse 0.6s ease-out;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'healingFadeOut 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 4000);
}

function showExitNotification(trainId) {
  const notification = document.createElement('div');
  notification.innerHTML = `
    <i class="fas fa-sign-out-alt"></i>
    Train ${trainId} has left the maintenance yard
  `;
  notification.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(37, 99, 235, 0.9));
    color: white;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
    animation: slideInRight 0.5s ease-out;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'slideOutRight 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

function showEntryNotification(trainId) {
  const notification = document.createElement('div');
  notification.innerHTML = `
    <i class="fas fa-sign-in-alt"></i>
    Train ${trainId} has entered the maintenance yard
  `;
  notification.style.cssText = `
    position: fixed;
    bottom: 20px;
    left: 20px;
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, rgba(251, 146, 60, 0.9), rgba(249, 115, 22, 0.9));
    color: white;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(251, 146, 60, 0.3);
    animation: slideInLeft 0.5s ease-out;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'slideOutLeft 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

function animateHealthTransition(trainId) {
  const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
  if (trainElement) {
    trainElement.style.animation = 'healingGlow 1s ease-out';
    
    setTimeout(() => {
      trainElement.className = 'train healthy exiting';
      
      // Add exit indicator
      const exitBadge = document.createElement('div');
      exitBadge.className = 'exit-badge';
      exitBadge.innerHTML = '<i class="fas fa-check"></i> Ready';
      trainElement.appendChild(exitBadge);
    }, 500);
  }
}

function updateAllVisualizations() {
  updateSummaryCounts(localStatusData);
  renderStatusTable(localStatusData, currentRecData);
  
  // Filter recommendations for trains in yard
  const activeRecs = currentRecData.filter(r => {
    const train = localStatusData.find(t => t.train_id === r.train_id);
    return train && 
           train.fitness_status !== 'Healthy' && 
           trainsInYard.has(train.train_id);
  });
  renderRecommendations(activeRecs);
  
  updateYardTrains();
}

async function fetchAll() {
  try {
    const [statusRes, recRes] = await Promise.all([
      fetch(`${API_BASE}/api/current_status`),
      fetch(`${API_BASE}/api/recommendation`)
    ]);
    
    if (!statusRes.ok || !recRes.ok) throw new Error("API fetch failed");
    
    const statusData = await statusRes.json();
    const recData = await recRes.json();
    
    return { statusData, recData };
  } catch (error) {
    console.error("Fetch error:", error);
    return { statusData: localStatusData, recData: currentRecData };
  }
}

function parseYardPosition(posStr) {
  if (!posStr) return { x: 150, y: 120, track: 1, slot: 1 };
  const s = posStr.replace(/\s/g, "");
  const match = s.match(/Track-(\d+).*Slot-(\d+)/i);
  
  if (match) {
    const track = Number(match[1]), slot = Number(match[2]);
    return { 
      x: SLOT_X[slot] || 150, 
      y: TRACK_Y[track] || 120, 
      track, 
      slot 
    };
  }
  
  return { x: 150, y: 120, track: 1, slot: 1 };
}

function renderTracksSVG() {
  const svg = document.getElementById("tracks-svg");
  svg.innerHTML = "";
  
  // Create definitions
  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  
  // Track gradient
  const trackGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
  trackGradient.setAttribute("id", "trackGradient");
  trackGradient.innerHTML = `
    <stop offset="0%" style="stop-color:#1e293b;stop-opacity:0.8" />
    <stop offset="50%" style="stop-color:#334155;stop-opacity:0.6" />
    <stop offset="100%" style="stop-color:#1e293b;stop-opacity:0.8" />
  `;
  defs.appendChild(trackGradient);
  
  svg.appendChild(defs);
  
  // Draw queue area (left side)
  const queueArea = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  queueArea.setAttribute("x", 0);
  queueArea.setAttribute("y", 50);
  queueArea.setAttribute("width", 80);
  queueArea.setAttribute("height", 450);
  queueArea.setAttribute("fill", "rgba(239, 68, 68, 0.05)");
  queueArea.setAttribute("stroke", "rgba(239, 68, 68, 0.2)");
  queueArea.setAttribute("stroke-width", "2");
  queueArea.setAttribute("stroke-dasharray", "5 5");
  queueArea.setAttribute("rx", 10);
  svg.appendChild(queueArea);
  
  // Queue label
  const queueLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
  queueLabel.setAttribute("x", 40);
  queueLabel.setAttribute("y", 35);
  queueLabel.setAttribute("text-anchor", "middle");
  queueLabel.setAttribute("fill", "rgba(239, 68, 68, 0.6)");
  queueLabel.setAttribute("font-size", "12");
  queueLabel.setAttribute("font-weight", "600");
  queueLabel.textContent = "QUEUE";
  svg.appendChild(queueLabel);
  
  // Draw maintenance bay (center)
  const bayArea = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  bayArea.setAttribute("x", 100);
  bayArea.setAttribute("y", 50);
  bayArea.setAttribute("width", 800);
  bayArea.setAttribute("height", 450);
  bayArea.setAttribute("fill", "rgba(0, 240, 255, 0.02)");
  bayArea.setAttribute("stroke", "rgba(0, 240, 255, 0.15)");
  bayArea.setAttribute("stroke-width", "2");
  bayArea.setAttribute("rx", 10);
  svg.appendChild(bayArea);
  
  // Bay label
  const bayLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
  bayLabel.setAttribute("x", 500);
  bayLabel.setAttribute("y", 35);
  bayLabel.setAttribute("text-anchor", "middle");
  bayLabel.setAttribute("fill", "rgba(0, 240, 255, 0.8)");
  bayLabel.setAttribute("font-size", "14");
  bayLabel.setAttribute("font-weight", "600");
  bayLabel.textContent = "MAINTENANCE BAY";
  svg.appendChild(bayLabel);
  
  // Draw exit area (right side)
  const exitArea = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  exitArea.setAttribute("x", 920);
  exitArea.setAttribute("y", 50);
  exitArea.setAttribute("width", 80);
  exitArea.setAttribute("height", 450);
  exitArea.setAttribute("fill", "rgba(16, 185, 129, 0.05)");
  exitArea.setAttribute("stroke", "rgba(16, 185, 129, 0.2)");
  exitArea.setAttribute("stroke-width", "2");
  exitArea.setAttribute("stroke-dasharray", "5 5");
  exitArea.setAttribute("rx", 10);
  svg.appendChild(exitArea);
  
  // Exit label
  const exitLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
  exitLabel.setAttribute("x", 960);
  exitLabel.setAttribute("y", 35);
  exitLabel.setAttribute("text-anchor", "middle");
  exitLabel.setAttribute("fill", "rgba(16, 185, 129, 0.6)");
  exitLabel.setAttribute("font-size", "12");
  exitLabel.setAttribute("font-weight", "600");
  exitLabel.textContent = "EXIT";
  svg.appendChild(exitLabel);
  
  // Draw tracks
  for (let t = 1; t <= 4; t++) {
    const y = TRACK_Y[t];
    
    // Track background
    const trackBg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    trackBg.setAttribute("x", 100);
    trackBg.setAttribute("y", y - 20);
    trackBg.setAttribute("width", 800);
    trackBg.setAttribute("height", 40);
    trackBg.setAttribute("fill", "url(#trackGradient)");
    trackBg.setAttribute("rx", 20);
    trackBg.setAttribute("opacity", "0.3");
    svg.appendChild(trackBg);
    
    // Rails
    const rail1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
    rail1.setAttribute("x1", 100);
    rail1.setAttribute("y1", y - 8);
    rail1.setAttribute("x2", 900);
    rail1.setAttribute("y2", y - 8);
    rail1.setAttribute("stroke", "#475569");
    rail1.setAttribute("stroke-width", "2");
    svg.appendChild(rail1);
    
    const rail2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
    rail2.setAttribute("x1", 100);
    rail2.setAttribute("y1", y + 8);
    rail2.setAttribute("x2", 900);
    rail2.setAttribute("y2", y + 8);
    rail2.setAttribute("stroke", "#475569");
    rail2.setAttribute("stroke-width", "2");
    svg.appendChild(rail2);
    
    // Service stations
    for (let s = 1; s <= 6; s++) {
      const cx = SLOT_X[s];
      
      // Station marker
      const station = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      station.setAttribute("cx", cx);
      station.setAttribute("cy", y);
      station.setAttribute("r", 15);
      station.setAttribute("fill", "rgba(0, 240, 255, 0.1)");
      station.setAttribute("stroke", "rgba(0, 240, 255, 0.3)");
      station.setAttribute("stroke-width", "1");
      svg.appendChild(station);
      
      // Station number
      const stationNum = document.createElementNS("http://www.w3.org/2000/svg", "text");
      stationNum.setAttribute("x", cx);
      stationNum.setAttribute("y", y + 4);
      stationNum.setAttribute("text-anchor", "middle");
      stationNum.setAttribute("fill", "rgba(0, 240, 255, 0.6)");
      stationNum.setAttribute("font-size", "10");
      stationNum.setAttribute("font-weight", "600");
      stationNum.textContent = s;
      svg.appendChild(stationNum);
    }
    
    // Track label
    const trackLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
    trackLabel.setAttribute("x", 120);
    trackLabel.setAttribute("y", y + 4);
    trackLabel.setAttribute("fill", "rgba(148, 163, 184, 0.8)");
    trackLabel.setAttribute("font-size", "12");
    trackLabel.setAttribute("font-weight", "600");
    trackLabel.textContent = `T${t}`;
    svg.appendChild(trackLabel);
  }
  
  // Add flow arrows
  for (let i = 0; i < 3; i++) {
    const arrow = document.createElementNS("http://www.w3.org/2000/svg", "text");
    arrow.setAttribute("x", 85);
    arrow.setAttribute("y", 200 + i * 100);
    arrow.setAttribute("fill", "rgba(251, 146, 60, 0.4)");
    arrow.setAttribute("font-size", "20");
    arrow.textContent = "â†’";
    arrow.style.animation = `flowArrow ${2 + i * 0.5}s ease-in-out infinite`;
    svg.appendChild(arrow);
  }
  
  for (let i = 0; i < 3; i++) {
    const arrow = document.createElementNS("http://www.w3.org/2000/svg", "text");
    arrow.setAttribute("x", 905);
    arrow.setAttribute("y", 200 + i * 100);
    arrow.setAttribute("fill", "rgba(16, 185, 129, 0.4)");
    arrow.setAttribute("font-size", "20");
    arrow.textContent = "â†’";
    arrow.style.animation = `flowArrow ${2 + i * 0.5}s ease-in-out infinite`;
    svg.appendChild(arrow);
  }
}

function createTrainElement(train, position, isEntering = false) {
  const div = document.createElement("div");
  div.className = "train";
  const fitness = (train.fitness_status || "Healthy").toLowerCase();
  div.classList.add(fitness);
  div.dataset.id = train.train_id;
  
  // Set initial position
  if (isEntering) {
    // Start from queue area
    div.style.left = `${QUEUE_X}px`;
    div.style.top = `${position.y}px`;
    div.style.opacity = '0.5';
  } else {
    div.style.left = `${position.x}px`;
    div.style.top = `${position.y}px`;
  }
  
  // Queue indicator
  const queuePosition = trainQueue.indexOf(train.train_id);
  const queueBadge = queuePosition >= 0 ? `<span class="queue-badge">#${queuePosition + 1}</span>` : '';
  
  // Train body
  div.innerHTML = `
    <div class="train-body">
      <div class="train-lights ${fitness}"></div>
      <div class="train-info">
        <div class="id">${train.train_id}</div>
        <div class="status-icon">
          ${fitness === 'healthy' ? 'âœ“' : fitness === 'critical' ? 'âš ' : '!'}
        </div>
      </div>
      ${queueBadge}
    </div>
  `;
  
  // Store info
  div.dataset.info = JSON.stringify(train);
  
  // Event handlers
  div.addEventListener('mouseenter', (e) => {
    createHoverParticles(e);
    div.style.zIndex = '10';
  });
  
  div.addEventListener('mouseleave', () => {
    div.style.zIndex = '1';
  });
  
  div.addEventListener('click', (e) => {
    e.stopPropagation();
    showDetailModal(train);
  });
  
  return div;
}

function updateYardTrains() {
  const layer = document.getElementById("trains-layer");
  
  // Update existing trains
  localStatusData.forEach(train => {
    const existingTrain = layer.querySelector(`[data-id="${train.train_id}"]`);
    
    if (existingTrain) {
      const fitness = (train.fitness_status || "Healthy").toLowerCase();
      existingTrain.className = `train ${fitness}`;
      if (exitingTrains.has(train.train_id)) {
        existingTrain.classList.add('exiting');
      }
      
      existingTrain.dataset.info = JSON.stringify(train);
      
      // Update queue badge
      const queuePosition = trainQueue.indexOf(train.train_id);
      const queueBadge = existingTrain.querySelector('.queue-badge');
      if (queuePosition >= 0) {
        if (queueBadge) {
          queueBadge.textContent = `#${queuePosition + 1}`;
        } else {
          const badge = document.createElement('span');
          badge.className = 'queue-badge';
          badge.textContent = `#${queuePosition + 1}`;
          existingTrain.querySelector('.train-body').appendChild(badge);
        }
      } else if (queueBadge) {
        queueBadge.remove();
      }
    }
  });
}

function createHoverParticles(e) {
  const train = e.currentTarget;
  const rect = train.getBoundingClientRect();
  
  for (let i = 0; i < 6; i++) {
    const particle = document.createElement('div');
    particle.style.cssText = `
      position: fixed;
      width: 4px;
      height: 4px;
      background: linear-gradient(45deg, #00f0ff, #8b5cf6);
      border-radius: 50%;
      left: ${rect.left + rect.width / 2}px;
      top: ${rect.bottom}px;
      pointer-events: none;
      z-index: 100;
    `;
    document.body.appendChild(particle);
    
    const angle = (Math.PI * 2 * i) / 6;
    const distance = 30 + Math.random() * 20;
    particle.animate([
      { transform: 'translate(0, 0) scale(1)', opacity: 1 },
      { transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`, opacity: 0 }
    ], {
      duration: 800,
      easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
    }).onfinish = () => particle.remove();
  }
}

// Rest of the functions remain the same...
function animateStatCounter(element, newValue) {
  const current = parseInt(element.dataset.value) || 0;
  const duration = 1000;
  const start = Date.now();
  
  const animate = () => {
    const elapsed = Date.now() - start;
    const progress = Math.min(elapsed / duration, 1);
    const value = Math.floor(current + (newValue - current) * easeOutQuart(progress));
    
    element.textContent = value;
    
    if (progress < 1) {
      requestAnimationFrame(animate);
    } else {
      element.dataset.value = newValue;
    }
  };
  
  animate();
}

function easeOutQuart(t) {
  return 1 - Math.pow(1 - t, 4);
}

function updateSummaryCounts(statusData) {
  const total = statusData.length;
  const critical = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "critical").length;
  const minor = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "minor").length;
  const healthy = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "healthy").length;
  
  animateStatCounter(document.querySelector('#stat-total .stat-value'), total);
  animateStatCounter(document.querySelector('#stat-critical .stat-value'), critical);
  animateStatCounter(document.querySelector('#stat-minor .stat-value'), minor);
  animateStatCounter(document.querySelector('#stat-healthy .stat-value'), healthy);
  
  const prevHealthy = parseInt(document.querySelector('#stat-healthy .stat-value').dataset.value || 0);
  if (healthy > prevHealthy) {
    const healthyStat = document.getElementById('stat-healthy');
    healthyStat.style.animation = 'healthyUpdate 1s ease';
    setTimeout(() => healthyStat.style.animation = '', 1000);
  }
  
  updateHealthChart(critical, minor, healthy);
  updateChartCenterLabel(healthy, total);
}

function updateChartCenterLabel(healthy, total) {
  const percentage = total > 0 ? Math.round((healthy / total) * 100) : 0;
  document.querySelector('.chart-percentage').textContent = `${percentage}%`;
}

function updateHealthChart(critical, minor, healthy) {
  const ctx = document.getElementById("healthChart").getContext("2d");
  
  if (healthChart) {
    healthChart.data.datasets[0].data = [critical, minor, healthy];
    healthChart.update('active');
    return;
  }
  
  healthChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: ['Critical', 'Minor Issues', 'Healthy'],
      datasets: [{
        data: [critical, minor, healthy],
        backgroundColor: [
          'rgba(239, 68, 68, 0.8)',
          'rgba(245, 158, 11, 0.8)',
          'rgba(16, 185, 129, 0.8)'
        ],
        borderColor: [
          'rgba(239, 68, 68, 1)',
          'rgba(245, 158, 11, 1)',
          'rgba(16, 185, 129, 1)'
        ],
        borderWidth: 2,
        hoverOffset: 4
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      cutout: '70%',
      plugins: {
        legend: {
          position: 'bottom',
          labels: {
            color: '#94a3b8',
            padding: 15,
            font: { size: 11 }
          }
        }
      },
      animation: {
        animateRotate: true,
        animateScale: true,
        duration: 1500,
        easing: 'easeInOutQuart'
      }
    }
  });
}

function renderStatusTable(statusData, recData) {
  const tbody = document.getElementById("status-body");
  tbody.innerHTML = "";
  
  // Show all trains with yard status
  statusData.forEach((train, idx) => {
    const match = recData.find(r => r.train_id === train.train_id) || {};
    const fitness = (train.fitness_status || "Healthy").toLowerCase();
    const tr = document.createElement("tr");
    
    const inYard = trainsInYard.has(train.train_id);
    const inQueue = trainQueue.includes(train.train_id);
    const isExiting = exitingTrains.has(train.train_id);
    
    let locationBadge = '';
    if (isExiting) {
      locationBadge = '<span class="location-badge exiting">Exiting</span>';
    } else if (inYard) {
      locationBadge = '<span class="location-badge in-yard">In Bay</span>';
    } else if (inQueue) {
      const queuePos = trainQueue.indexOf(train.train_id) + 1;
      locationBadge = `<span class="location-badge in-queue">Queue #${queuePos}</span>`;
    }
    
    tr.innerHTML = `
      <td>
        <div style="display: flex; align-items: center; gap: 8px;">
          <i class="fas fa-train" style="color: ${fitness === 'healthy' ? '#10b981' : fitness === 'critical' ? '#ef4444' : '#f59e0b'}; font-size: 12px;"></i>
          ${train.train_id}
          ${locationBadge}
        </div>
      </td>
      <td>${train.yard_position || 'â€”'}</td>
      <td class="${fitness}">
        <span style="display: inline-flex; align-items: center; gap: 6px;">
          <span class="status-dot ${fitness}"></span>
          ${train.fitness_status || 'Healthy'}
        </span>
      </td>
      <td>${train.next_service_due_date || 'â€”'}</td>
      <td>
        <span class="days-badge ${train.days_until_next_service < 3 ? 'urgent' : ''}">
          ${train.days_until_next_service ?? 'â€”'}
        </span>
      </td>
      <td>${match.consequence_if_skipped || train.consequence_if_skipped || 'â€”'}</td>
    `;
    
    tbody.appendChild(tr);
    tr.style.animation = `tableRowSlide 0.3s ease-out ${idx * 0.02}s both`;
  });
  
  updateLastUpdateTime();
}

function renderRecommendations(activeRecs) {
  const container = document.getElementById("recommend-list");
  container.innerHTML = "";
  
  // Show yard capacity
  const capacityCard = document.createElement('div');
  capacityCard.className = 'capacity-card';
  capacityCard.innerHTML = `
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <span><i class="fas fa-warehouse"></i> Bay Capacity</span>
      <span style="font-weight: 700; color: var(--accent-cyan);">${trainsInYard.size}/${MAX_TRAINS_IN_YARD}</span>
    </div>
    <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 0.8rem; opacity: 0.8;">
      <span><i class="fas fa-clock"></i> In Queue</span>
      <span>${trainQueue.length}</span>
    </div>
    <div class="capacity-bar">
      <div class="capacity-fill" style="width: ${(trainsInYard.size / MAX_TRAINS_IN_YARD) * 100}%"></div>
    </div>
  `;
  container.appendChild(capacityCard);
  
  if (!activeRecs || activeRecs.length === 0) {
    container.innerHTML += `
      <div class="rec-card" style="text-align: center; color: var(--text-secondary);">
        <i class="fas fa-check-circle" style="font-size: 2rem; color: var(--success); margin-bottom: 1rem;"></i>
        <p>All trains in bay are healthy</p>
        <small class="health-countdown" style="display: block; margin-top: 0.5rem; opacity: 0.7;"></small>
      </div>
    `;
    return;
  }
  
  activeRecs.slice(0, 4).forEach((r, idx) => {
    const div = document.createElement("div");
    div.className = `rec-card ${(r.fitness_status||"healthy").toLowerCase()}`;
    
    const urgencyIcon = r.fitness_status === "Critical" ? 
      '<i class="fas fa-exclamation-triangle" style="color: #ef4444;"></i>' :
      '<i class="fas fa-exclamation-circle" style="color: #f59e0b;"></i>';
    
    const isNext = idx === 0 ? '<span class="next-badge pulse">NEXT</span>' : '';
    
    div.innerHTML = `
      <strong style="display: flex; align-items: center; gap: 8px;">
        ${urgencyIcon}
        Train ${r.train_id}
        ${isNext}
      </strong>
      <div class="rec-reason">${r.reason}</div>
      ${idx === 0 ? '<small class="health-countdown" style="display: block; margin-top: 0.5rem; color: var(--accent-cyan);"></small>' : ''}
    `;
    
    div.addEventListener("click", () => showDetailModal(r));
    div.style.animation = `recommendSlide 0.4s ease-out ${idx * 0.05}s both`;
    
    container.appendChild(div);
  });
}

function showDetailModal(obj) {
  const modal = document.getElementById("detail-modal");
  const content = document.getElementById("modal-content");
  const title = document.getElementById("modal-title");
  
  const fitness = (obj.fitness_status || "Healthy").toLowerCase();
  const statusColor = fitness === "critical" ? "#ef4444" : 
                      fitness === "minor" ? "#f59e0b" : "#10b981";
  
  title.innerHTML = `
    <i class="fas fa-train" style="margin-right: 8px;"></i>
    Train ${obj.train_id}
  `;
  
  content.innerHTML = `
    <div style="display: grid; gap: 1rem;">
      <div style="display: flex; align-items: center; gap: 1rem; padding: 1rem; background: rgba(0, 240, 255, 0.05); border-radius: 8px;">
        <div style="width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; background: ${statusColor}20; border-radius: 50%;">
          <i class="fas fa-${fitness === 'critical' ? 'exclamation-triangle' : fitness === 'minor' ? 'exclamation-circle' : 'check-circle'}" style="font-size: 1.5rem; color: ${statusColor};"></i>
        </div>
        <div>
          <div style="font-size: 0.875rem; color: var(--text-secondary);">Current Status</div>
          <div style="font-size: 1.25rem; font-weight: 600; color: ${statusColor}; text-transform: capitalize;">${obj.fitness_status || 'Healthy'}</div>
        </div>
      </div>
      
      <table style="width: 100%; border-collapse: collapse;">
        ${Object.entries(obj).filter(([key]) => !['recentlyHealed', 'exitTimer'].includes(key))
          .map(([key, value]) => {
          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          return `
            <tr style="border-bottom: 1px solid var(--border-color);">
              <td style="padding: 0.75rem; font-weight: 600; color: var(--text-secondary); width: 40%;">
                ${formattedKey}
              </td>
              <td style="padding: 0.75rem; color: var(--text-primary);">
                ${value ?? 'â€”'}
              </td>
            </tr>
          `;
        }).join('')}
      </table>
      
      <div style="display: flex; justify-content: flex-end; gap: 0.75rem; margin-top: 1rem;">
        <button onclick="closeModal()" style="padding: 0.75rem 1.5rem; background: transparent; border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; cursor: pointer;">
          Close
        </button>
      </div>
    </div>
  `;
  
  modal.classList.remove("hidden");
}

function closeModal() {
  document.getElementById("detail-modal").classList.add("hidden");
}

function updateLastUpdateTime() {
  const now = new Date();
  const timeStr = now.toLocaleTimeString('en-US', { 
    hour12: false,
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
  document.getElementById('last-update-time').textContent = timeStr;
}

function showNotification(message, type = 'info') {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 1rem 1.5rem;
    background: ${type === 'error' ? 'rgba(239, 68, 68, 0.9)' : 'rgba(16, 185, 129, 0.9)'};
    color: white;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    animation: notificationSlide 0.3s ease-out;
  `;
  notification.textContent = message;
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'notificationSlideOut 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

// Enhanced styles
const enhancedStyles = document.createElement('style');
enhancedStyles.textContent = `
  /* Depot system styles */
  #yard {
    height: 550px !important;
    position: relative;
    overflow: visible !important;
  }
  
  .train {
    min-width: 100px;
    max-width: 120px;
    padding: 8px;
    position: absolute;
    transform: translate(-50%, -50%);
    transition: all 1s ease-out;
    cursor: pointer;
  }
  
  .train.exiting {
    animation: exitPulse 1s ease-in-out infinite;
  }
  
  @keyframes exitPulse {
    0%, 100% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.5); }
    50% { box-shadow: 0 0 40px rgba(16, 185, 129, 0.8); }
  }
  
  .train-body {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    position: relative;
  }
  
  .train-lights {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    animation: lightPulse 1s ease-in-out infinite;
  }
  
  .train-lights.critical {
    background: #ef4444;
    box-shadow: 0 0 10px #ef4444;
  }
  
  .train-lights.minor {
    background: #f59e0b;
    box-shadow: 0 0 10px #f59e0b;
  }
  
  .train-lights.healthy {
    background: #10b981;
    box-shadow: 0 0 10px #10b981;
  }
  
  @keyframes lightPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  
  .status-icon {
    font-size: 16px;
    font-weight: bold;
  }
  
  .queue-badge {
    position: absolute;
    top: -8px;
    right: -8px;
    background: linear-gradient(135deg, #ef4444, #dc2626);
    color: white;
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 0.65rem;
    font-weight: 700;
    box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
  }
  
  .exit-badge {
    position: absolute;
    bottom: -8px;
    background: linear-gradient(135deg, #10b981, #059669);
    color: white;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.65rem;
    font-weight: 700;
    animation: exitBadgePulse 1s ease-in-out infinite;
  }
  
  @keyframes exitBadgePulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }
  
  .location-badge {
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.65rem;
    font-weight: 600;
    margin-left: 4px;
  }
  
  .location-badge.in-yard {
    background: rgba(0, 240, 255, 0.2);
    color: #00f0ff;
  }
  
  .location-badge.in-queue {
    background: rgba(251, 146, 60, 0.2);
    color: #fb923c;
  }
  
  .location-badge.exiting {
    background: rgba(16, 185, 129, 0.2);
    color: #10b981;
    animation: blink 0.5s ease-in-out infinite;
  }
  
  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  
  .capacity-card {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(37, 99, 235, 0.05));
    border: 1px solid rgba(59, 130, 246, 0.3);
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 12px;
  }
  
  .capacity-bar {
    width: 100%;
    height: 8px;
    background: rgba(148, 163, 184, 0.2);
    border-radius: 4px;
    margin-top: 12px;
    overflow: hidden;
  }
  
  .capacity-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent-cyan), var(--accent-blue));
    border-radius: 4px;
    transition: width 0.5s ease;
    box-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
  }
  
  @keyframes flowArrow {
    0%, 100% { opacity: 0.2; transform: translateX(0); }
    50% { opacity: 0.8; transform: translateX(10px); }
  }
  
  @keyframes slideInLeft {
    from { transform: translateX(-100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes slideOutLeft {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(-100%); opacity: 0; }
  }
  
  @keyframes slideInRight {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes slideOutRight {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
  }
  
  @keyframes healingPulse {
    0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
    50% { transform: translateX(-50%) scale(1.1); opacity: 1; }
    100% { transform: translateX(-50%) scale(1); opacity: 1; }
  }
  
  @keyframes healingFadeOut {
    from { opacity: 1; transform: translateX(-50%) translateY(0); }
    to { opacity: 0; transform: translateX(-50%) translateY(-20px); }
  }
  
  @keyframes healingGlow {
    0% { box-shadow: 0 0 20px rgba(16, 185, 129, 0); }
    50% { box-shadow: 0 0 60px rgba(16, 185, 129, 1); }
    100% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.4); }
  }
  
  @keyframes healthyUpdate {
    0% { transform: scale(1); background: rgba(16, 185, 129, 0); }
    50% { transform: scale(1.05); background: rgba(16, 185, 129, 0.1); }
    100% { transform: scale(1); background: rgba(16, 185, 129, 0); }
  }
  
  @keyframes notificationSlide {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes notificationSlideOut {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
  }
  
  @keyframes tableRowSlide {
    from { opacity: 0; transform: translateX(-20px); }
    to { opacity: 1; transform: translateX(0); }
  }
  
  @keyframes recommendSlide {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  .next-badge.pulse {
    animation: nextPulse 1.5s ease-in-out infinite;
  }
  
  @keyframes nextPulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.8; transform: scale(1.05); }
  }
  
  .status-dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    animation: statusPulse 2s ease-in-out infinite;
  }
  
  .status-dot.critical {
    background: #ef4444;
    box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
  }
  
  .status-dot.minor {
    background: #f59e0b;
    box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
  }
  
  .status-dot.healthy {
    background: #10b981;
    box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
  }
  
  @keyframes statusPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
  }
  
  .days-badge {
    display: inline-block;
    padding: 2px 8px;
    background: rgba(148, 163, 184, 0.1);
    border-radius: 12px;
    font-size: 0.875rem;
    font-weight: 600;
  }
  
  .days-badge.urgent {
    background: rgba(239, 68, 68, 0.2);
    color: #fca5a5;
    animation: urgentPulse 1s ease-in-out infinite;
  }
  
  @keyframes urgentPulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
    50% { box-shadow: 0 0 10px 2px rgba(239, 68, 68, 0.3); }
  }
`;
document.head.appendChild(enhancedStyles);

// Main refresh function
async function refreshAll() {
  try {
    const { statusData, recData } = await fetchAll();
    
    if (isInitialLoad) {
      backendStatusData = [...statusData];
      localStatusData = [...statusData];
      currentRecData = recData;
      isInitialLoad = false;
      
      // Initialize depot on first load
      initializeDepotPositions();
    } else {
      // Preserve local changes
      backendStatusData = [...statusData];
      localStatusData = statusData.map(backendTrain => {
        const localTrain = localStatusData.find(t => t.train_id === backendTrain.train_id);
        if (localTrain && healthProcessedTrains.has(backendTrain.train_id)) {
          return {
            ...backendTrain,
            fitness_status: localTrain.fitness_status,
            days_until_next_service: localTrain.days_until_next_service,
            consequence_if_skipped: localTrain.consequence_if_skipped,
            exitTimer: localTrain.exitTimer
          };
        }
        return backendTrain;
      });
      currentRecData = recData;
    }
    
    updateAllVisualizations();
    
    // Render yard
    renderTracksSVG();
    const layer = document.getElementById("trains-layer");
    
    // Only recreate trains if needed
    if (layer.children.length === 0) {
      layer.innerHTML = "";
      
      // Create trains in yard
      Array.from(trainsInYard).forEach((trainId, index) => {
        const train = localStatusData.find(t => t.train_id === trainId);
        if (train) {
          const position = calculateYardPosition(index);
          const el = createTrainElement(train, position, false);
          layer.appendChild(el);
        }
      });
      
      // Create trains in queue (off-screen)
      trainQueue.forEach((trainId, index) => {
        const train = localStatusData.find(t => t.train_id === trainId);
        if (train) {
          const el = createTrainElement(train, { 
            x: QUEUE_X, 
            y: QUEUE_Y_START + index * QUEUE_SPACING 
          }, false);
          el.style.opacity = '0.3';
          layer.appendChild(el);
        }
      });
    } else {
      updateYardTrains();
    }
    
  } catch (err) {
    console.error("Error refreshing:", err);
  }
}
---------------------------------------script.js 9----------------------------------
// Enhanced Control Center Script with Track-based Sequential Healing
const API_BASE = "http://127.0.0.1:5000";
const REFRESH_MS = 8000;
const HEALTH_UPDATE_MS = 30000; // 30 seconds for health update cycle
const EXIT_DELAY_MS = 10000; // 10 seconds before healthy train exits
const TRACK_HEAL_DELAY = 3000; // 3 seconds between each track healing
const MAX_TRAINS_PER_TRACK = 2; // Maximum trains per track

// Track positions
const TRACK_Y = { 1: 120, 2: 220, 3: 320, 4: 420 };

// Zone X positions
const QUEUE_X_START = 50; // Queue area (left)
const QUEUE_X_END = 150;
const REPAIR_X_START = 250; // Repair area (center-right)
const REPAIR_X_END = 750;
const EXIT_X = 950; // Exit area (far right)

// Repair bay positions per track
const REPAIR_SLOTS = {
  1: [350, 550], // Two slots per track
  2: [350, 550],
  3: [350, 550],
  4: [350, 550]
};

let healthChart = null;
let currentScale = 1;
let localStatusData = [];
let backendStatusData = [];
let currentRecData = [];

// Track management
let trackAssignments = new Map(); // trainId -> track number
let trainsInRepair = new Map(); // track -> [trainIds]
let trainQueue = []; // Trains waiting to enter
let exitingTrains = new Set(); // Trains that are exiting
let healthProcessedTrains = new Set();
let isInitialLoad = true;

// Healing system
let isProcessingHealth = false;
let currentHealingTrack = 1;
let healingInProgress = false;

// Initialize on DOM load
document.addEventListener('DOMContentLoaded', () => {
  initializeApp();
  setupEventListeners();
  createParticles();
  animateBackground();
});

async function initializeApp() {
  showLoading();
  await refreshAll();
  setTimeout(() => hideLoading(), 1500);
  
  // Start systems after initial load
  setTimeout(() => {
    startHealthImprovementSystem();
    startDepotManagementSystem();
  }, 2000);
  
  // Periodic refresh
  refreshInterval = setInterval(() => {
    if (!healingInProgress) {
      refreshAll();
    }
  }, REFRESH_MS);
}

function showLoading() {
  document.getElementById('loading-overlay').classList.remove('hidden');
}

function hideLoading() {
  document.getElementById('loading-overlay').classList.add('hidden');
}

function setupEventListeners() {
  document.getElementById('zoom-in').addEventListener('click', () => {
    currentScale = Math.min(currentScale + 0.1, 1.5);
    document.getElementById('tracks-svg').style.transform = `scale(${currentScale})`;
    document.getElementById('trains-layer').style.transform = `scale(${currentScale})`;
  });
  
  document.getElementById('zoom-out').addEventListener('click', () => {
    currentScale = Math.max(currentScale - 0.1, 0.7);
    document.getElementById('tracks-svg').style.transform = `scale(${currentScale})`;
    document.getElementById('trains-layer').style.transform = `scale(${currentScale})`;
  });
  
  document.getElementById('refresh-yard').addEventListener('click', () => {
    animateRefresh();
    refreshAll();
  });
  
  document.getElementById('modal-close').addEventListener('click', closeModal);
  document.querySelector('.modal-backdrop').addEventListener('click', closeModal);
}

function animateRefresh() {
  const btn = document.getElementById('refresh-yard');
  btn.style.animation = 'spin 0.5s ease';
  setTimeout(() => btn.style.animation = '', 500);
}

// Create floating particles
function createParticles() {
  const container = document.getElementById('particles');
  for (let i = 0; i < 50; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.cssText = `
      position: absolute;
      width: ${Math.random() * 3 + 1}px;
      height: ${Math.random() * 3 + 1}px;
      background: rgba(0, 240, 255, ${Math.random() * 0.5 + 0.2});
      border-radius: 50%;
      left: ${Math.random() * 100}%;
      top: ${Math.random() * 100}%;
      animation: particleFloat ${Math.random() * 20 + 10}s linear infinite;
      animation-delay: ${Math.random() * 5}s;
    `;
    container.appendChild(particle);
  }
}

function animateBackground() {
  let hue = 0;
  setInterval(() => {
    hue = (hue + 1) % 360;
    document.documentElement.style.setProperty('--dynamic-hue', `${hue}deg`);
  }, 100);
}

// Initialize track-based depot system
function initializeDepotPositions() {
  trackAssignments.clear();
  trainsInRepair.clear();
  trainQueue = [];
  exitingTrains.clear();
  
  // Initialize repair tracks
  for (let track = 1; track <= 4; track++) {
    trainsInRepair.set(track, []);
  }
  
  // Assign trains to tracks or queue
  localStatusData.forEach((train, index) => {
    const track = (index % 4) + 1;
    
    if (trainsInRepair.get(track).length < MAX_TRAINS_PER_TRACK && index < 8) {
      // Assign to repair bay
      trackAssignments.set(train.train_id, track);
      trainsInRepair.get(track).push(train.train_id);
    } else {
      // Add to queue
      trainQueue.push(train.train_id);
    }
  });
  
  console.log('Depot initialized:', {
    inRepair: Array.from(trainsInRepair.entries()).map(([t, trains]) => `Track ${t}: ${trains.length}`),
    inQueue: trainQueue.length
  });
}

// Depot Management System
function startDepotManagementSystem() {
  console.log('Depot management system started');
  initializeDepotPositions();
  
  // Check for movements periodically
  setInterval(processDepotMovements, 2000);
}

function processDepotMovements() {
  // Process exits
  exitingTrains.forEach(trainId => {
    const trainData = localStatusData.find(t => t.train_id === trainId);
    if (trainData && trainData.exitTimer && Date.now() >= trainData.exitTimer) {
      performTrainExit(trainId);
    }
  });
  
  // Fill empty slots from queue
  for (let track = 1; track <= 4; track++) {
    const trainsOnTrack = trainsInRepair.get(track) || [];
    
    if (trainsOnTrack.length < MAX_TRAINS_PER_TRACK && trainQueue.length > 0) {
      const nextTrain = trainQueue.shift();
      if (nextTrain) {
        performTrainEntry(nextTrain, track);
      }
    }
  }
}

function performTrainExit(trainId) {
  console.log(`Train ${trainId} exiting`);
  
  const track = trackAssignments.get(trainId);
  if (!track) return;
  
  const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
  if (trainElement) {
    // Animate exit
    trainElement.style.transition = 'all 2s ease-out';
    trainElement.style.left = `${EXIT_X}px`;
    trainElement.style.opacity = '0';
    
    setTimeout(() => {
      trainElement.remove();
      
      // Update data structures
      const trainsOnTrack = trainsInRepair.get(track) || [];
      const index = trainsOnTrack.indexOf(trainId);
      if (index > -1) {
        trainsOnTrack.splice(index, 1);
      }
      
      trackAssignments.delete(trainId);
      exitingTrains.delete(trainId);
      
      // Move remaining train forward on same track
      moveTrainsForwardOnTrack(track);
      
      showExitNotification(trainId, track);
    }, 2000);
  }
}

function performTrainEntry(trainId, track) {
  console.log(`Train ${trainId} entering track ${track}`);
  
  const train = localStatusData.find(t => t.train_id === trainId);
  if (!train) return;
  
  // Assign to track
  trackAssignments.set(trainId, track);
  const trainsOnTrack = trainsInRepair.get(track) || [];
  trainsOnTrack.push(trainId);
  
  // Calculate position on track
  const slotIndex = trainsOnTrack.length - 1;
  const x = REPAIR_SLOTS[track][slotIndex] || REPAIR_SLOTS[track][0];
  const y = TRACK_Y[track];
  
  // Create train element in queue position
  const trainElement = createTrainElement(train, track, true);
  document.getElementById('trains-layer').appendChild(trainElement);
  
  // Animate entry to repair position
  setTimeout(() => {
    trainElement.style.transition = 'all 1.5s ease-out';
    trainElement.style.left = `${x}px`;
    trainElement.style.opacity = '1';
    
    showEntryNotification(trainId, track);
  }, 100);
}

function moveTrainsForwardOnTrack(track) {
  const trainsOnTrack = trainsInRepair.get(track) || [];
  
  trainsOnTrack.forEach((trainId, index) => {
    const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
    if (trainElement && !exitingTrains.has(trainId)) {
      const x = REPAIR_SLOTS[track][index];
      trainElement.style.transition = 'all 1s ease-out';
      trainElement.style.left = `${x}px`;
    }
  });
}

// Sequential Track Healing System
let healthSystemStarted = false;
let healingCycleInProgress = false;

function startHealthImprovementSystem() {
  if (healthSystemStarted) return;
  healthSystemStarted = true;
  
  console.log('Sequential healing system started');
  
  // Start healing cycles
  setInterval(() => {
    if (!healingCycleInProgress) {
      startHealingCycle();
    }
  }, HEALTH_UPDATE_MS);
  
  // Update countdown
  updateHealthCountdown();
  setInterval(updateHealthCountdown, 1000);
}

function startHealingCycle() {
  console.log('Starting healing cycle');
  healingCycleInProgress = true;
  healingInProgress = true;
  currentHealingTrack = 1;
  
  // Process each track sequentially
  processTrackHealing();
}

function processTrackHealing() {
  if (currentHealingTrack > 4) {
    // Cycle complete
    healingCycleInProgress = false;
    healingInProgress = false;
    console.log('Healing cycle complete');
    return;
  }
  
  console.log(`Processing healing for track ${currentHealingTrack}`);
  
  // Find first non-healthy train on this track (based on recommendations)
  const trainsOnTrack = trainsInRepair.get(currentHealingTrack) || [];
  
  let trainToHeal = null;
  for (const rec of currentRecData) {
    if (trainsOnTrack.includes(rec.train_id)) {
      const train = localStatusData.find(t => t.train_id === rec.train_id);
      if (train && train.fitness_status !== 'Healthy' && !healthProcessedTrains.has(train.train_id)) {
        trainToHeal = train;
        break;
      }
    }
  }
  
  if (trainToHeal) {
    healTrain(trainToHeal, currentHealingTrack);
  } else {
    console.log(`No trains to heal on track ${currentHealingTrack}`);
  }
  
  // Move to next track after delay
  setTimeout(() => {
    currentHealingTrack++;
    processTrackHealing();
  }, TRACK_HEAL_DELAY);
}

function healTrain(train, track) {
  console.log(`Healing train ${train.train_id} on track ${track}`);
  
  // Mark as processed
  healthProcessedTrains.add(train.train_id);
  
  // Show track-specific healing animation
  showTrackHealingAnimation(track, train.train_id);
  
  // Update train status
  const trainIndex = localStatusData.findIndex(t => t.train_id === train.train_id);
  if (trainIndex !== -1) {
    localStatusData[trainIndex] = {
      ...localStatusData[trainIndex],
      fitness_status: 'Healthy',
      days_until_next_service: 30,
      consequence_if_skipped: 'Regular maintenance',
      recentlyHealed: true,
      exitTimer: Date.now() + EXIT_DELAY_MS
    };
    
    // Mark for exit
    exitingTrains.add(train.train_id);
    
    // Update visualizations
    updateAllVisualizations();
    
    // Animate the train
    animateHealthTransition(train.train_id, track);
  }
}

function showTrackHealingAnimation(track, trainId) {
  // Track-specific healing effect
  const trackY = TRACK_Y[track];
  
  const healEffect = document.createElement('div');
  healEffect.className = 'track-heal-effect';
  healEffect.style.cssText = `
    position: fixed;
    left: 250px;
    top: ${trackY}px;
    width: 500px;
    height: 60px;
    background: linear-gradient(90deg, transparent, rgba(16, 185, 129, 0.3), transparent);
    border-radius: 30px;
    pointer-events: none;
    z-index: 50;
    animation: healWave 1s ease-out;
  `;
  
  document.getElementById('yard').appendChild(healEffect);
  
  setTimeout(() => healEffect.remove(), 1000);
  
  // Notification
  const notification = document.createElement('div');
  notification.className = 'healing-notification';
  notification.innerHTML = `
    <i class="fas fa-wrench"></i>
    <span>Track ${track}: Train ${trainId} maintenance completed!</span>
    <i class="fas fa-check-circle"></i>
    <div style="font-size: 0.8rem; margin-top: 4px; opacity: 0.8;">Will exit in 10 seconds...</div>
  `;
  notification.style.cssText = `
    position: fixed;
    top: ${80 + (track - 1) * 30}px;
    left: 50%;
    transform: translateX(-50%);
    padding: 1rem 2rem;
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.95), rgba(5, 150, 105, 0.95));
    color: white;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(16, 185, 129, 0.4);
    z-index: 1000;
    text-align: center;
    animation: healingPulse 0.6s ease-out;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'healingFadeOut 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

function updateHealthCountdown() {
  const timeLeft = Math.ceil((HEALTH_UPDATE_MS - (Date.now() % HEALTH_UPDATE_MS)) / 1000);
  const countdownElements = document.querySelectorAll('.health-countdown');
  countdownElements.forEach(el => {
    if (healingCycleInProgress) {
      el.textContent = `Healing in progress... Track ${currentHealingTrack}/4`;
    } else {
      el.textContent = `Next maintenance cycle: ${timeLeft}s`;
    }
  });
}

function showExitNotification(trainId, track) {
  const notification = document.createElement('div');
  notification.innerHTML = `
    <i class="fas fa-sign-out-alt"></i>
    Train ${trainId} has left Track ${track}
  `;
  notification.style.cssText = `
    position: fixed;
    bottom: ${20 + (track - 1) * 60}px;
    right: 20px;
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(37, 99, 235, 0.9));
    color: white;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
    animation: slideInRight 0.5s ease-out;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'slideOutRight 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

function showEntryNotification(trainId, track) {
  const notification = document.createElement('div');
  notification.innerHTML = `
    <i class="fas fa-sign-in-alt"></i>
    Train ${trainId} has entered Track ${track}
  `;
  notification.style.cssText = `
    position: fixed;
    bottom: ${20 + (track - 1) * 60}px;
    left: 20px;
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, rgba(251, 146, 60, 0.9), rgba(249, 115, 22, 0.9));
    color: white;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(251, 146, 60, 0.3);
    animation: slideInLeft 0.5s ease-out;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'slideOutLeft 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

function animateHealthTransition(trainId, track) {
  const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
  if (trainElement) {
    // Add track-specific healing animation
    trainElement.style.animation = `trackHeal${track} 1s ease-out`;
    
    setTimeout(() => {
      trainElement.className = 'train healthy exiting';
      trainElement.dataset.track = track;
      
      // Add exit indicator
      const exitBadge = document.createElement('div');
      exitBadge.className = 'exit-badge';
      exitBadge.innerHTML = `<i class="fas fa-check"></i> T${track} Ready`;
      trainElement.appendChild(exitBadge);
    }, 500);
  }
}

function updateAllVisualizations() {
  updateSummaryCounts(localStatusData);
  renderStatusTable(localStatusData, currentRecData);
  
  // Filter recommendations for trains in repair
  const allRepairTrains = Array.from(trainsInRepair.values()).flat();
  const activeRecs = currentRecData.filter(r => {
    const train = localStatusData.find(t => t.train_id === r.train_id);
    return train && 
           train.fitness_status !== 'Healthy' && 
           allRepairTrains.includes(train.train_id);
  });
  renderRecommendations(activeRecs);
  
  updateYardTrains();
}

async function fetchAll() {
  try {
    const [statusRes, recRes] = await Promise.all([
      fetch(`${API_BASE}/api/current_status`),
      fetch(`${API_BASE}/api/recommendation`)
    ]);
    
    if (!statusRes.ok || !recRes.ok) throw new Error("API fetch failed");
    
    const statusData = await statusRes.json();
    const recData = await recRes.json();
    
    return { statusData, recData };
  } catch (error) {
    console.error("Fetch error:", error);
    return { statusData: localStatusData, recData: currentRecData };
  }
}

function renderTracksSVG() {
  const svg = document.getElementById("tracks-svg");
  svg.innerHTML = "";
  
  // Create definitions
  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  
  // Track gradient
  const trackGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
  trackGradient.setAttribute("id", "trackGradient");
  trackGradient.innerHTML = `
    <stop offset="0%" style="stop-color:#1e293b;stop-opacity:0.8" />
    <stop offset="50%" style="stop-color:#334155;stop-opacity:0.6" />
    <stop offset="100%" style="stop-color:#1e293b;stop-opacity:0.8" />
  `;
  defs.appendChild(trackGradient);
  
  // Healing gradient for each track
  for (let t = 1; t <= 4; t++) {
    const healGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
    healGradient.setAttribute("id", `healGradient${t}`);
    healGradient.innerHTML = `
      <stop offset="0%" style="stop-color:#10b981;stop-opacity:0">
        <animate attributeName="stop-opacity" values="0;0.6;0" dur="3s" begin="${(t-1)*3}s" repeatCount="indefinite" />
      </stop>
      <stop offset="50%" style="stop-color:#10b981;stop-opacity:0">
        <animate attributeName="stop-opacity" values="0;1;0" dur="3s" begin="${(t-1)*3}s" repeatCount="indefinite" />
      </stop>
      <stop offset="100%" style="stop-color:#10b981;stop-opacity:0">
        <animate attributeName="stop-opacity" values="0;0.6;0" dur="3s" begin="${(t-1)*3}s" repeatCount="indefinite" />
      </stop>
    `;
    defs.appendChild(healGradient);
  }
  
  svg.appendChild(defs);
  
  // Draw queue area (left)
  const queueArea = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  queueArea.setAttribute("x", 20);
  queueArea.setAttribute("y", 50);
  queueArea.setAttribute("width", 180);
  queueArea.setAttribute("height", 450);
  queueArea.setAttribute("fill", "rgba(251, 146, 60, 0.03)");
  queueArea.setAttribute("stroke", "rgba(251, 146, 60, 0.2)");
  queueArea.setAttribute("stroke-width", "2");
  queueArea.setAttribute("stroke-dasharray", "5 5");
  queueArea.setAttribute("rx", 10);
  svg.appendChild(queueArea);
  
  // Queue label
  const queueLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
  queueLabel.setAttribute("x", 110);
  queueLabel.setAttribute("y", 35);
  queueLabel.setAttribute("text-anchor", "middle");
  queueLabel.setAttribute("fill", "rgba(251, 146, 60, 0.8)");
  queueLabel.setAttribute("font-size", "14");
  queueLabel.setAttribute("font-weight", "600");
  queueLabel.textContent = "WAITING QUEUE";
  svg.appendChild(queueLabel);
  
  // Draw repair area (center-right)
  const repairArea = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  repairArea.setAttribute("x", 220);
  repairArea.setAttribute("y", 50);
  repairArea.setAttribute("width", 580);
  repairArea.setAttribute("height", 450);
  repairArea.setAttribute("fill", "rgba(0, 240, 255, 0.02)");
  repairArea.setAttribute("stroke", "rgba(0, 240, 255, 0.15)");
  repairArea.setAttribute("stroke-width", "2");
  repairArea.setAttribute("rx", 10);
  svg.appendChild(repairArea);
  
  // Repair label
  const repairLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
  repairLabel.setAttribute("x", 510);
  repairLabel.setAttribute("y", 35);
  repairLabel.setAttribute("text-anchor", "middle");
  repairLabel.setAttribute("fill", "rgba(0, 240, 255, 0.8)");
  repairLabel.setAttribute("font-size", "14");
  repairLabel.setAttribute("font-weight", "600");
  repairLabel.textContent = "MAINTENANCE & REPAIR BAY";
  svg.appendChild(repairLabel);
  
  // Draw exit area (far right)
  const exitArea = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  exitArea.setAttribute("x", 820);
  exitArea.setAttribute("y", 50);
  exitArea.setAttribute("width", 160);
  exitArea.setAttribute("height", 450);
  exitArea.setAttribute("fill", "rgba(16, 185, 129, 0.03)");
  exitArea.setAttribute("stroke", "rgba(16, 185, 129, 0.2)");
  exitArea.setAttribute("stroke-width", "2");
  exitArea.setAttribute("stroke-dasharray", "5 5");
  exitArea.setAttribute("rx", 10);
  svg.appendChild(exitArea);
  
  // Exit label
  const exitLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
  exitLabel.setAttribute("x", 900);
  exitLabel.setAttribute("y", 35);
  exitLabel.setAttribute("text-anchor", "middle");
  exitLabel.setAttribute("fill", "rgba(16, 185, 129, 0.8)");
  exitLabel.setAttribute("font-size", "14");
  exitLabel.setAttribute("font-weight", "600");
  exitLabel.textContent = "EXIT ZONE";
  svg.appendChild(exitLabel);
  
  // Draw tracks
  for (let t = 1; t <= 4; t++) {
    const y = TRACK_Y[t];
    
    // Track background
    const trackBg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    trackBg.setAttribute("x", 20);
    trackBg.setAttribute("y", y - 25);
    trackBg.setAttribute("width", 960);
    trackBg.setAttribute("height", 50);
    trackBg.setAttribute("fill", "url(#trackGradient)");
    trackBg.setAttribute("rx", 25);
    trackBg.setAttribute("opacity", "0.2");
    svg.appendChild(trackBg);
    
    // Repair zone highlight
    const repairZone = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    repairZone.setAttribute("x", 250);
    repairZone.setAttribute("y", y - 20);
    repairZone.setAttribute("width", 500);
    repairZone.setAttribute("height", 40);
    repairZone.setAttribute("fill", `url(#healGradient${t})`);
    repairZone.setAttribute("rx", 20);
    repairZone.setAttribute("opacity", "0.3");
    svg.appendChild(repairZone);
    
    // Rails
    const rail1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
    rail1.setAttribute("x1", 30);
    rail1.setAttribute("y1", y - 10);
    rail1.setAttribute("x2", 970);
    rail1.setAttribute("y2", y - 10);
    rail1.setAttribute("stroke", "#475569");
    rail1.setAttribute("stroke-width", "3");
    rail1.setAttribute("opacity", "0.6");
    svg.appendChild(rail1);
    
    const rail2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
    rail2.setAttribute("x1", 30);
    rail2.setAttribute("y1", y + 10);
    rail2.setAttribute("x2", 970);
    rail2.setAttribute("y2", y + 10);
    rail2.setAttribute("stroke", "#475569");
    rail2.setAttribute("stroke-width", "3");
    rail2.setAttribute("opacity", "0.6");
    svg.appendChild(rail2);
    
    // Repair stations
    for (let s = 0; s < 2; s++) {
      const cx = REPAIR_SLOTS[t][s];
      
      // Station marker
      const station = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      station.setAttribute("cx", cx);
      station.setAttribute("cy", y);
      station.setAttribute("r", 20);
      station.setAttribute("fill", "rgba(0, 240, 255, 0.05)");
      station.setAttribute("stroke", "rgba(0, 240, 255, 0.2)");
      station.setAttribute("stroke-width", "2");
      svg.appendChild(station);
      
      // Station label
      const stationLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
      stationLabel.setAttribute("x", cx);
      stationLabel.setAttribute("y", y + 5);
      stationLabel.setAttribute("text-anchor", "middle");
      stationLabel.setAttribute("fill", "rgba(0, 240, 255, 0.4)");
      stationLabel.setAttribute("font-size", "11");
      stationLabel.setAttribute("font-weight", "600");
      stationLabel.textContent = `${t}-${s+1}`;
      svg.appendChild(stationLabel);
    }
    
    // Track number
    const trackNum = document.createElementNS("http://www.w3.org/2000/svg", "text");
    trackNum.setAttribute("x", 235);
    trackNum.setAttribute("y", y + 5);
    trackNum.setAttribute("fill", "rgba(148, 163, 184, 0.8)");
    trackNum.setAttribute("font-size", "14");
    trackNum.setAttribute("font-weight", "700");
    trackNum.textContent = `T${t}`;
    svg.appendChild(trackNum);
    
    // Flow indicators
    for (let i = 0; i < 3; i++) {
      const arrow = document.createElementNS("http://www.w3.org/2000/svg", "text");
      arrow.setAttribute("x", 205);
      arrow.setAttribute("y", y + 5);
      arrow.setAttribute("fill", "rgba(251, 146, 60, 0.3)");
      arrow.setAttribute("font-size", "16");
      arrow.textContent = "â†’";
      arrow.style.animation = `flowArrow ${2 + t * 0.2}s ease-in-out infinite`;
      arrow.style.animationDelay = `${i * 0.3}s`;
      svg.appendChild(arrow);
    }
    
    for (let i = 0; i < 3; i++) {
      const arrow = document.createElementNS("http://www.w3.org/2000/svg", "text");
      arrow.setAttribute("x", 805);
      arrow.setAttribute("y", y + 5);
      arrow.setAttribute("fill", "rgba(16, 185, 129, 0.3)");
      arrow.setAttribute("font-size", "16");
      arrow.textContent = "â†’";
      arrow.style.animation = `flowArrow ${2 + t * 0.2}s ease-in-out infinite`;
      arrow.style.animationDelay = `${i * 0.3}s`;
      svg.appendChild(arrow);
    }
  }
}

function createTrainElement(train, track, isEntering = false) {
  const div = document.createElement("div");
  div.className = "train";
  const fitness = (train.fitness_status || "Healthy").toLowerCase();
  div.classList.add(fitness);
  div.dataset.id = train.train_id;
  div.dataset.track = track;
  
  const y = TRACK_Y[track];
  
  // Set initial position
  if (isEntering) {
    // Start from queue
    div.style.left = `${QUEUE_X_END}px`;
    div.style.top = `${y}px`;
    div.style.opacity = '0.5';
  } else {
    // Already in position
    const trainsOnTrack = trainsInRepair.get(track) || [];
    const index = trainsOnTrack.indexOf(train.train_id);
    const x = index >= 0 ? REPAIR_SLOTS[track][index] : REPAIR_SLOTS[track][0];
    div.style.left = `${x}px`;
    div.style.top = `${y}px`;
  }
  
  // Queue indicator
  const queuePosition = trainQueue.indexOf(train.train_id);
  const queueBadge = queuePosition >= 0 ? 
    `<span class="queue-badge">Queue #${queuePosition + 1}</span>` : '';
  
  // Track indicator
  const trackBadge = track ? 
    `<span class="track-badge">T${track}</span>` : '';
  
  // Train body
  div.innerHTML = `
    <div class="train-body">
      <div class="train-lights ${fitness}"></div>
      <div class="train-info">
        <div class="id">${train.train_id}</div>
        <div class="status-icon">
          ${fitness === 'healthy' ? 'âœ“' : fitness === 'critical' ? 'âš ' : '!'}
        </div>
      </div>
      ${trackBadge}
      ${queueBadge}
    </div>
  `;
  
  // Store info
  div.dataset.info = JSON.stringify(train);
  
  // Event handlers
  div.addEventListener('mouseenter', (e) => {
    createHoverParticles(e);
    div.style.zIndex = '10';
  });
  
  div.addEventListener('mouseleave', () => {
    div.style.zIndex = '1';
  });
  
  div.addEventListener('click', (e) => {
    e.stopPropagation();
    showDetailModal(train);
  });
  
  return div;
}

function updateYardTrains() {
  const layer = document.getElementById("trains-layer");
  
  localStatusData.forEach(train => {
    const existingTrain = layer.querySelector(`[data-id="${train.train_id}"]`);
    
    if (existingTrain) {
      const fitness = (train.fitness_status || "Healthy").toLowerCase();
      existingTrain.className = `train ${fitness}`;
      if (exitingTrains.has(train.train_id)) {
        existingTrain.classList.add('exiting');
      }
      
      existingTrain.dataset.info = JSON.stringify(train);
      
      // Update status icon
      const statusIcon = existingTrain.querySelector('.status-icon');
      if (statusIcon) {
        statusIcon.textContent = fitness === 'healthy' ? 'âœ“' : 
                                 fitness === 'critical' ? 'âš ' : '!';
      }
      
      // Update queue badge
      const queuePosition = trainQueue.indexOf(train.train_id);
      const queueBadge = existingTrain.querySelector('.queue-badge');
      if (queuePosition >= 0) {
        if (queueBadge) {
          queueBadge.textContent = `Queue #${queuePosition + 1}`;
        }
      } else if (queueBadge) {
        queueBadge.remove();
      }
    }
  });
}

function createHoverParticles(e) {
  const train = e.currentTarget;
  const rect = train.getBoundingClientRect();
  const track = parseInt(train.dataset.track) || 1;
  
  for (let i = 0; i < 6; i++) {
    const particle = document.createElement('div');
    particle.style.cssText = `
      position: fixed;
      width: 4px;
      height: 4px;
      background: linear-gradient(45deg, #00f0ff, #10b981);
      border-radius: 50%;
      left: ${rect.left + rect.width / 2}px;
      top: ${rect.bottom}px;
      pointer-events: none;
      z-index: 100;
    `;
    document.body.appendChild(particle);
    
    const angle = (Math.PI * 2 * i) / 6;
    const distance = 30 + Math.random() * 20;
    particle.animate([
      { transform: 'translate(0, 0) scale(1)', opacity: 1 },
      { transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`, opacity: 0 }
    ], {
      duration: 800,
      easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
    }).onfinish = () => particle.remove();
  }
}

// UI Update Functions
function animateStatCounter(element, newValue) {
  const current = parseInt(element.dataset.value) || 0;
  const duration = 1000;
  const start = Date.now();
  
  const animate = () => {
    const elapsed = Date.now() - start;
    const progress = Math.min(elapsed / duration, 1);
    const value = Math.floor(current + (newValue - current) * easeOutQuart(progress));
    
    element.textContent = value;
    
    if (progress < 1) {
      requestAnimationFrame(animate);
    } else {
      element.dataset.value = newValue;
    }
  };
  
  animate();
}

function easeOutQuart(t) {
  return 1 - Math.pow(1 - t, 4);
}

function updateSummaryCounts(statusData) {
  const total = statusData.length;
  const critical = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "critical").length;
  const minor = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "minor").length;
  const healthy = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "healthy").length;
  
  animateStatCounter(document.querySelector('#stat-total .stat-value'), total);
  animateStatCounter(document.querySelector('#stat-critical .stat-value'), critical);
  animateStatCounter(document.querySelector('#stat-minor .stat-value'), minor);
  animateStatCounter(document.querySelector('#stat-healthy .stat-value'), healthy);
  
  updateHealthChart(critical, minor, healthy);
  updateChartCenterLabel(healthy, total);
}

function updateChartCenterLabel(healthy, total) {
  const percentage = total > 0 ? Math.round((healthy / total) * 100) : 0;
  document.querySelector('.chart-percentage').textContent = `${percentage}%`;
}

function updateHealthChart(critical, minor, healthy) {
  const ctx = document.getElementById("healthChart").getContext("2d");
  
  if (healthChart) {
    healthChart.data.datasets[0].data = [critical, minor, healthy];
    healthChart.update('active');
    return;
  }
  
  healthChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: ['Critical', 'Minor Issues', 'Healthy'],
      datasets: [{
        data: [critical, minor, healthy],
        backgroundColor: [
          'rgba(239, 68, 68, 0.8)',
          'rgba(245, 158, 11, 0.8)',
          'rgba(16, 185, 129, 0.8)'
        ],
        borderColor: [
          'rgba(239, 68, 68, 1)',
          'rgba(245, 158, 11, 1)',
          'rgba(16, 185, 129, 1)'
        ],
        borderWidth: 2,
        hoverOffset: 4
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      cutout: '70%',
      plugins: {
        legend: {
          position: 'bottom',
          labels: {
            color: '#94a3b8',
            padding: 15,
            font: { size: 11 }
          }
        }
      },
      animation: {
        animateRotate: true,
        animateScale: true,
        duration: 1500,
        easing: 'easeInOutQuart'
      }
    }
  });
}

function renderStatusTable(statusData, recData) {
  const tbody = document.getElementById("status-body");
  tbody.innerHTML = "";
  
  statusData.forEach((train, idx) => {
    const match = recData.find(r => r.train_id === train.train_id) || {};
    const fitness = (train.fitness_status || "Healthy").toLowerCase();
    const track = trackAssignments.get(train.train_id);
    const allRepairTrains = Array.from(trainsInRepair.values()).flat();
    const inRepair = allRepairTrains.includes(train.train_id);
    const inQueue = trainQueue.includes(train.train_id);
    const isExiting = exitingTrains.has(train.train_id);
    
    let locationBadge = '';
    if (isExiting) {
      locationBadge = `<span class="location-badge exiting">Exiting T${track}</span>`;
    } else if (inRepair) {
      locationBadge = `<span class="location-badge in-repair">Track ${track}</span>`;
    } else if (inQueue) {
      const queuePos = trainQueue.indexOf(train.train_id) + 1;
      locationBadge = `<span class="location-badge in-queue">Queue #${queuePos}</span>`;
    }
    
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>
        <div style="display: flex; align-items: center; gap: 8px;">
          <i class="fas fa-train" style="color: ${fitness === 'healthy' ? '#10b981' : fitness === 'critical' ? '#ef4444' : '#f59e0b'}; font-size: 12px;"></i>
          ${train.train_id}
          ${locationBadge}
        </div>
      </td>
      <td>${train.yard_position || 'â€”'}</td>
      <td class="${fitness}">
        <span style="display: inline-flex; align-items: center; gap: 6px;">
          <span class="status-dot ${fitness}"></span>
          ${train.fitness_status || 'Healthy'}
        </span>
      </td>
      <td>${train.next_service_due_date || 'â€”'}</td>
      <td>
        <span class="days-badge ${train.days_until_next_service < 3 ? 'urgent' : ''}">
          ${train.days_until_next_service ?? 'â€”'}
        </span>
      </td>
      <td>${match.consequence_if_skipped || train.consequence_if_skipped || 'â€”'}</td>
    `;
    
    tbody.appendChild(tr);
    tr.style.animation = `tableRowSlide 0.3s ease-out ${idx * 0.02}s both`;
  });
  
  updateLastUpdateTime();
}

function renderRecommendations(activeRecs) {
  const container = document.getElementById("recommend-list");
  container.innerHTML = "";
  
  // Track status card
  const trackCard = document.createElement('div');
  trackCard.className = 'track-status-card';
  trackCard.innerHTML = `
    <div style="font-weight: 600; margin-bottom: 12px; color: var(--accent-cyan);">
      <i class="fas fa-tasks"></i> Track Status
    </div>
  `;
  
  for (let t = 1; t <= 4; t++) {
    const trainsOnTrack = trainsInRepair.get(t) || [];
    const trackDiv = document.createElement('div');
    trackDiv.className = 'track-status-item';
    trackDiv.innerHTML = `
      <span>Track ${t}</span>
      <span style="display: flex; align-items: center; gap: 8px;">
        <span class="track-count">${trainsOnTrack.length}/${MAX_TRAINS_PER_TRACK}</span>
        ${healingCycleInProgress && currentHealingTrack === t ? 
          '<span class="healing-indicator"><i class="fas fa-wrench"></i></span>' : ''}
      </span>
    `;
    trackCard.appendChild(trackDiv);
  }
  
  trackCard.innerHTML += `
    <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color);">
      <div style="display: flex; justify-content: space-between; font-size: 0.875rem;">
        <span>Queue Length</span>
        <span style="color: var(--warning);">${trainQueue.length} trains</span>
      </div>
    </div>
    <div class="health-countdown" style="margin-top: 8px; text-align: center; font-size: 0.8rem; color: var(--accent-cyan);"></div>
  `;
  
  container.appendChild(trackCard);
  
  if (!activeRecs || activeRecs.length === 0) {
    container.innerHTML += `
      <div class="rec-card" style="text-align: center; color: var(--text-secondary);">
        <i class="fas fa-check-circle" style="font-size: 2rem; color: var(--success); margin-bottom: 1rem;"></i>
        <p>All trains in repair bay are healthy</p>
      </div>
    `;
    return;
  }
  
  // Group recommendations by track
  const recsByTrack = {};
  activeRecs.forEach(rec => {
    const track = trackAssignments.get(rec.train_id);
    if (track) {
      if (!recsByTrack[track]) recsByTrack[track] = [];
      recsByTrack[track].push(rec);
    }
  });
  
  // Show recommendations by track
  Object.entries(recsByTrack).slice(0, 3).forEach(([track, recs]) => {
    const trackRecCard = document.createElement('div');
    trackRecCard.className = 'track-rec-card';
    trackRecCard.innerHTML = `
      <div style="font-weight: 600; margin-bottom: 8px; color: var(--accent-blue);">
        Track ${track} Maintenance
      </div>
    `;
    
    recs.slice(0, 2).forEach((r, idx) => {
      const div = document.createElement('div');
      div.className = `rec-item ${(r.fitness_status||"healthy").toLowerCase()}`;
      
      const urgencyIcon = r.fitness_status === "Critical" ? 
        '<i class="fas fa-exclamation-triangle" style="color: #ef4444;"></i>' :
        '<i class="fas fa-exclamation-circle" style="color: #f59e0b;"></i>';
      
      div.innerHTML = `
        <strong>${urgencyIcon} Train ${r.train_id}</strong>
        <div style="font-size: 0.8rem; opacity: 0.8; margin-top: 4px;">${r.reason}</div>
      `;
      
      div.addEventListener("click", () => showDetailModal(r));
      trackRecCard.appendChild(div);
    });
    
    container.appendChild(trackRecCard);
  });
}

function showDetailModal(obj) {
  const modal = document.getElementById("detail-modal");
  const content = document.getElementById("modal-content");
  const title = document.getElementById("modal-title");
  
  const fitness = (obj.fitness_status || "Healthy").toLowerCase();
  const statusColor = fitness === "critical" ? "#ef4444" : 
                      fitness === "minor" ? "#f59e0b" : "#10b981";
  const track = trackAssignments.get(obj.train_id);
  
  title.innerHTML = `
    <i class="fas fa-train" style="margin-right: 8px;"></i>
    Train ${obj.train_id} ${track ? `(Track ${track})` : ''}
  `;
  
  content.innerHTML = `
    <div style="display: grid; gap: 1rem;">
      <div style="display: flex; align-items: center; gap: 1rem; padding: 1rem; background: rgba(0, 240, 255, 0.05); border-radius: 8px;">
        <div style="width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; background: ${statusColor}20; border-radius: 50%;">
          <i class="fas fa-${fitness === 'critical' ? 'exclamation-triangle' : fitness === 'minor' ? 'exclamation-circle' : 'check-circle'}" style="font-size: 1.5rem; color: ${statusColor};"></i>
        </div>
        <div>
          <div style="font-size: 0.875rem; color: var(--text-secondary);">Current Status</div>
          <div style="font-size: 1.25rem; font-weight: 600; color: ${statusColor}; text-transform: capitalize;">${obj.fitness_status || 'Healthy'}</div>
          ${track ? `<div style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 4px;">Assigned to Track ${track}</div>` : ''}
        </div>
      </div>
      
      <table style="width: 100%; border-collapse: collapse;">
        ${Object.entries(obj).filter(([key]) => !['recentlyHealed', 'exitTimer'].includes(key))
          .map(([key, value]) => {
          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          return `
            <tr style="border-bottom: 1px solid var(--border-color);">
              <td style="padding: 0.75rem; font-weight: 600; color: var(--text-secondary); width: 40%;">
                ${formattedKey}
              </td>
              <td style="padding: 0.75rem; color: var(--text-primary);">
                ${value ?? 'â€”'}
              </td>
            </tr>
          `;
        }).join('')}
      </table>
      
      <div style="display: flex; justify-content: flex-end; gap: 0.75rem; margin-top: 1rem;">
        <button onclick="closeModal()" style="padding: 0.75rem 1.5rem; background: transparent; border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; cursor: pointer;">
          Close
        </button>
      </div>
    </div>
  `;
  
  modal.classList.remove("hidden");
}

function closeModal() {
  document.getElementById("detail-modal").classList.add("hidden");
}

function updateLastUpdateTime() {
  const now = new Date();
  const timeStr = now.toLocaleTimeString('en-US', { 
    hour12: false,
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
  document.getElementById('last-update-time').textContent = timeStr;
}

// Enhanced styles
const enhancedStyles = document.createElement('style');
enhancedStyles.textContent = `
  #yard {
    height: 550px !important;
    position: relative;
    overflow: visible !important;
  }
  
  .train {
    min-width: 100px;
    max-width: 120px;
    padding: 8px;
    position: absolute;
    transform: translate(-50%, -50%);
    transition: left 1.5s ease-out, opacity 1s ease-out;
    cursor: pointer;
  }
  
  .train.exiting {
    animation: exitPulse 1s ease-in-out infinite;
  }
  
  @keyframes exitPulse {
    0%, 100% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.5); }
    50% { box-shadow: 0 0 40px rgba(16, 185, 129, 0.8); }
  }
  
  .train-body {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    position: relative;
  }
  
  .train-lights {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    animation: lightPulse 1s ease-in-out infinite;
  }
  
  .train-lights.critical {
    background: #ef4444;
    box-shadow: 0 0 15px #ef4444;
  }
  
  .train-lights.minor {
    background: #f59e0b;
    box-shadow: 0 0 15px #f59e0b;
  }
  
  .train-lights.healthy {
    background: #10b981;
    box-shadow: 0 0 15px #10b981;
  }
  
  @keyframes lightPulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.6; transform: scale(0.8); }
  }
  
  .track-badge {
    position: absolute;
    top: -10px;
    left: -10px;
    background: linear-gradient(135deg, #3b82f6, #2563eb);
    color: white;
    padding: 2px 6px;
    border-radius: 8px;
    font-size: 0.6rem;
    font-weight: 700;
  }
  
  .queue-badge {
    position: absolute;
    top: -10px;
    right: -10px;
    background: linear-gradient(135deg, #fb923c, #f97316);
    color: white;
    padding: 2px 6px;
    border-radius: 8px;
    font-size: 0.6rem;
    font-weight: 700;
  }
  
  .exit-badge {
    position: absolute;
    bottom: -10px;
    background: linear-gradient(135deg, #10b981, #059669);
    color: white;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.65rem;
    font-weight: 700;
    animation: exitBadgePulse 1s ease-in-out infinite;
  }
  
  @keyframes exitBadgePulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }
  
  .location-badge {
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.65rem;
    font-weight: 600;
    margin-left: 4px;
  }
  
  .location-badge.in-repair {
    background: rgba(59, 130, 246, 0.2);
    color: #3b82f6;
  }
  
  .location-badge.in-queue {
    background: rgba(251, 146, 60, 0.2);
    color: #fb923c;
  }
  
  .location-badge.exiting {
    background: rgba(16, 185, 129, 0.2);
    color: #10b981;
    animation: blink 0.5s ease-in-out infinite;
  }
  
  .track-status-card {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(37, 99, 235, 0.05));
    border: 1px solid rgba(59, 130, 246, 0.3);
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 12px;
  }
  
  .track-status-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid rgba(148, 163, 184, 0.1);
  }
  
  .track-status-item:last-of-type {
    border-bottom: none;
  }
  
  .track-count {
    background: rgba(0, 240, 255, 0.1);
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.8rem;
    font-weight: 600;
  }
  
  .healing-indicator {
    color: #10b981;
    animation: healingRotate 2s linear infinite;
  }
  
  @keyframes healingRotate {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  .track-rec-card {
    background: linear-gradient(135deg, rgba(0, 240, 255, 0.05), transparent);
    border: 1px solid rgba(0, 240, 255, 0.2);
    border-radius: 12px;
    padding: 12px;
    margin-bottom: 8px;
  }
  
  .rec-item {
    padding: 8px;
    margin: 4px 0;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    border-left: 3px solid transparent;
  }
  
  .rec-item.critical {
    border-left-color: #ef4444;
    background: rgba(239, 68, 68, 0.05);
  }
  
  .rec-item.minor {
    border-left-color: #f59e0b;
    background: rgba(245, 158, 11, 0.05);
  }
  
  .rec-item:hover {
    transform: translateX(4px);
    background: rgba(0, 240, 255, 0.1);
  }
  
  @keyframes healWave {
    0% { 
      transform: scaleX(0);
      opacity: 0;
    }
    50% { 
      opacity: 1;
    }
    100% { 
      transform: scaleX(1);
      opacity: 0;
    }
  }
  
  @keyframes trackHeal1 {
    0% { box-shadow: 0 0 20px rgba(16, 185, 129, 0); }
    50% { box-shadow: 0 0 60px rgba(16, 185, 129, 1); transform: translate(-50%, -50%) scale(1.1); }
    100% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.4); transform: translate(-50%, -50%) scale(1); }
  }
  
  @keyframes trackHeal2 {
    0% { box-shadow: 0 0 20px rgba(16, 185, 129, 0); }
    50% { box-shadow: 0 0 60px rgba(16, 185, 129, 1); transform: translate(-50%, -50%) scale(1.1); }
    100% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.4); transform: translate(-50%, -50%) scale(1); }
  }
  
  @keyframes trackHeal3 {
    0% { box-shadow: 0 0 20px rgba(16, 185, 129, 0); }
    50% { box-shadow: 0 0 60px rgba(16, 185, 129, 1); transform: translate(-50%, -50%) scale(1.1); }
    100% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.4); transform: translate(-50%, -50%) scale(1); }
  }
  
  @keyframes trackHeal4 {
    0% { box-shadow: 0 0 20px rgba(16, 185, 129, 0); }
    50% { box-shadow: 0 0 60px rgba(16, 185, 129, 1); transform: translate(-50%, -50%) scale(1.1); }
    100% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.4); transform: translate(-50%, -50%) scale(1); }
  }
  
  @keyframes flowArrow {
    0%, 100% { opacity: 0.2; transform: translateX(0); }
    50% { opacity: 0.8; transform: translateX(15px); }
  }
  
  @keyframes slideInLeft {
    from { transform: translateX(-100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes slideOutLeft {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(-100%); opacity: 0; }
  }
  
  @keyframes slideInRight {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes slideOutRight {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
  }
  
  @keyframes healingPulse {
    0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
    50% { transform: translateX(-50%) scale(1.1); opacity: 1; }
    100% { transform: translateX(-50%) scale(1); opacity: 1; }
  }
  
  @keyframes healingFadeOut {
    from { opacity: 1; transform: translateX(-50%) translateY(0); }
    to { opacity: 0; transform: translateX(-50%) translateY(-20px); }
  }
`;
document.head.appendChild(enhancedStyles);

// Main refresh function
async function refreshAll() {
  try {
    const { statusData, recData } = await fetchAll();
    
    if (isInitialLoad) {
      backendStatusData = [...statusData];
      localStatusData = [...statusData];
      currentRecData = recData;
      isInitialLoad = false;
      
      initializeDepotPositions();
    } else {
      backendStatusData = [...statusData];
      localStatusData = statusData.map(backendTrain => {
        const localTrain = localStatusData.find(t => t.train_id === backendTrain.train_id);
        if (localTrain && healthProcessedTrains.has(backendTrain.train_id)) {
          return {
            ...backendTrain,
            fitness_status: localTrain.fitness_status,
            days_until_next_service: localTrain.days_until_next_service,
            consequence_if_skipped: localTrain.consequence_if_skipped,
            exitTimer: localTrain.exitTimer
          };
        }
        return backendTrain;
      });
      currentRecData = recData;
    }
    
    updateAllVisualizations();
    
    // Render yard
    renderTracksSVG();
    const layer = document.getElementById("trains-layer");
    
    if (layer.children.length === 0) {
      layer.innerHTML = "";
      
      // Create trains in repair bays
      for (let track = 1; track <= 4; track++) {
        const trainsOnTrack = trainsInRepair.get(track) || [];
        trainsOnTrack.forEach((trainId, index) => {
          const train = localStatusData.find(t => t.train_id === trainId);
          if (train) {
            const el = createTrainElement(train, track, false);
            layer.appendChild(el);
          }
        });
      }
      
      // Create queued trains
      trainQueue.forEach((trainId, index) => {
        const train = localStatusData.find(t => t.train_id === trainId);
        if (train) {
          const el = createTrainElement(train, 0, false);
          el.style.left = `${QUEUE_X_START + (index % 2) * 50}px`;
          el.style.top = `${150 + Math.floor(index / 2) * 60}px`;
          el.style.opacity = '0.4';
          layer.appendChild(el);
        }
      });
    } else {
      updateYardTrains();
    }
    
  } catch (err) {
    console.error("Error refreshing:", err);
  }
}

-----------------------------------------script.js 10--------------------------------------------
// Enhanced Control Center Script with Real-time Day Tracking and Variable Healing
const API_BASE = "http://127.0.0.1:5000";
const REFRESH_MS = 8000;
const HEALTH_UPDATE_MS = 30000; // Base cycle time
const EXIT_DELAY_MS = 10000; // 10 seconds before healthy train exits
const MAX_TRAINS_PER_TRACK = 2;

// Time conversion: 3 seconds = 1 day
const SECONDS_PER_DAY = 3;
const DAYS_TO_MINOR = 10; // 10 days = 30 seconds
const DAYS_TO_CRITICAL = 30; // 30 days = 90 seconds

// Variable track delays (in seconds)
const TRACK_DELAYS = {
  1: 1000,  // 1 second
  2: 5000,  // 5 seconds  
  3: 3000,  // 3 seconds
  4: 7000   // 7 seconds
};

// Healing times based on status (in seconds)
const HEALING_TIMES = {
  'critical': 30000,  // 30 seconds for critical
  'minor': 10000,     // 10 seconds for minor
  'healthy': 0        // Already healthy
};

// Track positions
const TRACK_Y = { 1: 120, 2: 220, 3: 320, 4: 420 };

// Zone X positions - reordered
const QUEUE_X_START = 50;  // Queue area (left)
const QUEUE_X_END = 200;
const NEXT_TRAIN_X = 300;  // Next train position (center-left)
const REPAIR_X = 650;      // Active repair position (center-right)
const EXIT_X = 950;        // Exit area (far right)

let healthChart = null;
let currentScale = 1;
let localStatusData = [];
let backendStatusData = [];
let currentRecData = [];

// Track management
let trackAssignments = new Map(); // trainId -> track number
let trainsInRepair = new Map(); // track -> trainId (one per track when healing)
let trainQueue = []; // Trains waiting to enter
let nextTrainSlots = new Map(); // track -> trainId (next in line)
let exitingTrains = new Set(); // Trains that are exiting
let healingTrains = new Map(); // trainId -> {startTime, duration, track}
let trainDaysTracking = new Map(); // trainId -> {lastUpdate, totalDays}
let healthProcessedTrains = new Set();
let isInitialLoad = true;

// Healing system
let healingCycleInProgress = false;
let currentHealingTrack = 1;

// Day tracking system
let dayTrackingInterval = null;

// Initialize on DOM load
document.addEventListener('DOMContentLoaded', () => {
  initializeApp();
  setupEventListeners();
  createParticles();
  animateBackground();
});

async function initializeApp() {
  showLoading();
  await refreshAll();
  setTimeout(() => hideLoading(), 1500);
  
  // Start systems after initial load
  setTimeout(() => {
    startDayTrackingSystem();
    startHealthImprovementSystem();
    startDepotManagementSystem();
  }, 2000);
  
  // Periodic refresh
  refreshInterval = setInterval(() => {
    if (!healingCycleInProgress) {
      refreshAll();
    }
  }, REFRESH_MS);
}

function showLoading() {
  document.getElementById('loading-overlay').classList.remove('hidden');
}

function hideLoading() {
  document.getElementById('loading-overlay').classList.add('hidden');
}

function setupEventListeners() {
  document.getElementById('zoom-in').addEventListener('click', () => {
    currentScale = Math.min(currentScale + 0.1, 1.5);
    document.getElementById('tracks-svg').style.transform = `scale(${currentScale})`;
    document.getElementById('trains-layer').style.transform = `scale(${currentScale})`;
  });
  
  document.getElementById('zoom-out').addEventListener('click', () => {
    currentScale = Math.max(currentScale - 0.1, 0.7);
    document.getElementById('tracks-svg').style.transform = `scale(${currentScale})`;
    document.getElementById('trains-layer').style.transform = `scale(${currentScale})`;
  });
  
  document.getElementById('refresh-yard').addEventListener('click', () => {
    animateRefresh();
    refreshAll();
  });
  
  document.getElementById('modal-close').addEventListener('click', closeModal);
  document.querySelector('.modal-backdrop').addEventListener('click', closeModal);
}

function animateRefresh() {
  const btn = document.getElementById('refresh-yard');
  btn.style.animation = 'spin 0.5s ease';
  setTimeout(() => btn.style.animation = '', 500);
}

// Create floating particles
function createParticles() {
  const container = document.getElementById('particles');
  for (let i = 0; i < 50; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.cssText = `
      position: absolute;
      width: ${Math.random() * 3 + 1}px;
      height: ${Math.random() * 3 + 1}px;
      background: rgba(0, 240, 255, ${Math.random() * 0.5 + 0.2});
      border-radius: 50%;
      left: ${Math.random() * 100}%;
      top: ${Math.random() * 100}%;
      animation: particleFloat ${Math.random() * 20 + 10}s linear infinite;
      animation-delay: ${Math.random() * 5}s;
    `;
    container.appendChild(particle);
  }
}

function animateBackground() {
  let hue = 0;
  setInterval(() => {
    hue = (hue + 1) % 360;
    document.documentElement.style.setProperty('--dynamic-hue', `${hue}deg`);
  }, 100);
}

// Day Tracking System
function startDayTrackingSystem() {
  console.log('Day tracking system started');
  
  // Initialize tracking for all trains
  localStatusData.forEach(train => {
    if (!trainDaysTracking.has(train.train_id)) {
      trainDaysTracking.set(train.train_id, {
        lastUpdate: Date.now(),
        totalDays: train.days_until_next_service || 0,
        statusLastChanged: Date.now()
      });
    }
  });
  
  // Update days every second (1 day = 3 seconds)
  dayTrackingInterval = setInterval(() => {
    updateTrainDays();
  }, 1000);
}

function updateTrainDays() {
  const now = Date.now();
  
  localStatusData.forEach(train => {
    // Skip if train is being healed or exiting
    if (healingTrains.has(train.train_id) || exitingTrains.has(train.train_id)) {
      return;
    }
    
    const tracking = trainDaysTracking.get(train.train_id);
    if (!tracking) return;
    
    // Calculate elapsed time since last update
    const elapsedSeconds = (now - tracking.lastUpdate) / 1000;
    const elapsedDays = elapsedSeconds / SECONDS_PER_DAY;
    
    // Update days
    const newDays = Math.max(0, (tracking.totalDays || 0) - elapsedDays);
    tracking.totalDays = newDays;
    tracking.lastUpdate = now;
    
    // Update train data
    const trainIndex = localStatusData.findIndex(t => t.train_id === train.train_id);
    if (trainIndex !== -1) {
      localStatusData[trainIndex].days_until_next_service = Math.round(newDays);
      
      // Update status based on days remaining
      const previousStatus = train.fitness_status;
      let newStatus = previousStatus;
      
      if (newDays <= 0) {
        newStatus = 'Critical';
      } else if (newDays <= DAYS_TO_MINOR) {
        newStatus = 'Minor';
      } else {
        newStatus = 'Healthy';
      }
      
      if (newStatus !== previousStatus) {
        localStatusData[trainIndex].fitness_status = newStatus;
        console.log(`Train ${train.train_id} status changed: ${previousStatus} â†’ ${newStatus} (${Math.round(newDays)} days left)`);
        
        // Update visual immediately
        updateTrainVisual(train.train_id, newStatus);
      }
    }
  });
  
  // Update displays
  updateAllVisualizations();
}

function updateTrainVisual(trainId, newStatus) {
  const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
  if (trainElement) {
    const fitness = newStatus.toLowerCase();
    trainElement.className = `train ${fitness}`;
    
    // Update lights
    const lights = trainElement.querySelector('.train-lights');
    if (lights) {
      lights.className = `train-lights ${fitness}`;
    }
    
    // Add status change animation
    trainElement.style.animation = `statusChange 0.5s ease-out`;
    setTimeout(() => {
      trainElement.style.animation = '';
    }, 500);
  }
}

// Initialize depot positions
function initializeDepotPositions() {
  trackAssignments.clear();
  trainsInRepair.clear();
  nextTrainSlots.clear();
  trainQueue = [];
  exitingTrains.clear();
  healingTrains.clear();
  
  // Initialize tracks
  for (let track = 1; track <= 4; track++) {
    trainsInRepair.set(track, null);
    nextTrainSlots.set(track, null);
  }
  
  // Assign first 4 trains to tracks (one per track for repair)
  localStatusData.forEach((train, index) => {
    if (index < 4) {
      const track = index + 1;
      trackAssignments.set(train.train_id, track);
      trainsInRepair.set(track, train.train_id);
    } else if (index < 8) {
      // Next 4 trains as "next in line"
      const track = (index - 4) + 1;
      nextTrainSlots.set(track, train.train_id);
      trackAssignments.set(train.train_id, track);
    } else {
      // Rest go to queue
      trainQueue.push(train.train_id);
    }
  });
  
  console.log('Depot initialized:', {
    inRepair: Array.from(trainsInRepair.entries()),
    nextInLine: Array.from(nextTrainSlots.entries()),
    inQueue: trainQueue.length
  });
}

// Depot Management System
function startDepotManagementSystem() {
  console.log('Depot management system started');
  initializeDepotPositions();
  
  // Check for movements periodically
  setInterval(processDepotMovements, 2000);
}

function processDepotMovements() {
  // Process exits
  exitingTrains.forEach(trainId => {
    const trainData = localStatusData.find(t => t.train_id === trainId);
    if (trainData && trainData.exitTimer && Date.now() >= trainData.exitTimer) {
      performTrainExit(trainId);
    }
  });
  
  // Check healing progress
  healingTrains.forEach((healingInfo, trainId) => {
    const elapsed = Date.now() - healingInfo.startTime;
    const progress = Math.min(100, (elapsed / healingInfo.duration) * 100);
    
    // Update healing progress indicator
    updateHealingProgress(trainId, progress);
    
    if (elapsed >= healingInfo.duration) {
      // Healing complete
      completeHealing(trainId, healingInfo.track);
    }
  });
}

function performTrainExit(trainId) {
  console.log(`Train ${trainId} exiting`);
  
  const track = trackAssignments.get(trainId);
  if (!track) return;
  
  const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
  if (trainElement) {
    // Animate exit
    trainElement.style.transition = 'all 2s ease-out';
    trainElement.style.left = `${EXIT_X}px`;
    trainElement.style.opacity = '0';
    
    setTimeout(() => {
      trainElement.remove();
      
      // Clear from data structures
      trainsInRepair.set(track, null);
      trackAssignments.delete(trainId);
      exitingTrains.delete(trainId);
      
      // Move next train to repair position
      moveNextTrainToRepair(track);
      
      showExitNotification(trainId, track);
    }, 2000);
  }
}

function moveNextTrainToRepair(track) {
  const nextTrainId = nextTrainSlots.get(track);
  if (nextTrainId) {
    console.log(`Moving train ${nextTrainId} to repair position on track ${track}`);
    
    // Move to repair position
    trainsInRepair.set(track, nextTrainId);
    nextTrainSlots.set(track, null);
    
    const trainElement = document.querySelector(`.train[data-id="${nextTrainId}"]`);
    if (trainElement) {
      trainElement.style.transition = 'all 1.5s ease-out';
      trainElement.style.left = `${REPAIR_X}px`;
    }
    
    // Fill next slot from queue
    if (trainQueue.length > 0) {
      const queuedTrain = trainQueue.shift();
      performTrainEntry(queuedTrain, track);
    }
  }
}

function performTrainEntry(trainId, track) {
  console.log(`Train ${trainId} entering track ${track} as next`);
  
  const train = localStatusData.find(t => t.train_id === trainId);
  if (!train) return;
  
  // Assign to track's next slot
  trackAssignments.set(trainId, track);
  nextTrainSlots.set(track, trainId);
  
  const y = TRACK_Y[track];
  
  // Create train element
  const trainElement = createTrainElement(train, track, true);
  document.getElementById('trains-layer').appendChild(trainElement);
  
  // Animate to next position
  setTimeout(() => {
    trainElement.style.transition = 'all 1.5s ease-out';
    trainElement.style.left = `${NEXT_TRAIN_X}px`;
    trainElement.style.opacity = '1';
    
    showEntryNotification(trainId, track);
  }, 100);
}

// Sequential Track Healing System with Variable Delays
function startHealthImprovementSystem() {
  console.log('Variable delay healing system started');
  
  // Start healing cycles
  setInterval(() => {
    if (!healingCycleInProgress) {
      startHealingCycle();
    }
  }, HEALTH_UPDATE_MS);
  
  // Update countdown
  updateHealthCountdown();
  setInterval(updateHealthCountdown, 1000);
}

function startHealingCycle() {
  console.log('Starting healing cycle with variable delays');
  healingCycleInProgress = true;
  currentHealingTrack = 1;
  
  // Start with track 1
  processTrackHealing();
}

function processTrackHealing() {
  if (currentHealingTrack > 4) {
    // Cycle complete
    healingCycleInProgress = false;
    console.log('Healing cycle complete');
    return;
  }
  
  console.log(`Processing healing for track ${currentHealingTrack}`);
  
  // Get train in repair position on this track
  const trainId = trainsInRepair.get(currentHealingTrack);
  
  if (trainId) {
    const train = localStatusData.find(t => t.train_id === trainId);
    
    if (train && train.fitness_status !== 'Healthy' && !healingTrains.has(trainId)) {
      // Start healing with duration based on status
      const healingDuration = HEALING_TIMES[train.fitness_status.toLowerCase()] || 10000;
      startTrainHealing(train, currentHealingTrack, healingDuration);
    } else {
      console.log(`No healing needed for train on track ${currentHealingTrack}`);
    }
  }
  
  // Get delay for next track
  const delay = TRACK_DELAYS[currentHealingTrack];
  console.log(`Waiting ${delay/1000}s before track ${currentHealingTrack + 1}`);
  
  // Move to next track after variable delay
  setTimeout(() => {
    currentHealingTrack++;
    processTrackHealing();
  }, delay);
}

function startTrainHealing(train, track, duration) {
  console.log(`Starting ${duration/1000}s healing for ${train.fitness_status} train ${train.train_id} on track ${track}`);
  
  // Record healing start
  healingTrains.set(train.train_id, {
    startTime: Date.now(),
    duration: duration,
    track: track,
    initialStatus: train.fitness_status
  });
  
  // Show healing animation
  showTrackHealingAnimation(track, train.train_id, train.fitness_status);
  
  // Animate train
  const trainElement = document.querySelector(`.train[data-id="${train.train_id}"]`);
  if (trainElement) {
    trainElement.classList.add('healing');
    
    // Add healing progress bar
    const progressBar = document.createElement('div');
    progressBar.className = 'healing-progress';
    progressBar.innerHTML = `
      <div class="progress-bar">
        <div class="progress-fill" style="width: 0%"></div>
      </div>
      <div class="progress-time">${duration/1000}s</div>
    `;
    trainElement.appendChild(progressBar);
  }
}

function updateHealingProgress(trainId, progress) {
  const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
  if (trainElement) {
    const progressFill = trainElement.querySelector('.progress-fill');
    if (progressFill) {
      progressFill.style.width = `${progress}%`;
    }
    
    const healingInfo = healingTrains.get(trainId);
    if (healingInfo) {
      const remaining = Math.ceil((healingInfo.duration - (Date.now() - healingInfo.startTime)) / 1000);
      const progressTime = trainElement.querySelector('.progress-time');
      if (progressTime && remaining > 0) {
        progressTime.textContent = `${remaining}s`;
      }
    }
  }
}

function completeHealing(trainId, track) {
  console.log(`Completed healing for train ${trainId}`);
  
  // Remove from healing
  healingTrains.delete(trainId);
  healthProcessedTrains.add(trainId);
  
  // Update train status
  const trainIndex = localStatusData.findIndex(t => t.train_id === trainId);
  if (trainIndex !== -1) {
    localStatusData[trainIndex] = {
      ...localStatusData[trainIndex],
      fitness_status: 'Healthy',
      days_until_next_service: 40, // Reset to 40 days
      consequence_if_skipped: 'Regular maintenance',
      exitTimer: Date.now() + EXIT_DELAY_MS
    };
    
    // Reset day tracking
    trainDaysTracking.set(trainId, {
      lastUpdate: Date.now(),
      totalDays: 40,
      statusLastChanged: Date.now()
    });
    
    // Mark for exit
    exitingTrains.add(trainId);
    
    // Update visualizations
    updateAllVisualizations();
    
    // Update train visual
    const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
    if (trainElement) {
      trainElement.classList.remove('healing');
      trainElement.className = 'train healthy exiting';
      
      // Remove progress bar
      const progressBar = trainElement.querySelector('.healing-progress');
      if (progressBar) progressBar.remove();
      
      // Add exit badge
      const exitBadge = document.createElement('div');
      exitBadge.className = 'exit-badge';
      exitBadge.innerHTML = `<i class="fas fa-check"></i> Ready`;
      trainElement.appendChild(exitBadge);
    }
  }
  
  showHealingCompleteNotification(trainId, track);
}

function showTrackHealingAnimation(track, trainId, status) {
  const trackY = TRACK_Y[track];
  const color = status === 'Critical' ? 'rgba(239, 68, 68, 0.3)' : 'rgba(245, 158, 11, 0.3)';
  
  const healEffect = document.createElement('div');
  healEffect.className = 'track-heal-effect';
  healEffect.style.cssText = `
    position: fixed;
    left: ${REPAIR_X - 100}px;
    top: ${trackY}px;
    width: 200px;
    height: 60px;
    background: linear-gradient(90deg, transparent, ${color}, transparent);
    border-radius: 30px;
    pointer-events: none;
    z-index: 50;
    animation: healWave 2s ease-out infinite;
  `;
  
  document.getElementById('yard').appendChild(healEffect);
  
  // Remove after healing duration
  const healingInfo = healingTrains.get(trainId);
  if (healingInfo) {
    setTimeout(() => healEffect.remove(), healingInfo.duration);
  }
}

function showHealingCompleteNotification(trainId, track) {
  const notification = document.createElement('div');
  notification.className = 'healing-notification';
  notification.innerHTML = `
    <i class="fas fa-check-circle"></i>
    <span>Track ${track}: Train ${trainId} maintenance completed!</span>
    <div style="font-size: 0.8rem; margin-top: 4px; opacity: 0.8;">Exiting in 10 seconds...</div>
  `;
  notification.style.cssText = `
    position: fixed;
    top: ${80 + (track - 1) * 30}px;
    right: 20px;
    padding: 1rem 2rem;
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.95), rgba(5, 150, 105, 0.95));
    color: white;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(16, 185, 129, 0.4);
    z-index: 1000;
    animation: slideInRight 0.5s ease-out;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'slideOutRight 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

function showExitNotification(trainId, track) {
  const notification = document.createElement('div');
  notification.innerHTML = `
    <i class="fas fa-sign-out-alt"></i>
    Train ${trainId} has left Track ${track}
  `;
  notification.style.cssText = `
    position: fixed;
    bottom: ${20 + (track - 1) * 60}px;
    right: 20px;
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(37, 99, 235, 0.9));
    color: white;
    border-radius: 8px;
    animation: slideInRight 0.5s ease-out;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'slideOutRight 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

function showEntryNotification(trainId, track) {
  const notification = document.createElement('div');
  notification.innerHTML = `
    <i class="fas fa-sign-in-alt"></i>
    Train ${trainId} ready on Track ${track}
  `;
  notification.style.cssText = `
    position: fixed;
    bottom: ${20 + (track - 1) * 60}px;
    left: 20px;
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, rgba(251, 146, 60, 0.9), rgba(249, 115, 22, 0.9));
    color: white;
    border-radius: 8px;
    animation: slideInLeft 0.5s ease-out;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'slideOutLeft 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

function updateHealthCountdown() {
  const timeLeft = Math.ceil((HEALTH_UPDATE_MS - (Date.now() % HEALTH_UPDATE_MS)) / 1000);
  const daysEquivalent = Math.round(timeLeft / SECONDS_PER_DAY);
  
  const countdownElements = document.querySelectorAll('.health-countdown');
  countdownElements.forEach(el => {
    if (healingCycleInProgress) {
      el.innerHTML = `<i class="fas fa-cog fa-spin"></i> Maintenance cycle in progress...`;
    } else {
      el.innerHTML = `Next cycle: ${timeLeft}s (${daysEquivalent} days)`;
    }
  });
}

function updateAllVisualizations() {
  updateSummaryCounts(localStatusData);
  renderStatusTable(localStatusData, currentRecData);
  
  // Filter recommendations
  const allRepairTrains = Array.from(trainsInRepair.values()).filter(id => id !== null);
  const activeRecs = currentRecData.filter(r => {
    const train = localStatusData.find(t => t.train_id === r.train_id);
    return train && 
           train.fitness_status !== 'Healthy' && 
           allRepairTrains.includes(train.train_id);
  });
  renderRecommendations(activeRecs);
  
  updateYardTrains();
}

async function fetchAll() {
  try {
    const [statusRes, recRes] = await Promise.all([
      fetch(`${API_BASE}/api/current_status`),
      fetch(`${API_BASE}/api/recommendation`)
    ]);
    
    if (!statusRes.ok || !recRes.ok) throw new Error("API fetch failed");
    
    const statusData = await statusRes.json();
    const recData = await recRes.json();
    
    return { statusData, recData };
  } catch (error) {
    console.error("Fetch error:", error);
    return { statusData: localStatusData, recData: currentRecData };
  }
}

function renderTracksSVG() {
  const svg = document.getElementById("tracks-svg");
  svg.innerHTML = "";
  
  // Create definitions
  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  
  // Track gradient
  const trackGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
  trackGradient.setAttribute("id", "trackGradient");
  trackGradient.innerHTML = `
    <stop offset="0%" style="stop-color:#1e293b;stop-opacity:0.8" />
    <stop offset="50%" style="stop-color:#334155;stop-opacity:0.6" />
    <stop offset="100%" style="stop-color:#1e293b;stop-opacity:0.8" />
  `;
  defs.appendChild(trackGradient);
  
  svg.appendChild(defs);
  
  // Draw zones
  // Queue zone (left)
  const queueZone = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  queueZone.setAttribute("x", 20);
  queueZone.setAttribute("y", 50);
  queueZone.setAttribute("width", 200);
  queueZone.setAttribute("height", 450);
  queueZone.setAttribute("fill", "rgba(251, 146, 60, 0.03)");
  queueZone.setAttribute("stroke", "rgba(251, 146, 60, 0.2)");
  queueZone.setAttribute("stroke-width", "2");
  queueZone.setAttribute("stroke-dasharray", "5 5");
  queueZone.setAttribute("rx", 10);
  svg.appendChild(queueZone);
  
  // Next zone (center-left)
  const nextZone = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  nextZone.setAttribute("x", 240);
  nextZone.setAttribute("y", 50);
  nextZone.setAttribute("width", 140);
  nextZone.setAttribute("height", 450);
  nextZone.setAttribute("fill", "rgba(251, 191, 36, 0.03)");
  nextZone.setAttribute("stroke", "rgba(251, 191, 36, 0.2)");
  nextZone.setAttribute("stroke-width", "2");
  nextZone.setAttribute("rx", 10);
  svg.appendChild(nextZone);
  
  // Repair zone (center-right)
  const repairZone = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  repairZone.setAttribute("x", 550);
  repairZone.setAttribute("y", 50);
  repairZone.setAttribute("width", 200);
  repairZone.setAttribute("height", 450);
  repairZone.setAttribute("fill", "rgba(0, 240, 255, 0.03)");
  repairZone.setAttribute("stroke", "rgba(0, 240, 255, 0.2)");
  repairZone.setAttribute("stroke-width", "2");
  repairZone.setAttribute("rx", 10);
  svg.appendChild(repairZone);
  
  // Exit zone (far right)
  const exitZone = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  exitZone.setAttribute("x", 870);
  exitZone.setAttribute("y", 50);
  exitZone.setAttribute("width", 110);
  exitZone.setAttribute("height", 450);
  exitZone.setAttribute("fill", "rgba(16, 185, 129, 0.03)");
  exitZone.setAttribute("stroke", "rgba(16, 185, 129, 0.2)");
  exitZone.setAttribute("stroke-width", "2");
  exitZone.setAttribute("stroke-dasharray", "5 5");
  exitZone.setAttribute("rx", 10);
  svg.appendChild(exitZone);
  
  // Zone labels
  const labels = [
    { text: "QUEUE", x: 120, color: "rgba(251, 146, 60, 0.8)" },
    { text: "NEXT", x: 310, color: "rgba(251, 191, 36, 0.8)" },
    { text: "REPAIR BAY", x: 650, color: "rgba(0, 240, 255, 0.8)" },
    { text: "EXIT", x: 925, color: "rgba(16, 185, 129, 0.8)" }
  ];
  
  labels.forEach(label => {
    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", label.x);
    text.setAttribute("y", 35);
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("fill", label.color);
    text.setAttribute("font-size", "12");
    text.setAttribute("font-weight", "600");
    text.textContent = label.text;
    svg.appendChild(text);
  });
  
  // Draw tracks
  for (let t = 1; t <= 4; t++) {
    const y = TRACK_Y[t];
    
    // Track background
    const trackBg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    trackBg.setAttribute("x", 20);
    trackBg.setAttribute("y", y - 25);
    trackBg.setAttribute("width", 960);
    trackBg.setAttribute("height", 50);
    trackBg.setAttribute("fill", "url(#trackGradient)");
    trackBg.setAttribute("rx", 25);
    trackBg.setAttribute("opacity", "0.2");
    svg.appendChild(trackBg);
    
    // Rails
    const rail1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
    rail1.setAttribute("x1", 30);
    rail1.setAttribute("y1", y - 10);
    rail1.setAttribute("x2", 970);
    rail1.setAttribute("y2", y - 10);
    rail1.setAttribute("stroke", "#475569");
    rail1.setAttribute("stroke-width", "2");
    rail1.setAttribute("opacity", "0.5");
    svg.appendChild(rail1);
    
    const rail2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
    rail2.setAttribute("x1", 30);
    rail2.setAttribute("y1", y + 10);
    rail2.setAttribute("x2", 970);
    rail2.setAttribute("y2", y + 10);
    rail2.setAttribute("stroke", "#475569");
    rail2.setAttribute("stroke-width", "2");
    rail2.setAttribute("opacity", "0.5");
    svg.appendChild(rail2);
    
    // Track number with delay indicator
    const trackNum = document.createElementNS("http://www.w3.org/2000/svg", "text");
    trackNum.setAttribute("x", 510);
    trackNum.setAttribute("y", y + 5);
    trackNum.setAttribute("text-anchor", "middle");
    trackNum.setAttribute("fill", "rgba(148, 163, 184, 0.8)");
    trackNum.setAttribute("font-size", "14");
    trackNum.setAttribute("font-weight", "700");
    trackNum.textContent = `T${t} (${TRACK_DELAYS[t]/1000}s)`;
    svg.appendChild(trackNum);
    
    // Flow arrows
    for (let i = 0; i < 4; i++) {
      const arrow = document.createElementNS("http://www.w3.org/2000/svg", "text");
      arrow.setAttribute("x", 400 + i * 120);
      arrow.setAttribute("y", y + 5);
      arrow.setAttribute("fill", "rgba(0, 240, 255, 0.2)");
      arrow.setAttribute("font-size", "16");
      arrow.textContent = "â†’";
      arrow.style.animation = `flowArrow ${2 + t * 0.3}s ease-in-out infinite`;
      arrow.style.animationDelay = `${i * 0.4}s`;
      svg.appendChild(arrow);
    }
  }
}

function createTrainElement(train, track, isEntering = false) {
  const div = document.createElement("div");
  div.className = "train";
  const fitness = (train.fitness_status || "Healthy").toLowerCase();
  div.classList.add(fitness);
  div.dataset.id = train.train_id;
  div.dataset.track = track;
  
  const y = TRACK_Y[track];
  
  // Set initial position
  if (isEntering) {
    div.style.left = `${QUEUE_X_END}px`;
    div.style.top = `${y}px`;
    div.style.opacity = '0.5';
  } else {
    // Check position type
    if (trainsInRepair.get(track) === train.train_id) {
      div.style.left = `${REPAIR_X}px`;
    } else if (nextTrainSlots.get(track) === train.train_id) {
      div.style.left = `${NEXT_TRAIN_X}px`;
    } else {
      const queueIndex = trainQueue.indexOf(train.train_id);
      if (queueIndex >= 0) {
        div.style.left = `${QUEUE_X_START + (queueIndex % 3) * 50}px`;
        div.style.top = `${150 + Math.floor(queueIndex / 3) * 60}px`;
      }
    }
    div.style.top = `${y}px`;
  }
  
  // Days indicator with color
  let daysColor = '#10b981';
  const daysLeft = train.days_until_next_service || 0;
  if (daysLeft <= 0) {
    daysColor = '#ef4444';
  } else if (daysLeft <= DAYS_TO_MINOR) {
    daysColor = '#f59e0b';
  }
  
  // Train body
  div.innerHTML = `
    <div class="train-body">
      <div class="train-lights ${fitness}"></div>
      <div class="train-info">
        <div class="id">${train.train_id}</div>
        <div class="days-indicator" style="color: ${daysColor}; font-weight: 700;">
          ${Math.round(daysLeft)}d
        </div>
      </div>
      <span class="track-badge">T${track}</span>
    </div>
  `;
  
  // Store info
  div.dataset.info = JSON.stringify(train);
  
  // Event handlers
  div.addEventListener('mouseenter', (e) => {
    createHoverParticles(e);
    div.style.zIndex = '10';
  });
  
  div.addEventListener('mouseleave', () => {
    div.style.zIndex = '1';
  });
  
  div.addEventListener('click', (e) => {
    e.stopPropagation();
    showDetailModal(train);
  });
  
  return div;
}

function updateYardTrains() {
  const layer = document.getElementById("trains-layer");
  
  localStatusData.forEach(train => {
    const existingTrain = layer.querySelector(`[data-id="${train.train_id}"]`);
    
    if (existingTrain) {
      const fitness = (train.fitness_status || "Healthy").toLowerCase();
      
      // Update class if not healing
      if (!healingTrains.has(train.train_id)) {
        existingTrain.className = `train ${fitness}`;
        if (exitingTrains.has(train.train_id)) {
          existingTrain.classList.add('exiting');
        }
      }
      
      existingTrain.dataset.info = JSON.stringify(train);
      
      // Update days indicator
      const daysIndicator = existingTrain.querySelector('.days-indicator');
      if (daysIndicator) {
        const daysLeft = train.days_until_next_service || 0;
        let daysColor = '#10b981';
        if (daysLeft <= 0) {
          daysColor = '#ef4444';
        } else if (daysLeft <= DAYS_TO_MINOR) {
          daysColor = '#f59e0b';
        }
        daysIndicator.style.color = daysColor;
        daysIndicator.textContent = `${Math.round(daysLeft)}d`;
      }
      
      // Update lights
      const lights = existingTrain.querySelector('.train-lights');
      if (lights && !healingTrains.has(train.train_id)) {
        lights.className = `train-lights ${fitness}`;
      }
    }
  });
}

function createHoverParticles(e) {
  const train = e.currentTarget;
  const rect = train.getBoundingClientRect();
  
  for (let i = 0; i < 6; i++) {
    const particle = document.createElement('div');
    particle.style.cssText = `
      position: fixed;
      width: 4px;
      height: 4px;
      background: linear-gradient(45deg, #00f0ff, #10b981);
      border-radius: 50%;
      left: ${rect.left + rect.width / 2}px;
      top: ${rect.bottom}px;
      pointer-events: none;
      z-index: 100;
    `;
    document.body.appendChild(particle);
    
    const angle = (Math.PI * 2 * i) / 6;
    const distance = 30 + Math.random() * 20;
    particle.animate([
      { transform: 'translate(0, 0) scale(1)', opacity: 1 },
      { transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`, opacity: 0 }
    ], {
      duration: 800,
      easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
    }).onfinish = () => particle.remove();
  }
}

// UI functions remain mostly the same
function animateStatCounter(element, newValue) {
  const current = parseInt(element.dataset.value) || 0;
  const duration = 1000;
  const start = Date.now();
  
  const animate = () => {
    const elapsed = Date.now() - start;
    const progress = Math.min(elapsed / duration, 1);
    const value = Math.floor(current + (newValue - current) * easeOutQuart(progress));
    
    element.textContent = value;
    
    if (progress < 1) {
      requestAnimationFrame(animate);
    } else {
      element.dataset.value = newValue;
    }
  };
  
  animate();
}

function easeOutQuart(t) {
  return 1 - Math.pow(1 - t, 4);
}

function updateSummaryCounts(statusData) {
  const total = statusData.length;
  const critical = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "critical").length;
  const minor = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "minor").length;
  const healthy = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "healthy").length;
  
  animateStatCounter(document.querySelector('#stat-total .stat-value'), total);
  animateStatCounter(document.querySelector('#stat-critical .stat-value'), critical);
  animateStatCounter(document.querySelector('#stat-minor .stat-value'), minor);
  animateStatCounter(document.querySelector('#stat-healthy .stat-value'), healthy);
  
  updateHealthChart(critical, minor, healthy);
  updateChartCenterLabel(healthy, total);
}

function updateChartCenterLabel(healthy, total) {
  const percentage = total > 0 ? Math.round((healthy / total) * 100) : 0;
  document.querySelector('.chart-percentage').textContent = `${percentage}%`;
}

function updateHealthChart(critical, minor, healthy) {
  const ctx = document.getElementById("healthChart").getContext("2d");
  
  if (healthChart) {
    healthChart.data.datasets[0].data = [critical, minor, healthy];
    healthChart.update('active');
    return;
  }
  
  healthChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: ['Critical', 'Minor Issues', 'Healthy'],
      datasets: [{
        data: [critical, minor, healthy],
        backgroundColor: [
          'rgba(239, 68, 68, 0.8)',
          'rgba(245, 158, 11, 0.8)',
          'rgba(16, 185, 129, 0.8)'
        ],
        borderColor: [
          'rgba(239, 68, 68, 1)',
          'rgba(245, 158, 11, 1)',
          'rgba(16, 185, 129, 1)'
        ],
        borderWidth: 2,
        hoverOffset: 4
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      cutout: '70%',
      plugins: {
        legend: {
          position: 'bottom',
          labels: {
            color: '#94a3b8',
            padding: 15,
            font: { size: 11 }
          }
        }
      },
      animation: {
        animateRotate: true,
        animateScale: true,
        duration: 1500,
        easing: 'easeInOutQuart'
      }
    }
  });
}

function renderStatusTable(statusData, recData) {
  const tbody = document.getElementById("status-body");
  tbody.innerHTML = "";
  
  statusData.forEach((train, idx) => {
    const match = recData.find(r => r.train_id === train.train_id) || {};
    const fitness = (train.fitness_status || "Healthy").toLowerCase();
    const track = trackAssignments.get(train.train_id);
    const isInRepair = Array.from(trainsInRepair.values()).includes(train.train_id);
    const isNext = Array.from(nextTrainSlots.values()).includes(train.train_id);
    const inQueue = trainQueue.includes(train.train_id);
    const isExiting = exitingTrains.has(train.train_id);
    const isHealing = healingTrains.has(train.train_id);
    
    let locationBadge = '';
    if (isHealing) {
      const healingInfo = healingTrains.get(train.train_id);
      const elapsed = Date.now() - healingInfo.startTime;
      const progress = Math.round((elapsed / healingInfo.duration) * 100);
      locationBadge = `<span class="location-badge healing">Repairing ${progress}%</span>`;
    } else if (isExiting) {
      locationBadge = `<span class="location-badge exiting">Exiting T${track}</span>`;
    } else if (isInRepair) {
      locationBadge = `<span class="location-badge in-repair">Repair Bay T${track}</span>`;
    } else if (isNext) {
      locationBadge = `<span class="location-badge next">Next T${track}</span>`;
    } else if (inQueue) {
      const queuePos = trainQueue.indexOf(train.train_id) + 1;
      locationBadge = `<span class="location-badge in-queue">Queue #${queuePos}</span>`;
    }
    
    const daysLeft = train.days_until_next_service || 0;
    let daysColor = '';
    if (daysLeft <= 0) {
      daysColor = 'critical-days';
    } else if (daysLeft <= DAYS_TO_MINOR) {
      daysColor = 'warning-days';
    }
    
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>
        <div style="display: flex; align-items: center; gap: 8px;">
          <i class="fas fa-train" style="color: ${fitness === 'healthy' ? '#10b981' : fitness === 'critical' ? '#ef4444' : '#f59e0b'}; font-size: 12px;"></i>
          ${train.train_id}
          ${locationBadge}
        </div>
      </td>
      <td>${train.yard_position || 'â€”'}</td>
      <td class="${fitness}">
        <span style="display: inline-flex; align-items: center; gap: 6px;">
          <span class="status-dot ${fitness}"></span>
          ${train.fitness_status || 'Healthy'}
        </span>
      </td>
      <td>${train.next_service_due_date || 'â€”'}</td>
      <td>
        <span class="days-badge ${daysColor}">
          <i class="fas fa-calendar-alt" style="font-size: 10px; margin-right: 4px;"></i>
          ${Math.round(daysLeft)} days
        </span>
      </td>
      <td>${match.consequence_if_skipped || train.consequence_if_skipped || 'â€”'}</td>
    `;
    
    tbody.appendChild(tr);
    tr.style.animation = `tableRowSlide 0.3s ease-out ${idx * 0.02}s both`;
  });
  
  updateLastUpdateTime();
}

function renderRecommendations(activeRecs) {
  const container = document.getElementById("recommend-list");
  container.innerHTML = "";
  
  // Healing status card
  const statusCard = document.createElement('div');
  statusCard.className = 'healing-status-card';
  statusCard.innerHTML = `
    <div style="font-weight: 600; margin-bottom: 12px; color: var(--accent-cyan);">
      <i class="fas fa-tools"></i> Track Healing Status
    </div>
  `;
  
  for (let t = 1; t <= 4; t++) {
    const repairTrain = trainsInRepair.get(t);
    const nextTrain = nextTrainSlots.get(t);
    const healingInfo = repairTrain ? healingTrains.get(repairTrain) : null;
    
    const trackDiv = document.createElement('div');
    trackDiv.className = 'track-status-row';
    
    let statusText = 'Empty';
    let statusClass = 'empty';
    
    if (healingInfo) {
      const progress = Math.round(((Date.now() - healingInfo.startTime) / healingInfo.duration) * 100);
      statusText = `<div class="healing-bar"><div class="healing-fill" style="width: ${progress}%"></div></div>`;
      statusClass = 'healing';
    } else if (repairTrain) {
      const train = localStatusData.find(t => t.train_id === repairTrain);
      statusText = `${repairTrain} (${train?.fitness_status || 'Ready'})`;
      statusClass = train?.fitness_status?.toLowerCase() || 'ready';
    }
    
    trackDiv.innerHTML = `
      <div class="track-label">T${t} (${TRACK_DELAYS[t]/1000}s)</div>
      <div class="track-trains">
        <span class="position-indicator ${statusClass}">R: ${statusText}</span>
        <span class="position-indicator next">N: ${nextTrain || 'Empty'}</span>
      </div>
    `;
    statusCard.appendChild(trackDiv);
  }
  
  statusCard.innerHTML += `
    <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color);">
      <div style="display: flex; justify-content: space-between; font-size: 0.875rem;">
        <span>Queue Length</span>
        <span style="color: var(--warning);">${trainQueue.length} trains</span>
      </div>
    </div>
    <div class="health-countdown" style="margin-top: 8px; text-align: center; font-size: 0.8rem; color: var(--accent-cyan);"></div>
  `;
  
  container.appendChild(statusCard);
}

function showDetailModal(obj) {
  const modal = document.getElementById("detail-modal");
  const content = document.getElementById("modal-content");
  const title = document.getElementById("modal-title");
  
  const fitness = (obj.fitness_status || "Healthy").toLowerCase();
  const statusColor = fitness === "critical" ? "#ef4444" : 
                      fitness === "minor" ? "#f59e0b" : "#10b981";
  const track = trackAssignments.get(obj.train_id);
  const daysLeft = obj.days_until_next_service || 0;
  
  title.innerHTML = `
    <i class="fas fa-train" style="margin-right: 8px;"></i>
    Train ${obj.train_id} ${track ? `(Track ${track})` : ''}
  `;
  
  content.innerHTML = `
    <div style="display: grid; gap: 1rem;">
      <div style="display: flex; align-items: center; gap: 1rem; padding: 1rem; background: rgba(0, 240, 255, 0.05); border-radius: 8px;">
        <div style="width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; background: ${statusColor}20; border-radius: 50%;">
          <i class="fas fa-${fitness === 'critical' ? 'exclamation-triangle' : fitness === 'minor' ? 'exclamation-circle' : 'check-circle'}" style="font-size: 1.5rem; color: ${statusColor};"></i>
        </div>
        <div>
          <div style="font-size: 0.875rem; color: var(--text-secondary);">Current Status</div>
          <div style="font-size: 1.25rem; font-weight: 600; color: ${statusColor}; text-transform: capitalize;">${obj.fitness_status || 'Healthy'}</div>
          <div style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 4px;">
            <i class="fas fa-clock"></i> ${Math.round(daysLeft)} days remaining
          </div>
        </div>
      </div>
      
      <table style="width: 100%; border-collapse: collapse;">
        ${Object.entries(obj).filter(([key]) => !['recentlyHealed', 'exitTimer'].includes(key))
          .map(([key, value]) => {
          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          return `
            <tr style="border-bottom: 1px solid var(--border-color);">
              <td style="padding: 0.75rem; font-weight: 600; color: var(--text-secondary); width: 40%;">
                ${formattedKey}
              </td>
              <td style="padding: 0.75rem; color: var(--text-primary);">
                ${value ?? 'â€”'}
              </td>
            </tr>
          `;
        }).join('')}
      </table>
      
      <div style="display: flex; justify-content: flex-end; gap: 0.75rem; margin-top: 1rem;">
        <button onclick="closeModal()" style="padding: 0.75rem 1.5rem; background: transparent; border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; cursor: pointer;">
          Close
        </button>
      </div>
    </div>
  `;
  
  modal.classList.remove("hidden");
}

function closeModal() {
  document.getElementById("detail-modal").classList.add("hidden");
}

function updateLastUpdateTime() {
  const now = new Date();
  const timeStr = now.toLocaleTimeString('en-US', { 
    hour12: false,
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
  document.getElementById('last-update-time').textContent = timeStr;
}

// Enhanced styles
const enhancedStyles = document.createElement('style');
enhancedStyles.textContent = `
  #yard {
    height: 550px !important;
    position: relative;
    overflow: visible !important;
  }
  
  .train {
    min-width: 90px;
    max-width: 110px;
    padding: 6px;
    position: absolute;
    transform: translate(-50%, -50%);
    transition: left 1.5s ease-out, opacity 1s ease-out;
    cursor: pointer;
  }
  
  .train.healing {
    animation: healingPulse 2s ease-in-out infinite;
  }
  
  @keyframes healingPulse {
    0%, 100% { 
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.4);
      transform: translate(-50%, -50%) scale(1);
    }
    50% { 
      box-shadow: 0 0 40px rgba(0, 240, 255, 0.8);
      transform: translate(-50%, -50%) scale(1.05);
    }
  }
  
  .train.exiting {
    animation: exitPulse 1s ease-in-out infinite;
  }
  
  @keyframes exitPulse {
    0%, 100% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.5); }
    50% { box-shadow: 0 0 40px rgba(16, 185, 129, 0.8); }
  }
  
  .train-body {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    position: relative;
  }
  
  .train-lights {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    animation: lightPulse 1s ease-in-out infinite;
  }
  
  .train-lights.critical {
    background: #ef4444;
    box-shadow: 0 0 20px #ef4444;
  }
  
  .train-lights.minor {
    background: #f59e0b;
    box-shadow: 0 0 15px #f59e0b;
  }
  
  .train-lights.healthy {
    background: #10b981;
    box-shadow: 0 0 10px #10b981;
  }
  
  @keyframes lightPulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(0.9); }
  }
  
  .days-indicator {
    font-size: 11px;
    font-weight: 700;
    padding: 2px 4px;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.2);
  }
  
  .track-badge {
    position: absolute;
    top: -8px;
    right: -8px;
    background: linear-gradient(135deg, #3b82f6, #2563eb);
    color: white;
    padding: 1px 5px;
    border-radius: 6px;
    font-size: 0.6rem;
    font-weight: 700;
  }
  
  .healing-progress {
    position: absolute;
    bottom: -25px;
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    background: rgba(0, 0, 0, 0.7);
    padding: 4px;
    border-radius: 4px;
  }
  
  .progress-bar {
    height: 4px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 2px;
    overflow: hidden;
  }
  
  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #00f0ff, #10b981);
    transition: width 0.5s ease;
  }
  
  .progress-time {
    text-align: center;
    font-size: 0.65rem;
    color: #00f0ff;
    margin-top: 2px;
  }
  
  .exit-badge {
    position: absolute;
    bottom: -10px;
    background: linear-gradient(135deg, #10b981, #059669);
    color: white;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.65rem;
    font-weight: 700;
    animation: exitBadgePulse 1s ease-in-out infinite;
  }
  
  @keyframes exitBadgePulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }
  
  .location-badge {
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.65rem;
    font-weight: 600;
    margin-left: 4px;
  }
  
  .location-badge.healing {
    background: linear-gradient(135deg, rgba(0, 240, 255, 0.3), rgba(0, 240, 255, 0.1));
    color: #00f0ff;
    animation: blink 0.5s ease-in-out infinite;
  }
  
  .location-badge.in-repair {
    background: rgba(59, 130, 246, 0.2);
    color: #3b82f6;
  }
  
  .location-badge.next {
    background: rgba(251, 191, 36, 0.2);
    color: #fbbf24;
  }
  
  .location-badge.in-queue {
    background: rgba(251, 146, 60, 0.2);
    color: #fb923c;
  }
  
  .location-badge.exiting {
    background: rgba(16, 185, 129, 0.2);
    color: #10b981;
    animation: blink 0.5s ease-in-out infinite;
  }
  
  .days-badge {
    display: inline-flex;
    align-items: center;
    padding: 3px 8px;
    background: rgba(148, 163, 184, 0.1);
    border-radius: 12px;
    font-size: 0.8rem;
    font-weight: 600;
  }
  
  .days-badge.warning-days {
    background: rgba(245, 158, 11, 0.2);
    color: #fbbf24;
  }
  
  .days-badge.critical-days {
    background: rgba(239, 68, 68, 0.2);
    color: #fca5a5;
    animation: urgentPulse 1s ease-in-out infinite;
  }
  
  @keyframes urgentPulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
    50% { box-shadow: 0 0 10px 2px rgba(239, 68, 68, 0.3); }
  }
  
  .healing-status-card {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(37, 99, 235, 0.05));
    border: 1px solid rgba(59, 130, 246, 0.3);
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 12px;
  }
  
  .track-status-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid rgba(148, 163, 184, 0.1);
  }
  
  .track-label {
    font-weight: 600;
    color: var(--accent-cyan);
    min-width: 80px;
  }
  
  .track-trains {
    display: flex;
    gap: 12px;
    flex: 1;
  }
  
  .position-indicator {
    font-size: 0.75rem;
    padding: 2px 6px;
    border-radius: 6px;
    background: rgba(148, 163, 184, 0.1);
  }
  
  .position-indicator.critical {
    background: rgba(239, 68, 68, 0.2);
    color: #ef4444;
  }
  
  .position-indicator.minor {
    background: rgba(245, 158, 11, 0.2);
    color: #f59e0b;
  }
  
  .position-indicator.healing {
    background: rgba(0, 240, 255, 0.1);
    color: #00f0ff;
  }
  
  .position-indicator.next {
    background: rgba(251, 191, 36, 0.1);
    color: #fbbf24;
  }
  
  .healing-bar {
    width: 80px;
    height: 6px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
    overflow: hidden;
    display: inline-block;
  }
  
  .healing-fill {
    height: 100%;
    background: linear-gradient(90deg, #00f0ff, #10b981);
    transition: width 0.5s ease;
  }
  
  @keyframes statusChange {
    0% { transform: translate(-50%, -50%) scale(1.2); }
    100% { transform: translate(-50%, -50%) scale(1); }
  }
  
  @keyframes healWave {
    0% { 
      transform: scaleX(0);
      opacity: 0;
    }
    50% { 
      opacity: 1;
    }
    100% { 
      transform: scaleX(1);
      opacity: 0;
    }
  }
  
  @keyframes flowArrow {
    0%, 100% { opacity: 0.2; transform: translateX(0); }
    50% { opacity: 0.6; transform: translateX(10px); }
  }
  
  @keyframes slideInLeft {
    from { transform: translateX(-100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes slideOutLeft {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(-100%); opacity: 0; }
  }
  
  @keyframes slideInRight {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes slideOutRight {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
  }
  
  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }
`;
document.head.appendChild(enhancedStyles);

// Main refresh function
async function refreshAll() {
  try {
    const { statusData, recData } = await fetchAll();
    
    if (isInitialLoad) {
      backendStatusData = [...statusData];
      localStatusData = [...statusData];
      currentRecData = recData;
      isInitialLoad = false;
      
      initializeDepotPositions();
    } else {
      backendStatusData = [...statusData];
      localStatusData = statusData.map(backendTrain => {
        const localTrain = localStatusData.find(t => t.train_id === backendTrain.train_id);
        if (localTrain && (healthProcessedTrains.has(backendTrain.train_id) || healingTrains.has(backendTrain.train_id))) {
          return {
            ...backendTrain,
            fitness_status: localTrain.fitness_status,
            days_until_next_service: localTrain.days_until_next_service,
            consequence_if_skipped: localTrain.consequence_if_skipped,
            exitTimer: localTrain.exitTimer
          };
        }
        return backendTrain;
      });
      currentRecData = recData;
    }
    
    updateAllVisualizations();
    
    // Render yard
    renderTracksSVG();
    const layer = document.getElementById("trains-layer");
    
    if (layer.children.length === 0) {
      layer.innerHTML = "";
      
      // Create all trains
      localStatusData.forEach(train => {
        const track = trackAssignments.get(train.train_id) || 0;
        const el = createTrainElement(train, track, false);
        if (el) layer.appendChild(el);
      });
    } else {
      updateYardTrains();
    }
    
  } catch (err) {
    console.error("Error refreshing:", err);
  }
}
-------------------------------------------script.js 11----------------------------------------
// Enhanced Control Center Script with Fixed Layout and Re-entry System
const API_BASE = "http://127.0.0.1:5000";
const REFRESH_MS = 8000;
const HEALTH_UPDATE_MS = 30000; // Base cycle time
const EXIT_DELAY_MS = 10000; // 10 seconds before healthy train exits
const MAX_TRAINS_PER_TRACK = 1; // Only 1 train in repair at a time

// Time conversion: 3 seconds = 1 day = 24 hours
const SECONDS_PER_DAY = 3;
const HOURS_PER_SECOND = 8; // 1 real second = 8 simulation hours
const DAYS_TO_MINOR = 10; // 10 days = 30 seconds
const DAYS_TO_CRITICAL = 30; // 30 days = 90 seconds

// Variable track delays (in milliseconds)
const TRACK_DELAYS = {
  1: 1000,  // 1 second
  2: 5000,  // 5 seconds  
  3: 3000,  // 3 seconds
  4: 7000   // 7 seconds
};

// Healing times based on status (in seconds)
const HEALING_TIMES = {
  'critical': 30000,  // 30 seconds = 10 days = 240 hours
  'minor': 10000,     // 10 seconds = 3.3 days = 80 hours
  'healthy': 0        // Already healthy
};

// Track positions (adjusted for better alignment)
const TRACK_Y = { 1: 100, 2: 200, 3: 300, 4: 400 };

// Zone X positions (properly spaced)
const QUEUE_X_START = 60;   // Queue area start
const QUEUE_X_END = 160;    // Queue area end
const NEXT_TRAIN_X = 300;   // Next train position
const REPAIR_X = 550;       // Active repair position
const EXIT_X = 850;         // Exit area

let healthChart = null;
let currentScale = 1;
let localStatusData = [];
let backendStatusData = [];
let currentRecData = [];

// Track management
let trackAssignments = new Map(); // trainId -> track number
let trainsInRepair = new Map(); // track -> trainId (strictly one per track)
let trainQueue = []; // Trains waiting to enter
let nextTrainSlots = new Map(); // track -> trainId (next in line)
let exitingTrains = new Set(); // Trains that are exiting
let healingTrains = new Map(); // trainId -> {startTime, duration, track}
let trainDaysTracking = new Map(); // trainId -> {lastUpdate, totalDays}
let reEntryQueue = []; // Trains that need to re-enter after days expire
let isInitialLoad = true;

// Healing system
let healingCycleInProgress = false;
let currentHealingTrack = 1;

// Day tracking system
let dayTrackingInterval = null;

// Initialize on DOM load
document.addEventListener('DOMContentLoaded', () => {
  initializeApp();
  setupEventListeners();
  createParticles();
  animateBackground();
});

async function initializeApp() {
  showLoading();
  await refreshAll();
  setTimeout(() => hideLoading(), 1500);
  
  // Start systems after initial load
  setTimeout(() => {
    startDayTrackingSystem();
    startHealthImprovementSystem();
    startDepotManagementSystem();
  }, 2000);
  
  // Periodic refresh
  refreshInterval = setInterval(() => {
    if (!healingCycleInProgress) {
      refreshAll();
    }
  }, REFRESH_MS);
}

function showLoading() {
  document.getElementById('loading-overlay').classList.remove('hidden');
}

function hideLoading() {
  document.getElementById('loading-overlay').classList.add('hidden');
}

function setupEventListeners() {
  document.getElementById('zoom-in').addEventListener('click', () => {
    currentScale = Math.min(currentScale + 0.1, 1.5);
    updateYardScale();
  });
  
  document.getElementById('zoom-out').addEventListener('click', () => {
    currentScale = Math.max(currentScale - 0.1, 0.7);
    updateYardScale();
  });
  
  document.getElementById('refresh-yard').addEventListener('click', () => {
    animateRefresh();
    refreshAll();
  });
  
  document.getElementById('modal-close').addEventListener('click', closeModal);
  document.querySelector('.modal-backdrop').addEventListener('click', closeModal);
}

function updateYardScale() {
  const svg = document.getElementById('tracks-svg');
  const layer = document.getElementById('trains-layer');
  svg.style.transform = `scale(${currentScale})`;
  layer.style.transform = `scale(${currentScale})`;
  svg.style.transformOrigin = 'center center';
  layer.style.transformOrigin = 'center center';
}

function animateRefresh() {
  const btn = document.getElementById('refresh-yard');
  btn.style.animation = 'spin 0.5s ease';
  setTimeout(() => btn.style.animation = '', 500);
}

// Create floating particles
function createParticles() {
  const container = document.getElementById('particles');
  for (let i = 0; i < 50; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.cssText = `
      position: absolute;
      width: ${Math.random() * 3 + 1}px;
      height: ${Math.random() * 3 + 1}px;
      background: rgba(0, 240, 255, ${Math.random() * 0.5 + 0.2});
      border-radius: 50%;
      left: ${Math.random() * 100}%;
      top: ${Math.random() * 100}%;
      animation: particleFloat ${Math.random() * 20 + 10}s linear infinite;
      animation-delay: ${Math.random() * 5}s;
    `;
    container.appendChild(particle);
  }
}

function animateBackground() {
  let hue = 0;
  setInterval(() => {
    hue = (hue + 1) % 360;
    document.documentElement.style.setProperty('--dynamic-hue', `${hue}deg`);
  }, 100);
}

// Day Tracking System with Re-entry
function startDayTrackingSystem() {
  console.log('Day tracking system with re-entry started');
  
  // Initialize tracking for all trains
  localStatusData.forEach(train => {
    if (!trainDaysTracking.has(train.train_id)) {
      trainDaysTracking.set(train.train_id, {
        lastUpdate: Date.now(),
        totalDays: train.days_until_next_service || 30,
        statusLastChanged: Date.now(),
        cycleCount: 0
      });
    }
  });
  
  // Update days every second
  dayTrackingInterval = setInterval(() => {
    updateTrainDays();
    checkForReEntry();
  }, 1000);
}

function updateTrainDays() {
  const now = Date.now();
  
  localStatusData.forEach(train => {
    // Skip if train is being healed
    if (healingTrains.has(train.train_id)) {
      return;
    }
    
    const tracking = trainDaysTracking.get(train.train_id);
    if (!tracking) return;
    
    // Only count down days if not in repair
    const inRepair = Array.from(trainsInRepair.values()).includes(train.train_id);
    if (inRepair) return;
    
    // Calculate elapsed time since last update
    const elapsedSeconds = (now - tracking.lastUpdate) / 1000;
    const elapsedDays = elapsedSeconds / SECONDS_PER_DAY;
    
    // Update days
    const newDays = Math.max(0, (tracking.totalDays || 0) - elapsedDays);
    tracking.totalDays = newDays;
    tracking.lastUpdate = now;
    
    // Update train data
    const trainIndex = localStatusData.findIndex(t => t.train_id === train.train_id);
    if (trainIndex !== -1) {
      localStatusData[trainIndex].days_until_next_service = Math.round(newDays);
      
      // Update status based on days remaining
      const previousStatus = train.fitness_status;
      let newStatus = previousStatus;
      
      if (newDays <= 0) {
        newStatus = 'Critical';
        // Add to re-entry queue if not already there
        if (!reEntryQueue.includes(train.train_id) && !inRepair) {
          console.log(`Train ${train.train_id} needs re-entry (0 days left)`);
          reEntryQueue.push(train.train_id);
        }
      } else if (newDays <= DAYS_TO_MINOR) {
        newStatus = 'Minor';
      } else {
        newStatus = 'Healthy';
      }
      
      if (newStatus !== previousStatus) {
        localStatusData[trainIndex].fitness_status = newStatus;
        console.log(`Train ${train.train_id} status changed: ${previousStatus} â†’ ${newStatus} (${Math.round(newDays)} days left)`);
        updateTrainVisual(train.train_id, newStatus);
      }
    }
  });
  
  updateAllVisualizations();
}

function checkForReEntry() {
  // Process re-entry queue
  if (reEntryQueue.length > 0) {
    // Try to add trains back to main queue
    while (reEntryQueue.length > 0) {
      const trainId = reEntryQueue.shift();
      
      // Only re-queue if not already in queue or repair
      if (!trainQueue.includes(trainId) && 
          !Array.from(trainsInRepair.values()).includes(trainId) &&
          !Array.from(nextTrainSlots.values()).includes(trainId)) {
        
        console.log(`Re-queuing train ${trainId} for maintenance`);
        trainQueue.push(trainId);
        
        // Update train status to critical
        const trainIndex = localStatusData.findIndex(t => t.train_id === trainId);
        if (trainIndex !== -1) {
          localStatusData[trainIndex].fitness_status = 'Critical';
          localStatusData[trainIndex].days_until_next_service = 0;
        }
      }
    }
  }
}

function updateTrainVisual(trainId, newStatus) {
  const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
  if (trainElement) {
    const fitness = newStatus.toLowerCase();
    trainElement.className = `train ${fitness}`;
    
    // Update lights
    const lights = trainElement.querySelector('.train-lights');
    if (lights) {
      lights.className = `train-lights ${fitness}`;
    }
    
    // Add status change animation
    trainElement.style.animation = `statusChange 0.5s ease-out`;
    setTimeout(() => {
      trainElement.style.animation = '';
    }, 500);
  }
}

// Initialize depot positions
function initializeDepotPositions() {
  trackAssignments.clear();
  trainsInRepair.clear();
  nextTrainSlots.clear();
  trainQueue = [];
  exitingTrains.clear();
  healingTrains.clear();
  reEntryQueue = [];
  
  // Initialize tracks (empty initially)
  for (let track = 1; track <= 4; track++) {
    trainsInRepair.set(track, null);
    nextTrainSlots.set(track, null);
  }
  
  // Assign trains to positions
  localStatusData.forEach((train, index) => {
    if (index < 4) {
      // First 4 trains go to repair positions
      const track = index + 1;
      trackAssignments.set(train.train_id, track);
      trainsInRepair.set(track, train.train_id);
    } else if (index < 8) {
      // Next 4 trains as "next in line"
      const track = (index - 4) + 1;
      trackAssignments.set(train.train_id, track);
      nextTrainSlots.set(track, train.train_id);
    } else {
      // Rest go to queue
      trainQueue.push(train.train_id);
    }
  });
  
  console.log('Depot initialized:', {
    inRepair: Array.from(trainsInRepair.entries()),
    nextInLine: Array.from(nextTrainSlots.entries()),
    inQueue: trainQueue.length
  });
}

// Depot Management System
function startDepotManagementSystem() {
  console.log('Depot management system started');
  initializeDepotPositions();
  
  // Check for movements periodically
  setInterval(processDepotMovements, 2000);
}

function processDepotMovements() {
  // Process exits
  exitingTrains.forEach(trainId => {
    const trainData = localStatusData.find(t => t.train_id === trainId);
    if (trainData && trainData.exitTimer && Date.now() >= trainData.exitTimer) {
      performTrainExit(trainId);
    }
  });
  
  // Check healing progress
  healingTrains.forEach((healingInfo, trainId) => {
    const elapsed = Date.now() - healingInfo.startTime;
    const progress = Math.min(100, (elapsed / healingInfo.duration) * 100);
    
    updateHealingProgress(trainId, progress, healingInfo.duration - elapsed);
    
    if (elapsed >= healingInfo.duration) {
      completeHealing(trainId, healingInfo.track);
    }
  });
  
  // Ensure only one train per repair position
  for (let track = 1; track <= 4; track++) {
    const currentRepair = trainsInRepair.get(track);
    if (!currentRepair && !healingTrains.has(currentRepair)) {
      // Position is empty, move next train if available
      const nextTrain = nextTrainSlots.get(track);
      if (nextTrain) {
        moveNextTrainToRepair(track);
      }
    }
  }
}

function performTrainExit(trainId) {
  console.log(`Train ${trainId} exiting`);
  
  const track = trackAssignments.get(trainId);
  if (!track) return;
  
  const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
  if (trainElement) {
    // Animate exit
    trainElement.style.transition = 'all 2s ease-out';
    trainElement.style.left = `${EXIT_X}px`;
    trainElement.style.opacity = '0';
    
    setTimeout(() => {
      trainElement.remove();
      
      // Clear from repair position
      if (trainsInRepair.get(track) === trainId) {
        trainsInRepair.set(track, null);
      }
      
      trackAssignments.delete(trainId);
      exitingTrains.delete(trainId);
      
      // Move next train to repair position
      moveNextTrainToRepair(track);
      
      showExitNotification(trainId, track);
      
      // Start day countdown again for this train
      const tracking = trainDaysTracking.get(trainId);
      if (tracking) {
        tracking.cycleCount++;
        console.log(`Train ${trainId} completed cycle ${tracking.cycleCount}`);
      }
    }, 2000);
  }
}

function moveNextTrainToRepair(track) {
  // Ensure repair position is empty
  if (trainsInRepair.get(track)) {
    console.log(`Track ${track} repair position is occupied`);
    return;
  }
  
  const nextTrainId = nextTrainSlots.get(track);
  if (nextTrainId) {
    console.log(`Moving train ${nextTrainId} to repair position on track ${track}`);
    
    // Move to repair position
    trainsInRepair.set(track, nextTrainId);
    nextTrainSlots.set(track, null);
    
    const trainElement = document.querySelector(`.train[data-id="${nextTrainId}"]`);
    if (trainElement) {
      trainElement.style.transition = 'all 1.5s ease-out';
      trainElement.style.left = `${REPAIR_X}px`;
      trainElement.style.top = `${TRACK_Y[track]}px`;
    }
    
    // Fill next slot from queue
    if (trainQueue.length > 0) {
      const queuedTrain = trainQueue.shift();
      performTrainEntry(queuedTrain, track);
    }
  }
}

function performTrainEntry(trainId, track) {
  console.log(`Train ${trainId} entering track ${track} as next`);
  
  const train = localStatusData.find(t => t.train_id === trainId);
  if (!train) return;
  
  // Ensure next slot is empty
  if (nextTrainSlots.get(track)) {
    console.log(`Track ${track} next position is occupied`);
    trainQueue.unshift(trainId); // Put back in queue
    return;
  }
  
  // Assign to track's next slot
  trackAssignments.set(trainId, track);
  nextTrainSlots.set(track, trainId);
  
  const y = TRACK_Y[track];
  
  // Check if element exists
  let trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
  
  if (!trainElement) {
    // Create new element
    trainElement = createTrainElement(train, track, true);
    document.getElementById('trains-layer').appendChild(trainElement);
  }
  
  // Animate to next position
  setTimeout(() => {
    trainElement.style.transition = 'all 1.5s ease-out';
    trainElement.style.left = `${NEXT_TRAIN_X}px`;
    trainElement.style.top = `${y}px`;
    trainElement.style.opacity = '1';
    
    showEntryNotification(trainId, track);
  }, 100);
}

// Sequential Track Healing System with Variable Delays
function startHealthImprovementSystem() {
  console.log('Variable delay healing system started');
  
  // Start healing cycles
  setInterval(() => {
    if (!healingCycleInProgress) {
      startHealingCycle();
    }
  }, HEALTH_UPDATE_MS);
  
  // Update countdown
  updateHealthCountdown();
  setInterval(updateHealthCountdown, 1000);
}

function startHealingCycle() {
  console.log('Starting healing cycle with variable delays');
  healingCycleInProgress = true;
  currentHealingTrack = 1;
  
  processTrackHealing();
}

function processTrackHealing() {
  if (currentHealingTrack > 4) {
    healingCycleInProgress = false;
    console.log('Healing cycle complete');
    return;
  }
  
  console.log(`Processing healing for track ${currentHealingTrack}`);
  
  const trainId = trainsInRepair.get(currentHealingTrack);
  
  if (trainId && !healingTrains.has(trainId)) {
    const train = localStatusData.find(t => t.train_id === trainId);
    
    if (train && train.fitness_status !== 'Healthy') {
      const healingDuration = HEALING_TIMES[train.fitness_status.toLowerCase()] || 10000;
      startTrainHealing(train, currentHealingTrack, healingDuration);
    }
  }
  
  const delay = TRACK_DELAYS[currentHealingTrack];
  console.log(`Waiting ${delay/1000}s before track ${currentHealingTrack + 1}`);
  
  setTimeout(() => {
    currentHealingTrack++;
    processTrackHealing();
  }, delay);
}

function startTrainHealing(train, track, duration) {
  const healingHours = Math.round((duration / 1000) * HOURS_PER_SECOND);
  console.log(`Starting ${healingHours} hours healing for ${train.fitness_status} train ${train.train_id} on track ${track}`);
  
  healingTrains.set(train.train_id, {
    startTime: Date.now(),
    duration: duration,
    track: track,
    initialStatus: train.fitness_status
  });
  
  showTrackHealingAnimation(track, train.train_id, train.fitness_status);
  
  const trainElement = document.querySelector(`.train[data-id="${train.train_id}"]`);
  if (trainElement) {
    trainElement.classList.add('healing');
    
    // Add healing progress bar
    const progressBar = document.createElement('div');
    progressBar.className = 'healing-progress';
    progressBar.innerHTML = `
      <div class="progress-bar">
        <div class="progress-fill" style="width: 0%"></div>
      </div>
      <div class="progress-time">${healingHours}h</div>
    `;
    trainElement.appendChild(progressBar);
  }
}

function updateHealingProgress(trainId, progress, remainingMs) {
  const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
  if (trainElement) {
    const progressFill = trainElement.querySelector('.progress-fill');
    if (progressFill) {
      progressFill.style.width = `${progress}%`;
    }
    
    // Convert remaining time to hours
    const remainingHours = Math.ceil((remainingMs / 1000) * HOURS_PER_SECOND);
    const progressTime = trainElement.querySelector('.progress-time');
    if (progressTime && remainingMs > 0) {
      progressTime.textContent = `${remainingHours}h`;
    }
  }
}

function completeHealing(trainId, track) {
  console.log(`Completed healing for train ${trainId}`);
  
  healingTrains.delete(trainId);
  
  const trainIndex = localStatusData.findIndex(t => t.train_id === trainId);
  if (trainIndex !== -1) {
    localStatusData[trainIndex] = {
      ...localStatusData[trainIndex],
      fitness_status: 'Healthy',
      days_until_next_service: 40,
      consequence_if_skipped: 'Regular maintenance',
      exitTimer: Date.now() + EXIT_DELAY_MS
    };
    
    trainDaysTracking.set(trainId, {
      lastUpdate: Date.now(),
      totalDays: 40,
      statusLastChanged: Date.now(),
      cycleCount: (trainDaysTracking.get(trainId)?.cycleCount || 0)
    });
    
    exitingTrains.add(trainId);
    
    updateAllVisualizations();
    
    const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
    if (trainElement) {
      trainElement.classList.remove('healing');
      trainElement.className = 'train healthy exiting';
      
      const progressBar = trainElement.querySelector('.healing-progress');
      if (progressBar) progressBar.remove();
      
      const exitBadge = document.createElement('div');
      exitBadge.className = 'exit-badge';
      exitBadge.innerHTML = `<i class="fas fa-check"></i> Ready`;
      trainElement.appendChild(exitBadge);
    }
  }
  
  showHealingCompleteNotification(trainId, track);
}

function showTrackHealingAnimation(track, trainId, status) {
  const trainElement = document.querySelector(`.train[data-id="${trainId}"]`);
  if (!trainElement) return;
  
  const rect = trainElement.getBoundingClientRect();
  const color = status === 'Critical' ? 'rgba(239, 68, 68, 0.3)' : 'rgba(245, 158, 11, 0.3)';
  
  const healEffect = document.createElement('div');
  healEffect.className = 'track-heal-effect';
  healEffect.style.cssText = `
    position: fixed;
    left: ${rect.left - 50}px;
    top: ${rect.top - 10}px;
    width: ${rect.width + 100}px;
    height: ${rect.height + 20}px;
    background: radial-gradient(ellipse at center, ${color}, transparent);
    border-radius: 50%;
    pointer-events: none;
    z-index: 50;
    animation: healWave 2s ease-out infinite;
  `;
  
  document.body.appendChild(healEffect);
  
  const healingInfo = healingTrains.get(trainId);
  if (healingInfo) {
    setTimeout(() => healEffect.remove(), healingInfo.duration);
  }
}

function showHealingCompleteNotification(trainId, track) {
  const notification = document.createElement('div');
  notification.className = 'healing-notification';
  notification.innerHTML = `
    <i class="fas fa-check-circle"></i>
    <span>Track ${track}: Train ${trainId} maintenance completed!</span>
    <div style="font-size: 0.8rem; margin-top: 4px; opacity: 0.8;">Exiting in 10 seconds...</div>
  `;
  notification.style.cssText = `
    position: fixed;
    top: ${80 + (track - 1) * 30}px;
    right: 20px;
    padding: 1rem 2rem;
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.95), rgba(5, 150, 105, 0.95));
    color: white;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(16, 185, 129, 0.4);
    z-index: 1000;
    animation: slideInRight 0.5s ease-out;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'slideOutRight 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

function showExitNotification(trainId, track) {
  const notification = document.createElement('div');
  notification.innerHTML = `
    <i class="fas fa-sign-out-alt"></i>
    Train ${trainId} has left Track ${track}
  `;
  notification.style.cssText = `
    position: fixed;
    bottom: ${20 + (track - 1) * 60}px;
    right: 20px;
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(37, 99, 235, 0.9));
    color: white;
    border-radius: 8px;
    animation: slideInRight 0.5s ease-out;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'slideOutRight 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

function showEntryNotification(trainId, track) {
  const notification = document.createElement('div');
  notification.innerHTML = `
    <i class="fas fa-sign-in-alt"></i>
    Train ${trainId} ready on Track ${track}
  `;
  notification.style.cssText = `
    position: fixed;
    bottom: ${20 + (track - 1) * 60}px;
    left: 20px;
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, rgba(251, 146, 60, 0.9), rgba(249, 115, 22, 0.9));
    color: white;
    border-radius: 8px;
    animation: slideInLeft 0.5s ease-out;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'slideOutLeft 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

function updateHealthCountdown() {
  const timeLeft = Math.ceil((HEALTH_UPDATE_MS - (Date.now() % HEALTH_UPDATE_MS)) / 1000);
  const hoursEquivalent = Math.round(timeLeft * HOURS_PER_SECOND);
  
  const countdownElements = document.querySelectorAll('.health-countdown');
  countdownElements.forEach(el => {
    if (healingCycleInProgress) {
      el.innerHTML = `<i class="fas fa-cog fa-spin"></i> Maintenance cycle in progress...`;
    } else {
      el.innerHTML = `Next cycle: ${timeLeft}s (${hoursEquivalent} hours)`;
    }
  });
}

function updateAllVisualizations() {
  updateSummaryCounts(localStatusData);
  renderStatusTable(localStatusData, currentRecData);
  
  const allRepairTrains = Array.from(trainsInRepair.values()).filter(id => id !== null);
  const activeRecs = currentRecData.filter(r => {
    const train = localStatusData.find(t => t.train_id === r.train_id);
    return train && 
           train.fitness_status !== 'Healthy' && 
           allRepairTrains.includes(train.train_id);
  });
  renderRecommendations(activeRecs);
  
  updateYardTrains();
}

async function fetchAll() {
  try {
    const [statusRes, recRes] = await Promise.all([
      fetch(`${API_BASE}/api/current_status`),
      fetch(`${API_BASE}/api/recommendation`)
    ]);
    
    if (!statusRes.ok || !recRes.ok) throw new Error("API fetch failed");
    
    const statusData = await statusRes.json();
    const recData = await recRes.json();
    
    return { statusData, recData };
  } catch (error) {
    console.error("Fetch error:", error);
    return { statusData: localStatusData, recData: currentRecData };
  }
}

function renderTracksSVG() {
  const svg = document.getElementById("tracks-svg");
  svg.innerHTML = "";
  svg.setAttribute("viewBox", "0 0 1000 500");
  
  // Create definitions
  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  
  const trackGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
  trackGradient.setAttribute("id", "trackGradient");
  trackGradient.innerHTML = `
    <stop offset="0%" style="stop-color:#1e293b;stop-opacity:0.8" />
    <stop offset="50%" style="stop-color:#334155;stop-opacity:0.6" />
    <stop offset="100%" style="stop-color:#1e293b;stop-opacity:0.8" />
  `;
  defs.appendChild(trackGradient);
  
  svg.appendChild(defs);
  
  // Draw zones with proper positioning
  // Queue zone (left)
  const queueZone = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  queueZone.setAttribute("x", 20);
  queueZone.setAttribute("y", 60);
  queueZone.setAttribute("width", 180);
  queueZone.setAttribute("height", 380);
  queueZone.setAttribute("fill", "rgba(251, 146, 60, 0.03)");
  queueZone.setAttribute("stroke", "rgba(251, 146, 60, 0.2)");
  queueZone.setAttribute("stroke-width", "2");
  queueZone.setAttribute("stroke-dasharray", "5 5");
  queueZone.setAttribute("rx", 10);
  svg.appendChild(queueZone);
  
  // Next zone
  const nextZone = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  nextZone.setAttribute("x", 220);
  nextZone.setAttribute("y", 60);
  nextZone.setAttribute("width", 160);
  nextZone.setAttribute("height", 380);
  nextZone.setAttribute("fill", "rgba(251, 191, 36, 0.03)");
  nextZone.setAttribute("stroke", "rgba(251, 191, 36, 0.2)");
  nextZone.setAttribute("stroke-width", "2");
  nextZone.setAttribute("rx", 10);
  svg.appendChild(nextZone);
  
  // Repair zone
  const repairZone = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  repairZone.setAttribute("x", 450);
  repairZone.setAttribute("y", 60);
  repairZone.setAttribute("width", 200);
  repairZone.setAttribute("height", 380);
  repairZone.setAttribute("fill", "rgba(0, 240, 255, 0.03)");
  repairZone.setAttribute("stroke", "rgba(0, 240, 255, 0.2)");
  repairZone.setAttribute("stroke-width", "2");
  repairZone.setAttribute("rx", 10);
  svg.appendChild(repairZone);
  
  // Exit zone
  const exitZone = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  exitZone.setAttribute("x", 780);
  exitZone.setAttribute("y", 60);
  exitZone.setAttribute("width", 140);
  exitZone.setAttribute("height", 380);
  exitZone.setAttribute("fill", "rgba(16, 185, 129, 0.03)");
  exitZone.setAttribute("stroke", "rgba(16, 185, 129, 0.2)");
  exitZone.setAttribute("stroke-width", "2");
  exitZone.setAttribute("stroke-dasharray", "5 5");
  exitZone.setAttribute("rx", 10);
  svg.appendChild(exitZone);
  
  // Zone labels
  const labels = [
    { text: "QUEUE", x: 110, color: "rgba(251, 146, 60, 0.8)" },
    { text: "NEXT", x: 300, color: "rgba(251, 191, 36, 0.8)" },
    { text: "REPAIR BAY", x: 550, color: "rgba(0, 240, 255, 0.8)" },
    { text: "EXIT", x: 850, color: "rgba(16, 185, 129, 0.8)" }
  ];
  
  labels.forEach(label => {
    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", label.x);
    text.setAttribute("y", 45);
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("fill", label.color);
    text.setAttribute("font-size", "12");
    text.setAttribute("font-weight", "600");
    text.textContent = label.text;
    svg.appendChild(text);
  });
  
  // Draw tracks
  for (let t = 1; t <= 4; t++) {
    const y = TRACK_Y[t];
    
    // Track background
    const trackBg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    trackBg.setAttribute("x", 20);
    trackBg.setAttribute("y", y - 20);
    trackBg.setAttribute("width", 900);
    trackBg.setAttribute("height", 40);
    trackBg.setAttribute("fill", "url(#trackGradient)");
    trackBg.setAttribute("rx", 20);
    trackBg.setAttribute("opacity", "0.2");
    svg.appendChild(trackBg);
    
    // Rails
    const rail1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
    rail1.setAttribute("x1", 30);
    rail1.setAttribute("y1", y - 8);
    rail1.setAttribute("x2", 910);
    rail1.setAttribute("y2", y - 8);
    rail1.setAttribute("stroke", "#475569");
    rail1.setAttribute("stroke-width", "2");
    rail1.setAttribute("opacity", "0.5");
    svg.appendChild(rail1);
    
    const rail2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
    rail2.setAttribute("x1", 30);
    rail2.setAttribute("y1", y + 8);
    rail2.setAttribute("x2", 910);
    rail2.setAttribute("y2", y + 8);
    rail2.setAttribute("stroke", "#475569");
    rail2.setAttribute("stroke-width", "2");
    rail2.setAttribute("opacity", "0.5");
    svg.appendChild(rail2);
    
    // Track number with delay
    const trackNum = document.createElementNS("http://www.w3.org/2000/svg", "text");
    trackNum.setAttribute("x", 430);
    trackNum.setAttribute("y", y + 5);
    trackNum.setAttribute("text-anchor", "end");
    trackNum.setAttribute("fill", "rgba(148, 163, 184, 0.8)");
    trackNum.setAttribute("font-size", "12");
    trackNum.setAttribute("font-weight", "600");
    trackNum.textContent = `T${t} (${TRACK_DELAYS[t]/1000}s)`;
    svg.appendChild(trackNum);
    
    // Flow arrows
    for (let i = 0; i < 3; i++) {
      const arrow = document.createElementNS("http://www.w3.org/2000/svg", "text");
      arrow.setAttribute("x", 380 + i * 100);
      arrow.setAttribute("y", y + 5);
      arrow.setAttribute("fill", "rgba(0, 240, 255, 0.2)");
      arrow.setAttribute("font-size", "16");
      arrow.textContent = "â†’";
      arrow.style.animation = `flowArrow ${2 + t * 0.3}s ease-in-out infinite`;
      arrow.style.animationDelay = `${i * 0.4}s`;
      svg.appendChild(arrow);
    }
  }
}

function createTrainElement(train, track, isEntering = false) {
  const div = document.createElement("div");
  div.className = "train";
  const fitness = (train.fitness_status || "Healthy").toLowerCase();
  div.classList.add(fitness);
  div.dataset.id = train.train_id;
  div.dataset.track = track;
  
  const y = TRACK_Y[track] || 250;
  
  // Set initial position based on role
  if (isEntering) {
    div.style.left = `${QUEUE_X_END}px`;
    div.style.top = `${y}px`;
    div.style.opacity = '0.5';
  } else {
    // Position based on current assignment
    if (trainsInRepair.get(track) === train.train_id) {
      div.style.left = `${REPAIR_X}px`;
      div.style.top = `${y}px`;
    } else if (nextTrainSlots.get(track) === train.train_id) {
      div.style.left = `${NEXT_TRAIN_X}px`;
      div.style.top = `${y}px`;
    } else {
      // In queue
      const queueIndex = trainQueue.indexOf(train.train_id);
      if (queueIndex >= 0) {
        const col = queueIndex % 2;
        const row = Math.floor(queueIndex / 2);
        div.style.left = `${QUEUE_X_START + col * 60}px`;
        div.style.top = `${120 + row * 60}px`;
        div.style.opacity = '0.7';
      } else {
        div.style.left = `${QUEUE_X_START}px`;
        div.style.top = `${y}px`;
      }
    }
  }
  
  // Days indicator
  const daysLeft = train.days_until_next_service || 0;
  let daysColor = '#10b981';
  if (daysLeft <= 0) {
    daysColor = '#ef4444';
  } else if (daysLeft <= DAYS_TO_MINOR) {
    daysColor = '#f59e0b';
  }
  
  const cycleInfo = trainDaysTracking.get(train.train_id);
  const cycleCount = cycleInfo?.cycleCount || 0;
  
  div.innerHTML = `
    <div class="train-body">
      <div class="train-lights ${fitness}"></div>
      <div class="train-info">
        <div class="id">${train.train_id}</div>
        <div class="days-indicator" style="color: ${daysColor};">
          ${Math.round(daysLeft)}d
        </div>
      </div>
      ${track ? `<span class="track-badge">T${track}</span>` : ''}
      ${cycleCount > 0 ? `<span class="cycle-badge">C${cycleCount}</span>` : ''}
    </div>
  `;
  
  div.dataset.info = JSON.stringify(train);
  
  div.addEventListener('mouseenter', (e) => {
    createHoverParticles(e);
    div.style.zIndex = '10';
  });
  
  div.addEventListener('mouseleave', () => {
    div.style.zIndex = '1';
  });
  
  div.addEventListener('click', (e) => {
    e.stopPropagation();
    showDetailModal(train);
  });
  
  return div;
}

function updateYardTrains() {
  const layer = document.getElementById("trains-layer");
  
  localStatusData.forEach(train => {
    const existingTrain = layer.querySelector(`[data-id="${train.train_id}"]`);
    
    if (existingTrain) {
      const fitness = (train.fitness_status || "Healthy").toLowerCase();
      
      if (!healingTrains.has(train.train_id)) {
        existingTrain.className = `train ${fitness}`;
        if (exitingTrains.has(train.train_id)) {
          existingTrain.classList.add('exiting');
        }
      }
      
      existingTrain.dataset.info = JSON.stringify(train);
      
      const daysIndicator = existingTrain.querySelector('.days-indicator');
      if (daysIndicator) {
        const daysLeft = train.days_until_next_service || 0;
        let daysColor = '#10b981';
        if (daysLeft <= 0) {
          daysColor = '#ef4444';
        } else if (daysLeft <= DAYS_TO_MINOR) {
          daysColor = '#f59e0b';
        }
        daysIndicator.style.color = daysColor;
        daysIndicator.textContent = `${Math.round(daysLeft)}d`;
      }
      
      const lights = existingTrain.querySelector('.train-lights');
      if (lights && !healingTrains.has(train.train_id)) {
        lights.className = `train-lights ${fitness}`;
      }
    }
  });
}

function createHoverParticles(e) {
  const train = e.currentTarget;
  const rect = train.getBoundingClientRect();
  
  for (let i = 0; i < 6; i++) {
    const particle = document.createElement('div');
    particle.style.cssText = `
      position: fixed;
      width: 4px;
      height: 4px;
      background: linear-gradient(45deg, #00f0ff, #10b981);
      border-radius: 50%;
      left: ${rect.left + rect.width / 2}px;
      top: ${rect.bottom}px;
      pointer-events: none;
      z-index: 100;
    `;
    document.body.appendChild(particle);
    
    const angle = (Math.PI * 2 * i) / 6;
    const distance = 30 + Math.random() * 20;
    particle.animate([
      { transform: 'translate(0, 0) scale(1)', opacity: 1 },
      { transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`, opacity: 0 }
    ], {
      duration: 800,
      easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
    }).onfinish = () => particle.remove();
  }
}

// Rest of UI functions remain the same...
function animateStatCounter(element, newValue) {
  const current = parseInt(element.dataset.value) || 0;
  const duration = 1000;
  const start = Date.now();
  
  const animate = () => {
    const elapsed = Date.now() - start;
    const progress = Math.min(elapsed / duration, 1);
    const value = Math.floor(current + (newValue - current) * easeOutQuart(progress));
    
    element.textContent = value;
    
    if (progress < 1) {
      requestAnimationFrame(animate);
    } else {
      element.dataset.value = newValue;
    }
  };
  
  animate();
}

function easeOutQuart(t) {
  return 1 - Math.pow(1 - t, 4);
}

function updateSummaryCounts(statusData) {
  const total = statusData.length;
  const critical = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "critical").length;
  const minor = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "minor").length;
  const healthy = statusData.filter(t => (t.fitness_status||"").toLowerCase() === "healthy").length;
  
  animateStatCounter(document.querySelector('#stat-total .stat-value'), total);
  animateStatCounter(document.querySelector('#stat-critical .stat-value'), critical);
  animateStatCounter(document.querySelector('#stat-minor .stat-value'), minor);
  animateStatCounter(document.querySelector('#stat-healthy .stat-value'), healthy);
  
  updateHealthChart(critical, minor, healthy);
  updateChartCenterLabel(healthy, total);
}

function updateChartCenterLabel(healthy, total) {
  const percentage = total > 0 ? Math.round((healthy / total) * 100) : 0;
  document.querySelector('.chart-percentage').textContent = `${percentage}%`;
}

function updateHealthChart(critical, minor, healthy) {
  const ctx = document.getElementById("healthChart").getContext("2d");
  
  if (healthChart) {
    healthChart.data.datasets[0].data = [critical, minor, healthy];
    healthChart.update('active');
    return;
  }
  
  healthChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: ['Critical', 'Minor Issues', 'Healthy'],
      datasets: [{
        data: [critical, minor, healthy],
        backgroundColor: [
          'rgba(239, 68, 68, 0.8)',
          'rgba(245, 158, 11, 0.8)',
          'rgba(16, 185, 129, 0.8)'
        ],
        borderColor: [
          'rgba(239, 68, 68, 1)',
          'rgba(245, 158, 11, 1)',
          'rgba(16, 185, 129, 1)'
        ],
        borderWidth: 2,
        hoverOffset: 4
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      cutout: '70%',
      plugins: {
        legend: {
          position: 'bottom',
          labels: {
            color: '#94a3b8',
            padding: 15,
            font: { size: 11 }
          }
        }
      },
      animation: {
        animateRotate: true,
        animateScale: true,
        duration: 1500,
        easing: 'easeInOutQuart'
      }
    }
  });
}

function renderStatusTable(statusData, recData) {
  const tbody = document.getElementById("status-body");
  tbody.innerHTML = "";
  
  statusData.forEach((train, idx) => {
    const match = recData.find(r => r.train_id === train.train_id) || {};
    const fitness = (train.fitness_status || "Healthy").toLowerCase();
    const track = trackAssignments.get(train.train_id);
    const isInRepair = Array.from(trainsInRepair.values()).includes(train.train_id);
    const isNext = Array.from(nextTrainSlots.values()).includes(train.train_id);
    const inQueue = trainQueue.includes(train.train_id);
    const isExiting = exitingTrains.has(train.train_id);
    const isHealing = healingTrains.has(train.train_id);
    const cycleInfo = trainDaysTracking.get(train.train_id);
    
    let locationBadge = '';
    if (isHealing) {
      const healingInfo = healingTrains.get(train.train_id);
      const elapsed = Date.now() - healingInfo.startTime;
      const remainingHours = Math.ceil(((healingInfo.duration - elapsed) / 1000) * HOURS_PER_SECOND);
      locationBadge = `<span class="location-badge healing">Repairing (${remainingHours}h left)</span>`;
    } else if (isExiting) {
      locationBadge = `<span class="location-badge exiting">Exiting T${track}</span>`;
    } else if (isInRepair) {
      locationBadge = `<span class="location-badge in-repair">Repair Bay T${track}</span>`;
    } else if (isNext) {
      locationBadge = `<span class="location-badge next">Next T${track}</span>`;
    } else if (inQueue) {
      const queuePos = trainQueue.indexOf(train.train_id) + 1;
      locationBadge = `<span class="location-badge in-queue">Queue #${queuePos}</span>`;
    } else if (reEntryQueue.includes(train.train_id)) {
      locationBadge = `<span class="location-badge re-entry">Awaiting Re-entry</span>`;
    }
    
    const daysLeft = train.days_until_next_service || 0;
    let daysColor = '';
    if (daysLeft <= 0) {
      daysColor = 'critical-days';
    } else if (daysLeft <= DAYS_TO_MINOR) {
      daysColor = 'warning-days';
    }
    
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>
        <div style="display: flex; align-items: center; gap: 8px;">
          <i class="fas fa-train" style="color: ${fitness === 'healthy' ? '#10b981' : fitness === 'critical' ? '#ef4444' : '#f59e0b'}; font-size: 12px;"></i>
          ${train.train_id}
          ${locationBadge}
          ${cycleInfo?.cycleCount > 0 ? `<span class="cycle-indicator">Cycle ${cycleInfo.cycleCount}</span>` : ''}
        </div>
      </td>
      <td>${train.yard_position || 'â€”'}</td>
      <td class="${fitness}">
        <span style="display: inline-flex; align-items: center; gap: 6px;">
          <span class="status-dot ${fitness}"></span>
          ${train.fitness_status || 'Healthy'}
        </span>
      </td>
      <td>${train.next_service_due_date || 'â€”'}</td>
      <td>
        <span class="days-badge ${daysColor}">
          <i class="fas fa-clock" style="font-size: 10px; margin-right: 4px;"></i>
          ${Math.round(daysLeft)} days
        </span>
      </td>
      <td>${match.consequence_if_skipped || train.consequence_if_skipped || 'â€”'}</td>
    `;
    
    tbody.appendChild(tr);
    tr.style.animation = `tableRowSlide 0.3s ease-out ${idx * 0.02}s both`;
  });
  
  updateLastUpdateTime();
}

function renderRecommendations(activeRecs) {
  const container = document.getElementById("recommend-list");
  container.innerHTML = "";
  
  // Track status card
  const statusCard = document.createElement('div');
  statusCard.className = 'healing-status-card';
  statusCard.innerHTML = `
    <div style="font-weight: 600; margin-bottom: 12px; color: var(--accent-cyan);">
      <i class="fas fa-tools"></i> Track Status
    </div>
  `;
  
  for (let t = 1; t <= 4; t++) {
    const repairTrain = trainsInRepair.get(t);
    const nextTrain = nextTrainSlots.get(t);
    const healingInfo = repairTrain ? healingTrains.get(repairTrain) : null;
    
    const trackDiv = document.createElement('div');
    trackDiv.className = 'track-status-row';
    
    let repairStatus = 'Empty';
    let repairClass = 'empty';
    
    if (healingInfo) {
      const elapsed = Date.now() - healingInfo.startTime;
      const progress = Math.round((elapsed / healingInfo.duration) * 100);
      const remainingHours = Math.ceil(((healingInfo.duration - elapsed) / 1000) * HOURS_PER_SECOND);
      repairStatus = `
        <div style="display: flex; align-items: center; gap: 8px;">
          <span>${repairTrain}</span>
          <div class="healing-bar">
            <div class="healing-fill" style="width: ${progress}%"></div>
          </div>
          <span style="font-size: 0.7rem;">${remainingHours}h</span>
        </div>
      `;
      repairClass = 'healing';
    } else if (repairTrain) {
      const train = localStatusData.find(t => t.train_id === repairTrain);
      repairStatus = `${repairTrain} (${train?.fitness_status || 'Ready'})`;
      repairClass = train?.fitness_status?.toLowerCase() || 'ready';
    }
    
    trackDiv.innerHTML = `
      <div class="track-label">T${t}</div>
      <div class="track-positions">
        <div class="position-box ${repairClass}">
          <span class="position-label">Repair:</span>
          <span>${repairStatus}</span>
        </div>
        <div class="position-box next">
          <span class="position-label">Next:</span>
          <span>${nextTrain || 'Empty'}</span>
        </div>
      </div>
    `;
    statusCard.appendChild(trackDiv);
  }
  
  statusCard.innerHTML += `
    <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color);">
      <div style="display: flex; justify-content: space-between; font-size: 0.875rem;">
        <span>Queue</span>
        <span style="color: var(--warning);">${trainQueue.length}</span>
      </div>
      <div style="display: flex; justify-content: space-between; font-size: 0.875rem; margin-top: 4px;">
        <span>Re-entry</span>
        <span style="color: var(--danger);">${reEntryQueue.length}</span>
      </div>
    </div>
    <div class="health-countdown" style="margin-top: 8px; text-align: center; font-size: 0.8rem; color: var(--accent-cyan);"></div>
  `;
  
  container.appendChild(statusCard);
}

function showDetailModal(obj) {
  const modal = document.getElementById("detail-modal");
  const content = document.getElementById("modal-content");
  const title = document.getElementById("modal-title");
  
  const fitness = (obj.fitness_status || "Healthy").toLowerCase();
  const statusColor = fitness === "critical" ? "#ef4444" : 
                      fitness === "minor" ? "#f59e0b" : "#10b981";
  const track = trackAssignments.get(obj.train_id);
  const daysLeft = obj.days_until_next_service || 0;
  const hoursLeft = Math.round(daysLeft * SECONDS_PER_DAY * HOURS_PER_SECOND);
  const cycleInfo = trainDaysTracking.get(obj.train_id);
  
  title.innerHTML = `
    <i class="fas fa-train" style="margin-right: 8px;"></i>
    Train ${obj.train_id} ${track ? `(Track ${track})` : ''}
  `;
  
  content.innerHTML = `
    <div style="display: grid; gap: 1rem;">
      <div style="display: flex; align-items: center; gap: 1rem; padding: 1rem; background: rgba(0, 240, 255, 0.05); border-radius: 8px;">
        <div style="width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; background: ${statusColor}20; border-radius: 50%;">
          <i class="fas fa-${fitness === 'critical' ? 'exclamation-triangle' : fitness === 'minor' ? 'exclamation-circle' : 'check-circle'}" style="font-size: 1.5rem; color: ${statusColor};"></i>
        </div>
        <div>
          <div style="font-size: 0.875rem; color: var(--text-secondary);">Current Status</div>
          <div style="font-size: 1.25rem; font-weight: 600; color: ${statusColor}; text-transform: capitalize;">${obj.fitness_status || 'Healthy'}</div>
          <div style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 4px;">
            <i class="fas fa-clock"></i> ${Math.round(daysLeft)} days (${hoursLeft} hours)
          </div>
          ${cycleInfo ? `<div style="font-size: 0.875rem; color: var(--text-secondary);">
            <i class="fas fa-sync"></i> Maintenance cycles completed: ${cycleInfo.cycleCount}
          </div>` : ''}
        </div>
      </div>
      
      <table style="width: 100%; border-collapse: collapse;">
        ${Object.entries(obj).filter(([key]) => !['recentlyHealed', 'exitTimer'].includes(key))
          .map(([key, value]) => {
          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          return `
            <tr style="border-bottom: 1px solid var(--border-color);">
              <td style="padding: 0.75rem; font-weight: 600; color: var(--text-secondary); width: 40%;">
                ${formattedKey}
              </td>
              <td style="padding: 0.75rem; color: var(--text-primary);">
                ${value ?? 'â€”'}
              </td>
            </tr>
          `;
        }).join('')}
      </table>
      
      <div style="display: flex; justify-content: flex-end; gap: 0.75rem; margin-top: 1rem;">
        <button onclick="closeModal()" style="padding: 0.75rem 1.5rem; background: transparent; border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; cursor: pointer;">
          Close
        </button>
      </div>
    </div>
  `;
  
  modal.classList.remove("hidden");
}

function closeModal() {
  document.getElementById("detail-modal").classList.add("hidden");
}

function updateLastUpdateTime() {
  const now = new Date();
  const timeStr = now.toLocaleTimeString('en-US', { 
    hour12: false,
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
  document.getElementById('last-update-time').textContent = timeStr;
}

// Enhanced styles
const enhancedStyles = document.createElement('style');
enhancedStyles.textContent = `
  #yard {
    height: 500px !important;
    position: relative;
    overflow: hidden !important;
  }
  
  #tracks-svg, #trains-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  
  .train {
    min-width: 80px;
    max-width: 100px;
    padding: 6px;
    position: absolute;
    transform: translate(-50%, -50%);
    transition: left 1.5s ease-out, top 1.5s ease-out, opacity 1s ease-out;
    cursor: pointer;
    z-index: 1;
  }
  
  .train.healing {
    animation: healingPulse 2s ease-in-out infinite;
    z-index: 5;
  }
  
  @keyframes healingPulse {
    0%, 100% { 
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.4);
      transform: translate(-50%, -50%) scale(1);
    }
    50% { 
      box-shadow: 0 0 40px rgba(0, 240, 255, 0.8);
      transform: translate(-50%, -50%) scale(1.05);
    }
  }
  
  .train.exiting {
    animation: exitPulse 1s ease-in-out infinite;
  }
  
  @keyframes exitPulse {
    0%, 100% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.5); }
    50% { box-shadow: 0 0 40px rgba(16, 185, 129, 0.8); }
  }
  
  .train-body {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    position: relative;
  }
  
  .train-lights {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    animation: lightPulse 1s ease-in-out infinite;
  }
  
  .train-lights.critical {
    background: #ef4444;
    box-shadow: 0 0 15px #ef4444;
  }
  
  .train-lights.minor {
    background: #f59e0b;
    box-shadow: 0 0 12px #f59e0b;
  }
  
  .train-lights.healthy {
    background: #10b981;
    box-shadow: 0 0 8px #10b981;
  }
  
  @keyframes lightPulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(0.9); }
  }
  
  .days-indicator {
    font-size: 10px;
    font-weight: 700;
    padding: 1px 3px;
    border-radius: 3px;
    background: rgba(0, 0, 0, 0.3);
  }
  
  .track-badge {
    position: absolute;
    top: -6px;
    right: -6px;
    background: linear-gradient(135deg, #3b82f6, #2563eb);
    color: white;
    padding: 1px 4px;
    border-radius: 4px;
    font-size: 0.55rem;
    font-weight: 700;
  }
  
  .cycle-badge {
    position: absolute;
    top: -6px;
    left: -6px;
    background: linear-gradient(135deg, #8b5cf6, #7c3aed);
    color: white;
    padding: 1px 4px;
    border-radius: 4px;
    font-size: 0.55rem;
    font-weight: 700;
  }
  
  .healing-progress {
    position: absolute;
    bottom: -20px;
    left: 50%;
    transform: translateX(-50%);
    width: 70px;
    background: rgba(0, 0, 0, 0.8);
    padding: 3px;
    border-radius: 4px;
    z-index: 10;
  }
  
  .progress-bar {
    height: 3px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 2px;
    overflow: hidden;
  }
  
  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #00f0ff, #10b981);
    transition: width 0.5s ease;
  }
  
  .progress-time {
    text-align: center;
    font-size: 0.6rem;
    color: #00f0ff;
    margin-top: 1px;
  }
  
  .exit-badge {
    position: absolute;
    bottom: -8px;
    background: linear-gradient(135deg, #10b981, #059669);
    color: white;
    padding: 1px 6px;
    border-radius: 8px;
    font-size: 0.6rem;
    font-weight: 700;
    animation: exitBadgePulse 1s ease-in-out infinite;
  }
  
  @keyframes exitBadgePulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }
  
  .location-badge {
    padding: 2px 6px;
    border-radius: 8px;
    font-size: 0.65rem;
    font-weight: 600;
    margin-left: 4px;
  }
  
  .location-badge.healing {
    background: linear-gradient(135deg, rgba(0, 240, 255, 0.3), rgba(0, 240, 255, 0.1));
    color: #00f0ff;
    animation: blink 0.5s ease-in-out infinite;
  }
  
  .location-badge.in-repair {
    background: rgba(59, 130, 246, 0.2);
    color: #3b82f6;
  }
  
  .location-badge.next {
    background: rgba(251, 191, 36, 0.2);
    color: #fbbf24;
  }
  
  .location-badge.in-queue {
    background: rgba(251, 146, 60, 0.2);
    color: #fb923c;
  }
  
  .location-badge.re-entry {
    background: rgba(139, 92, 246, 0.2);
    color: #a78bfa;
  }
  
  .location-badge.exiting {
    background: rgba(16, 185, 129, 0.2);
    color: #10b981;
    animation: blink 0.5s ease-in-out infinite;
  }
  
  .cycle-indicator {
    font-size: 0.6rem;
    padding: 1px 4px;
    background: rgba(139, 92, 246, 0.2);
    color: #a78bfa;
    border-radius: 6px;
    margin-left: 4px;
  }
  
  .days-badge {
    display: inline-flex;
    align-items: center;
    padding: 2px 6px;
    background: rgba(148, 163, 184, 0.1);
    border-radius: 10px;
    font-size: 0.75rem;
    font-weight: 600;
  }
  
  .days-badge.warning-days {
    background: rgba(245, 158, 11, 0.2);
    color: #fbbf24;
  }
  
  .days-badge.critical-days {
    background: rgba(239, 68, 68, 0.2);
    color: #fca5a5;
    animation: urgentPulse 1s ease-in-out infinite;
  }
  
  @keyframes urgentPulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
    50% { box-shadow: 0 0 8px 2px rgba(239, 68, 68, 0.3); }
  }
  
  .healing-status-card {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(37, 99, 235, 0.05));
    border: 1px solid rgba(59, 130, 246, 0.3);
    border-radius: 12px;
    padding: 12px;
    margin-bottom: 12px;
  }
  
  .track-status-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 0;
    border-bottom: 1px solid rgba(148, 163, 184, 0.1);
  }
  
  .track-label {
    font-weight: 600;
    color: var(--accent-cyan);
    min-width: 40px;
    font-size: 0.8rem;
  }
  
  .track-positions {
    display: flex;
    gap: 8px;
    flex: 1;
  }
  
  .position-box {
    flex: 1;
    font-size: 0.7rem;
    padding: 3px 6px;
    border-radius: 6px;
    background: rgba(148, 163, 184, 0.1);
    display: flex;
    flex-direction: column;
    gap: 2px;
  }
  
  .position-label {
    font-size: 0.6rem;
    opacity: 0.7;
  }
  
  .position-box.critical {
    background: rgba(239, 68, 68, 0.15);
    color: #ef4444;
  }
  
  .position-box.minor {
    background: rgba(245, 158, 11, 0.15);
    color: #f59e0b;
  }
  
  .position-box.healing {
    background: rgba(0, 240, 255, 0.1);
    color: #00f0ff;
  }
  
  .position-box.next {
    background: rgba(251, 191, 36, 0.1);
    color: #fbbf24;
  }
  
  .healing-bar {
    width: 60px;
    height: 4px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
    overflow: hidden;
    display: inline-block;
  }
  
  .healing-fill {
    height: 100%;
    background: linear-gradient(90deg, #00f0ff, #10b981);
    transition: width 0.5s ease;
  }
  
  @keyframes statusChange {
    0% { transform: translate(-50%, -50%) scale(1.2); }
    100% { transform: translate(-50%, -50%) scale(1); }
  }
  
  @keyframes healWave {
    0% { 
      transform: scale(0.8);
      opacity: 0;
    }
    50% { 
      transform: scale(1.2);
      opacity: 1;
    }
    100% { 
      transform: scale(1.4);
      opacity: 0;
    }
  }
  
  @keyframes flowArrow {
    0%, 100% { opacity: 0.2; transform: translateX(0); }
    50% { opacity: 0.6; transform: translateX(10px); }
  }
  
  @keyframes slideInLeft {
    from { transform: translateX(-100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes slideOutLeft {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(-100%); opacity: 0; }
  }
  
  @keyframes slideInRight {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes slideOutRight {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
  }
  
  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }
`;
document.head.appendChild(enhancedStyles);

// Main refresh function
async function refreshAll() {
  try {
    const { statusData, recData } = await fetchAll();
    
    if (isInitialLoad) {
      backendStatusData = [...statusData];
      localStatusData = [...statusData];
      currentRecData = recData;
      isInitialLoad = false;
      
      initializeDepotPositions();
    } else {
      backendStatusData = [...statusData];
      localStatusData = statusData.map(backendTrain => {
        const localTrain = localStatusData.find(t => t.train_id === backendTrain.train_id);
        if (localTrain && (healingTrains.has(backendTrain.train_id) || exitingTrains.has(backendTrain.train_id))) {
          return {
            ...backendTrain,
            fitness_status: localTrain.fitness_status,
            days_until_next_service: localTrain.days_until_next_service,
            consequence_if_skipped: localTrain.consequence_if_skipped,
            exitTimer: localTrain.exitTimer
          };
        }
        return backendTrain;
      });
      currentRecData = recData;
    }
    
    updateAllVisualizations();
    
    // Render yard
    renderTracksSVG();
    const layer = document.getElementById("trains-layer");
    
    if (layer.children.length === 0 || isInitialLoad) {
      layer.innerHTML = "";
      
      // Create all visible trains
      localStatusData.forEach(train => {
        const track = trackAssignments.get(train.train_id) || 0;
        if (track || trainQueue.includes(train.train_id)) {
          const el = createTrainElement(train, track, false);
          if (el) layer.appendChild(el);
        }
      });
    } else {
      updateYardTrains();
    }
    
  } catch (err) {
    console.error("Error refreshing:", err);
  }
}

------------------------------------------------  12--------------------------


